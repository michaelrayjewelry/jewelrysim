<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>JEWELFORGE — 3-Cycle Intelligence Engine</title>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,600;1,300;1,400&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" crossorigin="anonymous"></script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --gold:#c9a84c;--gold-l:#e8c97a;--gold-d:#8a6e30;--gold-x:#4a3a18;
  --bg:#060606;--s1:#0d0d0d;--s2:#141414;--s3:#1c1c1c;
  --txt:#e8e4dc;--dim:#8a8680;--faint:#3a3a38;--xfaint:#1e1e1e;
  --grn:#4caf7d;--red:#b5332a;--blu:#4a7fa8;--purp:#7b6fa8;
  --bdr:rgba(201,168,76,0.14);
}
html{scroll-behavior:smooth}
body{background:var(--bg);color:var(--txt);font-family:'Rajdhani',sans-serif;overflow-x:hidden}
body::before{content:'';position:fixed;inset:0;background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.02'/%3E%3C/svg%3E");pointer-events:none;z-index:9999;opacity:.6}

/* NAV */
nav{position:fixed;top:0;left:0;right:0;z-index:500;background:rgba(6,6,6,.94);backdrop-filter:blur(20px);border-bottom:1px solid var(--bdr);display:flex;align-items:center;justify-content:space-between;padding:0 2rem;gap:1rem;flex-wrap:wrap;height:56px}
nav::after{content:'';position:absolute;bottom:-1px;left:0;right:0;height:1px;background:linear-gradient(90deg,transparent,var(--gold-d),var(--gold),var(--gold-d),transparent)}
.nav-logo{font-family:'Cormorant Garamond',serif;font-size:1.1rem;letter-spacing:.38em;color:var(--gold);font-weight:300;flex-shrink:0;display:flex;align-items:center;gap:.65rem}
.nav-logo-icon{width:28px;height:28px;border:1px solid var(--gold-d);border-radius:6px;display:flex;align-items:center;justify-content:center;position:relative;transform:rotate(45deg)}
.nav-logo-icon::before{content:'';width:10px;height:10px;background:var(--gold);transform:rotate(-45deg);clip-path:polygon(50% 0%,100% 50%,50% 100%,0% 50%)}
.nav-logo-icon::after{content:'';position:absolute;inset:3px;border:1px solid rgba(201,168,76,.3)}
.nav-tabs{display:flex;gap:0;height:100%}
.nav-tab{padding:0 1.1rem;font-size:.62rem;letter-spacing:.18em;text-transform:uppercase;border:none;border-bottom:2px solid transparent;color:var(--faint);cursor:pointer;transition:all .25s;background:none;font-family:'Rajdhani',sans-serif;font-weight:500;height:100%;display:flex;align-items:center;gap:.4rem;position:relative}
.nav-tab:hover{color:var(--dim);background:rgba(201,168,76,.02)}
.nav-tab.active{border-bottom-color:var(--gold);color:var(--gold);background:rgba(201,168,76,.04)}
.nav-tab.done{border-bottom-color:var(--grn);color:var(--grn)}
.nav-tab .nt-step{width:18px;height:18px;border:1px solid currentColor;display:inline-flex;align-items:center;justify-content:center;font-size:.5rem;font-weight:700;opacity:.6;flex-shrink:0}
.nav-tab.active .nt-step{opacity:1;border-color:var(--gold);box-shadow:0 0 6px rgba(201,168,76,.2)}
.nav-tab.done .nt-step{background:var(--grn);border-color:var(--grn);color:var(--bg)}
.nav-epoch{font-size:.6rem;letter-spacing:.22em;color:var(--faint);text-transform:uppercase;display:flex;align-items:center;gap:.6rem}
.nav-epoch span{color:var(--gold);font-family:'Cormorant Garamond',serif;font-size:.95rem;font-weight:400}
.nav-epoch-bar{width:48px;height:3px;background:var(--xfaint);overflow:hidden;border-radius:2px}
.nav-epoch-fill{height:100%;background:linear-gradient(90deg,var(--gold-d),var(--gold));border-radius:2px;transition:width .6s ease;width:0%}

/* SCREENS */
main{padding-top:56px}
.screen{display:none;min-height:calc(100vh - 56px);padding:2.5rem 2rem;max-width:1140px;margin:0 auto}
.screen.active{display:block}

/* TYPOGRAPHY */
.eyebrow{font-size:.62rem;letter-spacing:.42em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.7rem}
.h1{font-family:'Cormorant Garamond',serif;font-size:clamp(1.8rem,3.5vw,2.8rem);font-weight:300;line-height:1.1;margin-bottom:.4rem}
.h1 em{font-style:italic;color:var(--gold)}
.h2{font-family:'Cormorant Garamond',serif;font-size:1.5rem;font-weight:400;margin-bottom:.8rem}
.h2 em{font-style:italic;color:var(--gold)}
.rule{width:36px;height:1px;background:var(--gold);margin:1rem 0 1.8rem}
.sub{color:var(--dim);font-size:.9rem;line-height:1.75;max-width:580px;margin-bottom:2rem}
.label{font-size:.6rem;letter-spacing:.3em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.5rem}

/* BUTTONS */
.btn{display:inline-flex;align-items:center;gap:.4rem;padding:.7rem 1.6rem;font-family:'Rajdhani',sans-serif;font-size:.75rem;font-weight:600;letter-spacing:.2em;text-transform:uppercase;border:1px solid var(--gold);color:var(--gold);background:transparent;cursor:pointer;transition:all .25s;border-radius:10px}
.btn:hover{background:rgba(201,168,76,.1)}
.btn-primary{background:linear-gradient(135deg,var(--gold),var(--gold-d));color:var(--bg);border-color:var(--gold);box-shadow:0 2px 12px rgba(201,168,76,.2)}
.btn-primary:hover{background:linear-gradient(135deg,var(--gold-l),var(--gold));box-shadow:0 4px 20px rgba(201,168,76,.3)}
.btn-ghost{border-color:var(--faint);color:var(--dim)}
.btn-ghost:hover{border-color:var(--dim);color:var(--txt)}
.btn:disabled{opacity:.4;cursor:not-allowed;pointer-events:none}
.btn-sm{padding:.4rem 1rem;font-size:.65rem}

/* ═══ SCREEN 1: BUILDER (Soft Tech-Forward) ═══ */
.builder-layout{display:flex;flex-direction:column;gap:1.8rem;max-width:640px;margin:0 auto 1.5rem}
.bsec{background:linear-gradient(135deg,rgba(20,20,20,.95),rgba(13,13,13,.98));border:1px solid rgba(201,168,76,.1);padding:1.8rem 2rem;border-radius:16px;position:relative;overflow:hidden;backdrop-filter:blur(4px)}
.bsec::before{content:'';position:absolute;inset:0;border-radius:16px;background:radial-gradient(ellipse at 30% 0%,rgba(201,168,76,.04),transparent 60%);pointer-events:none}
.bsec h4{font-size:.62rem;letter-spacing:.32em;color:var(--gold-d);text-transform:uppercase;margin-bottom:1.2rem;padding-bottom:.6rem;border-bottom:1px solid rgba(201,168,76,.08);display:flex;align-items:center;gap:.6rem}
.bsec h4 .sec-icon{font-size:1rem;opacity:.7}
.field{margin-bottom:1.3rem}
.field label{display:block;font-size:.68rem;letter-spacing:.14em;color:var(--dim);text-transform:uppercase;margin-bottom:.45rem;font-weight:500}
.field input,.field textarea{width:100%;background:rgba(20,20,20,.7);border:1px solid rgba(58,58,56,.5);color:var(--txt);padding:.7rem 1rem;font-family:'Rajdhani',sans-serif;font-size:.9rem;outline:none;transition:all .3s ease;border-radius:10px}
.field input:focus,.field textarea:focus{border-color:rgba(201,168,76,.4);box-shadow:0 0 16px rgba(201,168,76,.08);background:rgba(20,20,20,.9)}
.field textarea{resize:vertical;min-height:80px;line-height:1.7}
.field input::placeholder,.field textarea::placeholder{color:var(--faint);font-style:italic}

/* Category sliders — soft gamified look */
.cat-slider{margin-bottom:1.4rem;position:relative}
.cat-slider-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:.5rem}
.cat-slider-label{display:flex;align-items:center;gap:.5rem;font-size:.78rem;color:var(--dim);font-weight:500;letter-spacing:.05em}
.cat-slider-label .cat-icon{font-size:1.1rem;filter:grayscale(.3)}
.cat-slider-val{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--gold);min-width:28px;text-align:right;transition:all .2s}
.cat-slider-track{position:relative;height:8px;background:rgba(58,58,56,.4);border-radius:4px;overflow:hidden}
.cat-slider-fill{height:100%;border-radius:4px;transition:width .15s ease;background:linear-gradient(90deg,var(--gold-d),var(--gold-l))}
.cat-slider input[type=range]{position:absolute;top:0;left:0;width:100%;height:8px;-webkit-appearance:none;background:transparent;outline:none;cursor:pointer;margin:0;z-index:2}
.cat-slider input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:radial-gradient(circle,var(--gold-l) 30%,var(--gold) 100%);border-radius:50%;cursor:pointer;box-shadow:0 0 8px rgba(201,168,76,.35);transition:transform .15s ease,box-shadow .15s ease}
.cat-slider input[type=range]::-webkit-slider-thumb:hover{transform:scale(1.2);box-shadow:0 0 14px rgba(201,168,76,.5)}
.cat-slider input[type=range]::-moz-range-thumb{width:18px;height:18px;background:radial-gradient(circle,var(--gold-l) 30%,var(--gold) 100%);border-radius:50%;border:none;cursor:pointer;box-shadow:0 0 8px rgba(201,168,76,.35)}
.cat-slider-hint{display:flex;justify-content:space-between;font-size:.58rem;color:var(--faint);margin-top:.35rem;letter-spacing:.05em}

/* Legacy sr/chip support for non-builder screens */
.sr{display:flex;align-items:center;gap:.7rem;margin-bottom:.9rem}
.sr label{font-size:.75rem;color:var(--dim);flex:1}
.sr .sv{font-family:'Cormorant Garamond',serif;font-size:1rem;color:var(--gold);width:28px;text-align:right;flex-shrink:0}
input[type=range]{flex:1;-webkit-appearance:none;height:2px;background:var(--faint);outline:none;cursor:pointer}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:11px;height:11px;background:var(--gold);cursor:pointer}
.chips{display:flex;flex-wrap:wrap;gap:.35rem}
.chip{padding:.25rem .65rem;font-size:.62rem;letter-spacing:.1em;text-transform:uppercase;border:1px solid var(--faint);color:var(--faint);cursor:pointer;transition:all .2s;user-select:none}
.chip:hover{border-color:var(--dim);color:var(--dim)}
.chip.on{border-color:var(--gold);color:var(--gold);background:rgba(201,168,76,.06)}
.auto-link{font-size:.65rem;letter-spacing:.15em;color:var(--gold-d);text-decoration:none;background:rgba(201,168,76,.06);border:1px solid rgba(201,168,76,.15);cursor:pointer;font-family:'Rajdhani',sans-serif;padding:.35rem .8rem;border-radius:8px;transition:all .25s;display:inline-flex;align-items:center;gap:.3rem}
.auto-link:hover{background:rgba(201,168,76,.12);border-color:rgba(201,168,76,.3);color:var(--gold)}

/* Preview card — soft rounded */
.preview-box{background:linear-gradient(135deg,rgba(20,20,20,.95),rgba(13,13,13,.98));border:1px solid rgba(201,168,76,.12);padding:1.6rem 1.8rem;margin-top:1.5rem;border-radius:16px;position:relative;overflow:hidden}
.preview-box::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;background:linear-gradient(90deg,transparent,var(--gold-d),var(--gold),var(--gold-d),transparent);border-radius:2px}
.prow{display:flex;align-items:baseline;gap:.8rem;margin-bottom:.5rem}
.plabel{font-size:.62rem;letter-spacing:.2em;color:var(--faint);text-transform:uppercase;width:86px;flex-shrink:0}
.pval{font-family:'Cormorant Garamond',serif;font-size:1.05rem;color:var(--txt)}
.dna-strip{display:flex;gap:4px;margin-top:.8rem;height:18px}
.dna-b{flex:1;border-radius:3px;transition:all .3s}

/* ═══ SCREEN 2: SIMULATOR ═══ */
.sim-topbar{display:flex;align-items:flex-start;justify-content:space-between;margin-bottom:1.8rem;gap:1rem;flex-wrap:wrap}
.cycle-indicator{display:flex;gap:8px;align-items:center}
.ci-dot{width:28px;height:28px;border:1px solid var(--faint);display:flex;align-items:center;justify-content:center;font-size:.6rem;letter-spacing:.1em;color:var(--faint);transition:all .4s;cursor:default}
.ci-dot.active{border-color:var(--gold);color:var(--gold);background:rgba(201,168,76,.08)}
.ci-dot.done{border-color:var(--grn);color:var(--grn);background:rgba(76,175,125,.06)}
.prog-bar{height:2px;background:var(--faint);margin-bottom:1.5rem;overflow:hidden}
.prog-fill{height:100%;background:linear-gradient(90deg,var(--gold-d),var(--gold));transition:width .6s ease;width:0%}
.phase-rail{display:flex;border:1px solid var(--bdr);margin-bottom:1.5rem;overflow-x:auto}
.pnode{flex:1;min-width:80px;padding:.7rem .4rem;text-align:center;background:var(--s1);border-right:1px solid var(--bdr);transition:all .3s}
.pnode:last-child{border-right:none}
.pnode.active{background:var(--s2);border-bottom:2px solid var(--gold)}
.pnode.done{background:rgba(76,175,125,.04);border-bottom:2px solid var(--grn)}
.pnode .pni{font-size:1rem;display:block;margin-bottom:.2rem}
.pnode .pnl{font-size:.58rem;letter-spacing:.1em;text-transform:uppercase;color:var(--faint)}
.pnode.active .pnl{color:var(--gold)}
.pnode.done .pnl{color:var(--grn)}
.sim-body{display:grid;grid-template-columns:220px 1fr;gap:1.5rem;min-height:360px}
@media(max-width:720px){.sim-body{grid-template-columns:1fr}}
.agents-col{background:var(--s1);border:1px solid var(--bdr);padding:1.2rem}
.agents-col h5{font-size:.58rem;letter-spacing:.3em;color:var(--gold-d);text-transform:uppercase;margin-bottom:1rem}
.arow{display:flex;align-items:center;gap:.6rem;padding:.5rem 0;border-bottom:1px solid var(--xfaint);transition:background .3s}
.arow:last-child{border-bottom:none}
.arow.highlight{background:rgba(201,168,76,.04)}
.av{width:26px;height:26px;border:1px solid var(--bdr);display:flex;align-items:center;justify-content:center;font-size:.85rem;flex-shrink:0}
.ai{flex:1;min-width:0}
.ai .an{font-size:.8rem;font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.ai .as{font-size:.68rem;color:var(--dim);margin-top:.05rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.acr{font-family:'Cormorant Garamond',serif;font-size:.95rem;color:var(--gold);flex-shrink:0;font-size:.82rem}
.log-col{background:var(--s1);border:1px solid var(--bdr);padding:1.2rem;display:flex;flex-direction:column}
.log-col h5{font-size:.58rem;letter-spacing:.3em;color:var(--gold-d);text-transform:uppercase;margin-bottom:1rem}
.log{flex:1;overflow-y:auto;max-height:320px;display:flex;flex-direction:column;gap:.35rem}
.log::-webkit-scrollbar{width:2px}
.log::-webkit-scrollbar-thumb{background:var(--gold-d)}
.le{font-size:.78rem;color:var(--dim);line-height:1.55;padding:.35rem .5rem;border-left:2px solid transparent;animation:slideIn .3s ease both}
.le.cv{border-left-color:var(--gold-d)}
.le.rp{border-left-color:var(--blu)}
.le.ds{border-left-color:var(--grn)}
.le.vt{border-left-color:var(--purp)}
.le.rs{border-left-color:var(--gold);color:var(--txt);font-weight:600}
.le .lt{font-size:.6rem;color:var(--faint);display:block;margin-bottom:.1rem}
.designs-wrap{margin-top:1.5rem}
.designs-wrap .dw-hdr{font-size:.58rem;letter-spacing:.35em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.8rem}
.dgrid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:1px;background:var(--bdr);border:1px solid var(--bdr)}
.dcard{background:var(--s1);transition:background .2s;overflow:hidden}
.dcard:hover{background:var(--s2)}
.dcard.winner-card{background:rgba(201,168,76,.06)}
/* inline card image */
.dcard-img-wrap{position:relative;width:100%;aspect-ratio:1;overflow:hidden;background:var(--s3);border-bottom:1px solid var(--bdr)}
.dcard-img{width:100%;height:100%;object-fit:cover;display:block;opacity:0;transition:opacity .7s ease}
.dcard-img.loaded{opacity:1}
.dcard-img-loader{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.4rem;background:linear-gradient(135deg,var(--s3) 0%,var(--s2) 50%,var(--s3) 100%);background-size:200% 200%;animation:shimmer2 2.5s ease infinite}
.dcard-img-loader.hidden{display:none}
.dcard-img-loader .di-gem{font-size:1.3rem;animation:pulse 1.5s infinite}
.dcard-img-loader .di-pct{font-family:'Cormorant Garamond',serif;font-size:.75rem;color:var(--gold-d);margin-top:.1rem}
.dcard-body{padding:.9rem}
@keyframes shimmer2{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
.dgem{font-size:1.4rem;text-align:center;margin-bottom:.4rem}
.dname{font-family:'Cormorant Garamond',serif;font-size:.9rem;text-align:center;margin-bottom:.15rem}
.dagent{font-size:.56rem;letter-spacing:.1em;color:var(--faint);text-transform:uppercase;text-align:center;margin-bottom:.5rem}
.dbar{display:flex;align-items:center;gap:.35rem;margin-bottom:.25rem}
.dbar-l{font-size:.58rem;color:var(--faint);width:24px}
.dbar-t{flex:1;height:2px;background:var(--faint)}
.dbar-f{height:100%;background:linear-gradient(90deg,var(--gold-d),var(--gold));transition:width .8s ease;width:0%}
.dcred{font-family:'Cormorant Garamond',serif;color:var(--gold);font-size:1rem;text-align:center;margin-top:.5rem}
.win-badge{font-size:.56rem;letter-spacing:.18em;color:var(--gold);border:1px solid var(--gold-d);padding:.12rem .4rem;display:block;text-align:center;text-transform:uppercase;margin-bottom:.3rem}
.sim-ctrl{display:flex;align-items:center;gap:.8rem;margin-top:1.2rem;flex-wrap:wrap}
.spd{display:flex;align-items:center;gap:.4rem;font-size:.62rem;letter-spacing:.15em;color:var(--dim);text-transform:uppercase}
.spd-btn{padding:.28rem .65rem;font-size:.62rem;border:1px solid var(--faint);color:var(--faint);background:none;cursor:pointer;font-family:'Rajdhani',sans-serif;transition:all .2s}
.spd-btn.on{border-color:var(--gold);color:var(--gold)}

/* ═══ DEPLOY PANEL ═══ */
.deploy-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);margin-top:1.5rem}
@media(max-width:720px){.deploy-grid{grid-template-columns:repeat(2,1fr)}}
.deploy-slot{background:var(--s1);padding:1.5rem;text-align:center;transition:all .4s}
.deploy-slot.deployed{background:rgba(201,168,76,.04);border-bottom:2px solid var(--gold)}
.deploy-slot.standby{opacity:.7}
.deploy-slot.standby:hover{opacity:1;background:var(--s2)}
.ds-emoji{font-size:1.8rem;margin-bottom:.5rem;transition:all .4s}
.ds-name{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--txt);margin-bottom:.15rem}
.ds-arch{font-size:.6rem;letter-spacing:.15em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.5rem}
.ds-phil{font-size:.72rem;color:var(--dim);font-style:italic;margin-bottom:.4rem;line-height:1.5}
.ds-tags{font-size:.58rem;letter-spacing:.1em;color:var(--faint);text-transform:uppercase;margin-bottom:.8rem}
.ds-status{font-size:.62rem;letter-spacing:.2em;color:var(--gold);text-transform:uppercase;margin-top:.5rem}
.deploy-counter{font-size:.7rem;letter-spacing:.2em;color:var(--dim);text-transform:uppercase;margin-bottom:1rem}
@keyframes deployPulse{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
.deploy-slot.just-deployed .ds-emoji{animation:deployPulse .5s ease}

/* ═══ ROSTER PANEL ═══ */
.roster-row{display:flex;gap:4px;flex-wrap:wrap;margin-bottom:1.2rem}
.roster-card{display:flex;align-items:center;gap:.5rem;background:var(--s1);border:1px solid var(--gold-d);padding:.4rem .8rem;animation:slideIn .3s ease both;border-radius:10px}
.rc-emoji{font-size:1.1rem}
.rc-info{min-width:0}
.rc-name{font-family:'Cormorant Garamond',serif;font-size:.85rem;color:var(--gold);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.rc-arch{font-size:.55rem;letter-spacing:.1em;color:var(--faint);text-transform:uppercase}

/* cycle-complete banner */
.cycle-complete{display:none;border:1px solid var(--gold-d);background:rgba(201,168,76,.04);padding:1.5rem;margin-top:1.5rem;animation:slideIn .5s ease}
.cycle-complete.show{display:block}
.cc-title{font-family:'Cormorant Garamond',serif;font-size:1.6rem;color:var(--gold);margin-bottom:.5rem}
.cc-sub{font-size:.85rem;color:var(--dim);margin-bottom:1.2rem}
.cc-winner{display:inline-flex;align-items:center;gap:.8rem;background:var(--s2);border:1px solid var(--bdr);padding:.8rem 1.2rem;margin-bottom:1.2rem}
.cc-winner-gem{font-size:1.5rem}
.cc-winner-name{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--gold)}
.cc-winner-by{font-size:.65rem;letter-spacing:.15em;color:var(--dim);text-transform:uppercase}
.cc-actions{display:flex;gap:.8rem;flex-wrap:wrap}

/* ═══ SCREEN 3: REPORTS ═══ */
.reports-layout{display:grid;grid-template-columns:200px 1fr;gap:1.5rem;min-height:70vh}
@media(max-width:720px){.reports-layout{grid-template-columns:1fr}}
.report-nav{background:var(--s1);border:1px solid var(--bdr);padding:1.2rem}
.report-nav h5{font-size:.58rem;letter-spacing:.3em;color:var(--gold-d);text-transform:uppercase;margin-bottom:1rem}
.rn-item{padding:.7rem .8rem;cursor:pointer;border:1px solid transparent;transition:all .2s;margin-bottom:2px}
.rn-item:hover{background:var(--s2)}
.rn-item.active{border-color:var(--gold-d);background:var(--s2)}
.rni-num{font-family:'Cormorant Garamond',serif;font-size:1.2rem;color:var(--gold);line-height:1}
.rni-label{font-size:.6rem;letter-spacing:.12em;color:var(--dim);text-transform:uppercase;margin-top:.15rem}
.rni-winner{font-size:.65rem;color:var(--faint);margin-top:.2rem;font-style:italic}
.rn-empty{font-size:.72rem;color:var(--faint);font-style:italic;padding:.5rem 0}
.report-view{background:var(--s1);border:1px solid var(--bdr);padding:2rem;overflow-y:auto;max-height:80vh}
.report-placeholder{display:flex;flex-direction:column;align-items:center;justify-content:center;height:300px;color:var(--faint)}
.rp-icon{font-size:2.5rem;margin-bottom:1rem;opacity:.4}
.rp-msg{font-size:.8rem;letter-spacing:.2em;text-transform:uppercase}

/* REPORT DOCUMENT */
.rdoc{font-family:'Rajdhani',sans-serif}
.rdoc-header{border-bottom:1px solid var(--gold-d);padding-bottom:1.2rem;margin-bottom:1.5rem}
.rdoc-title{font-family:'Cormorant Garamond',serif;font-size:1.8rem;font-weight:300;color:var(--gold);margin-bottom:.3rem}
.rdoc-meta{font-size:.65rem;letter-spacing:.2em;color:var(--dim);text-transform:uppercase}
.rsec{margin-bottom:2rem}
.rsec-hdr{font-size:.62rem;letter-spacing:.35em;color:var(--gold-d);text-transform:uppercase;border-bottom:1px solid var(--bdr);padding-bottom:.4rem;margin-bottom:1rem}
.rtable{width:100%;border-collapse:collapse;font-size:.78rem}
.rtable th{font-size:.58rem;letter-spacing:.2em;text-transform:uppercase;color:var(--gold-d);border-bottom:1px solid var(--bdr);padding:.5rem .7rem;text-align:left;background:var(--s2)}
.rtable td{padding:.55rem .7rem;border-bottom:1px solid var(--xfaint);color:var(--dim);vertical-align:top;line-height:1.5}
.rtable tr:last-child td{border-bottom:none}
.rtable tr:hover td{background:rgba(201,168,76,.02)}
.rtable .highlight-row td{color:var(--txt)}
.rtable .gold{color:var(--gold);font-family:'Cormorant Garamond',serif;font-size:.9rem}
.rtable .grn{color:var(--grn)}
.rtable .red{color:var(--red)}
.trend-grid{display:grid;grid-template-columns:1fr 1fr;gap:1px;background:var(--bdr);margin-bottom:1rem}
@media(max-width:600px){.trend-grid{grid-template-columns:1fr}}
.tcard{background:var(--s2);padding:1rem}
.tcard-label{font-size:.58rem;letter-spacing:.25em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.5rem}
.tcard-val{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--txt)}
.tcard-val.up{color:var(--grn)}
.tcard-val.down{color:var(--red)}
.tcard-sub{font-size:.72rem;color:var(--faint);margin-top:.2rem}
.fi-box{background:rgba(201,168,76,.04);border:1px solid var(--gold-d);padding:1.2rem;margin-top:.5rem}
.fi-title{font-size:.6rem;letter-spacing:.3em;color:var(--gold);text-transform:uppercase;margin-bottom:.8rem}
.fi-item{display:flex;gap:.7rem;margin-bottom:.6rem;font-size:.8rem;color:var(--dim);line-height:1.55}
.fi-item::before{content:'◆';color:var(--gold-d);font-size:.5rem;margin-top:.35rem;flex-shrink:0}
.prompt-box{background:var(--s3);border:1px solid var(--faint);padding:.7rem;font-size:.72rem;color:var(--grn);font-family:'Courier New',monospace;line-height:1.6;margin-top:.25rem}
.strat-badge{display:inline-block;font-size:.6rem;letter-spacing:.12em;text-transform:uppercase;padding:.15rem .5rem;border:1px solid}
.strat-exploit{border-color:var(--gold-d);color:var(--gold-d)}
.strat-explore{border-color:var(--blu);color:var(--blu)}
.strat-mutate{border-color:var(--purp);color:var(--purp)}
.exec-stats{display:grid;grid-template-columns:repeat(4,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);margin-bottom:1.5rem}
@media(max-width:600px){.exec-stats{grid-template-columns:repeat(2,1fr)}}
.es-item{background:var(--s2);padding:.9rem;text-align:center}
.es-val{font-family:'Cormorant Garamond',serif;font-size:1.5rem;color:var(--gold)}
.es-lbl{font-size:.58rem;letter-spacing:.2em;color:var(--faint);text-transform:uppercase;margin-top:.2rem}

/* ═══ IMAGE GALLERY ═══ */
.top3-gallery{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);margin:1.2rem 0}
@media(max-width:640px){.top3-gallery{grid-template-columns:1fr}}
.top3-card{background:var(--s2);display:flex;flex-direction:column}
.top3-card.gold-card{background:rgba(201,168,76,.06);border-bottom:2px solid var(--gold)}
.top3-img-wrap{position:relative;width:100%;aspect-ratio:.85;overflow:hidden;background:var(--s3)}
.top3-img{width:100%;height:100%;object-fit:cover;display:block;transition:opacity .6s ease;opacity:0}
.top3-img.loaded{opacity:1}
@keyframes shimmer{0%{background-position:-400px 0}100%{background-position:400px 0}}
.top3-img-loader{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:.6rem;background:linear-gradient(90deg,var(--s3) 25%,var(--s2) 50%,var(--s3) 75%);background-size:400px 100%;animation:shimmer 2s infinite linear}
.top3-img-loader .gem{font-size:1.6rem;animation:pulse 1.5s infinite}
.top3-img-loader .lbl{font-size:.58rem;letter-spacing:.25em;color:var(--faint);text-transform:uppercase}
.top3-img-loader .pct{font-family:'Cormorant Garamond',serif;font-size:.9rem;color:var(--gold-d)}
.top3-img-loader.hidden{display:none}
.top3-meta{padding:1rem}
.top3-rank{font-size:.6rem;letter-spacing:.25em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.3rem}
.top3-rank.first{color:var(--gold)}
.top3-name{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--txt);margin-bottom:.2rem}
.top3-by{font-size:.62rem;letter-spacing:.12em;color:var(--dim);text-transform:uppercase;margin-bottom:.6rem}
.top3-creds{font-family:'Cormorant Garamond',serif;font-size:1.2rem;color:var(--gold)}
.top3-creds-lbl{font-size:.58rem;color:var(--faint);letter-spacing:.15em;text-transform:uppercase}
.top3-strat{display:inline-block;font-size:.56rem;letter-spacing:.12em;text-transform:uppercase;padding:.1rem .4rem;border:1px solid;margin-top:.4rem}
.img-gen-status{font-size:.7rem;color:var(--dim);letter-spacing:.1em;margin-bottom:.8rem;display:flex;align-items:center;gap:.5rem}
.img-gen-status .dot{width:6px;height:6px;background:var(--gold);border-radius:50%;animation:pulse 1s infinite;flex-shrink:0}
.img-gen-status .dot.done{background:var(--grn);animation:none}

/* Report image strip */
.rdoc-top3{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);margin-bottom:1.5rem}
@media(max-width:580px){.rdoc-top3{grid-template-columns:1fr}}
.rdoc-imgcard{background:var(--s2)}
.rdoc-imgcard.rank1{border-top:2px solid var(--gold)}
.rdoc-imgcard.rank2{border-top:2px solid var(--dim)}
.rdoc-imgcard.rank3{border-top:2px solid var(--faint)}
.rdoc-img-wrap{width:100%;aspect-ratio:.85;overflow:hidden;background:var(--s3);position:relative}
.rdoc-img{width:100%;height:100%;object-fit:cover;opacity:0;transition:opacity .5s}
.rdoc-img.loaded{opacity:1}
.rdoc-img-placeholder{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:2rem;background:var(--s3)}
.rdoc-img-placeholder.hidden{display:none}
.rdoc-card-meta{padding:.8rem}
.rdoc-rank-badge{font-size:.58rem;letter-spacing:.22em;color:var(--faint);text-transform:uppercase;margin-bottom:.25rem}
.rdoc-rank-badge.r1{color:var(--gold)}
.rdoc-design-name{font-family:'Cormorant Garamond',serif;font-size:.95rem;color:var(--txt)}
.rdoc-design-by{font-size:.6rem;color:var(--dim);margin-top:.1rem}
.rdoc-design-creds{font-family:'Cormorant Garamond',serif;font-size:1rem;color:var(--gold);margin-top:.3rem}

/* ── KPI STRIP ── */
.kpi-strip{display:grid;grid-template-columns:repeat(6,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);margin-bottom:1.5rem}
@media(max-width:700px){.kpi-strip{grid-template-columns:repeat(3,1fr)}}
.kpi-cell{background:var(--s2);padding:.8rem .6rem;text-align:center}
.kpi-val{font-family:'Cormorant Garamond',serif;font-size:1.35rem;color:var(--gold);line-height:1}
.kpi-val.up{color:var(--grn)}
.kpi-val.down{color:var(--red)}
.kpi-val.neu{color:var(--txt)}
.kpi-lbl{font-size:.54rem;letter-spacing:.18em;color:var(--faint);text-transform:uppercase;margin-top:.3rem}

/* ── CORR BARS ── */
.corr-panel{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);margin-bottom:1rem}
.corr-card{background:var(--s2);padding:1rem}
.corr-dim{font-size:.58rem;letter-spacing:.22em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.6rem}
.corr-bar-track{height:6px;background:var(--faint);border-radius:3px;overflow:hidden;margin-bottom:.4rem}
.corr-bar-fill{height:100%;border-radius:3px;transition:width .8s ease}
.corr-bar-fill.aes{background:linear-gradient(90deg,var(--gold-d),var(--gold))}
.corr-bar-fill.nov{background:linear-gradient(90deg,#4a7fa8,#7bb8d4)}
.corr-bar-fill.pro{background:linear-gradient(90deg,#4caf7d,#7be0a8)}
.corr-r{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--txt)}
.corr-note{font-size:.65rem;color:var(--faint);margin-top:.2rem}
.corr-winner-badge{display:inline-block;font-size:.55rem;letter-spacing:.15em;color:var(--gold);border:1px solid var(--gold-d);padding:.1rem .4rem;text-transform:uppercase;margin-top:.3rem}

/* ── STRATEGY BATTLE ── */
.strat-battle{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);margin-bottom:1rem}
.sb-card{background:var(--s2);padding:1rem;position:relative}
.sb-card.sb-winner{background:rgba(201,168,76,.06)}
.sb-label{font-size:.58rem;letter-spacing:.2em;text-transform:uppercase;margin-bottom:.5rem}
.sb-creds{font-family:'Cormorant Garamond',serif;font-size:1.4rem;margin-bottom:.2rem}
.sb-sub{font-size:.65rem;color:var(--faint)}
.sb-win-flag{position:absolute;top:.6rem;right:.6rem;font-size:.52rem;letter-spacing:.12em;color:var(--gold);border:1px solid var(--gold-d);padding:.1rem .35rem;text-transform:uppercase}

/* ── CATEGORY HEAT MAP ── */
.cat-heat{width:100%;border-collapse:collapse;font-size:.78rem;margin-bottom:.5rem}
.cat-heat th{font-size:.56rem;letter-spacing:.18em;text-transform:uppercase;color:var(--gold-d);border-bottom:1px solid var(--bdr);padding:.5rem .7rem;text-align:left;background:var(--s2)}
.cat-heat td{padding:.55rem .7rem;border-bottom:1px solid var(--xfaint);color:var(--dim);vertical-align:middle}
.cat-heat tr:hover td{background:rgba(201,168,76,.02)}
.mini-bar{display:inline-block;height:4px;border-radius:2px;vertical-align:middle;margin-right:.4rem}

/* ── AGENT LEADERBOARD ── */
.agent-lb{width:100%;border-collapse:collapse;font-size:.78rem}
.agent-lb th{font-size:.56rem;letter-spacing:.18em;text-transform:uppercase;color:var(--gold-d);border-bottom:1px solid var(--bdr);padding:.5rem .7rem;background:var(--s2)}
.agent-lb td{padding:.55rem .7rem;border-bottom:1px solid var(--xfaint);color:var(--dim);vertical-align:middle}
.agent-lb tr:first-child td{color:var(--txt)}
.agent-lb .rank-num{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--faint);text-align:center}
.agent-lb .rank-num.r1{color:var(--gold)}
.agent-lb .rep-delta{font-size:.72rem}
.agent-lb .rep-up{color:var(--grn)}
.agent-lb .rep-dn{color:var(--red)}
.agent-lb .you-badge{font-size:.5rem;letter-spacing:.1em;color:var(--gold);border:1px solid var(--gold-d);padding:.05rem .3rem;margin-left:.3rem;text-transform:uppercase;vertical-align:middle}

/* ── VOTE FLOW ── */
.vflow-table{width:100%;border-collapse:collapse;font-size:.72rem}
.vflow-table th{font-size:.54rem;letter-spacing:.16em;text-transform:uppercase;color:var(--gold-d);border-bottom:1px solid var(--bdr);padding:.45rem .6rem;background:var(--s2)}
.vflow-table td{padding:.45rem .6rem;border-bottom:1px solid var(--xfaint);color:var(--dim);vertical-align:top}
.vflow-table tr:hover td{background:rgba(201,168,76,.02)}
.vf-alloc{display:inline-block;background:rgba(201,168,76,.08);border:1px solid var(--gold-x);padding:.1rem .4rem;font-size:.65rem;margin:.05rem .1rem .05rem 0;white-space:nowrap}
.vf-self{background:rgba(181,51,42,.08);border-color:rgba(181,51,42,.3);color:var(--red)}
.vote-insight{background:var(--s2);border:1px solid var(--bdr);padding:.8rem 1rem;font-size:.78rem;color:var(--dim);line-height:1.65;margin-top:.8rem}
.vote-insight b{color:var(--txt)}

/* ── TREND VELOCITY ── */
.trend-vel{display:flex;align-items:center;gap:1rem;margin-bottom:1rem}
.vel-meter{flex:1;height:8px;background:var(--faint);border-radius:4px;overflow:hidden}
.vel-fill{height:100%;border-radius:4px;background:linear-gradient(90deg,var(--gold-d),var(--gold-l));transition:width 1s ease}
.vel-score{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--gold);flex-shrink:0;width:44px;text-align:right}
.vel-label{font-size:.6rem;letter-spacing:.18em;color:var(--faint);text-transform:uppercase;flex-shrink:0;width:60px}
.trend-4grid{display:grid;grid-template-columns:repeat(2,1fr);gap:1px;background:var(--bdr)}
@media(max-width:500px){.trend-4grid{grid-template-columns:1fr}}

/* ── EPOCH ARC (Cycle 3 only) ── */
.epoch-arc{border:1px solid var(--gold-d);background:rgba(201,168,76,.03);padding:1.5rem;margin-bottom:1rem}
.epoch-arc-title{font-family:'Cormorant Garamond',serif;font-size:1.2rem;color:var(--gold);margin-bottom:1rem}
.epoch-timeline{display:grid;grid-template-columns:repeat(3,1fr);gap:0;background:var(--bdr)}
.et-node{background:var(--s2);padding:1rem;text-align:center;position:relative}
.et-node::after{content:'→';position:absolute;right:-10px;top:50%;transform:translateY(-50%);color:var(--gold-d);font-size:.9rem;z-index:1}
.et-node:last-child::after{display:none}
.et-cycle{font-size:.55rem;letter-spacing:.25em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.4rem}
.et-winner{font-family:'Cormorant Garamond',serif;font-size:.9rem;color:var(--txt);margin-bottom:.2rem}
.et-trend{font-size:.65rem;color:var(--dim)}
.et-creds{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--gold);margin-top:.3rem}
.epoch-insight{font-size:.82rem;color:var(--dim);line-height:1.75;margin-top:1.2rem;padding-top:1rem;border-top:1px solid var(--bdr)}
.epoch-insight b{color:var(--txt)}

/* ANIMATIONS */
@keyframes slideIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:none}}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
@keyframes pulse{0%,100%{opacity:.4}50%{opacity:1}}
.fade{animation:fadeIn .4s ease both}
.pulse{animation:pulse 1.5s infinite}

/* ═══ HOME / API KEY SCREEN ═══ */
.home-hero{text-align:center;padding:4rem 0 2.5rem;position:relative}
.home-hero::before{content:'';position:absolute;top:0;left:50%;transform:translateX(-50%);width:240px;height:240px;background:radial-gradient(circle,rgba(201,168,76,.06) 0%,transparent 70%);pointer-events:none}
.home-hero .h1{margin-bottom:.6rem;position:relative}
.home-hero .sub{margin:0 auto 2rem;text-align:center}

/* Hero gem icon */
.hero-gem{width:52px;height:52px;margin:0 auto 1.5rem;position:relative;display:flex;align-items:center;justify-content:center}
.hero-gem::before{content:'';width:36px;height:36px;background:transparent;border:1px solid var(--gold);transform:rotate(45deg);position:absolute;animation:goldGlow 3s ease infinite}
.hero-gem::after{content:'';width:18px;height:18px;background:linear-gradient(135deg,var(--gold),var(--gold-d));transform:rotate(45deg);position:absolute}
.hero-gem-inner{width:8px;height:8px;background:var(--gold-l);transform:rotate(45deg);position:absolute;z-index:1;box-shadow:0 0 12px rgba(201,168,76,.5)}

/* Step flow cards */
.home-steps{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);max-width:680px;margin:0 auto 2.5rem;position:relative}
.home-step{background:var(--s1);padding:1.3rem 1rem;text-align:center;position:relative;transition:all .3s;cursor:default}
.home-step:hover{background:var(--s2)}
.home-step::after{content:'→';position:absolute;right:-8px;top:50%;transform:translateY(-50%);color:var(--gold-d);font-size:.8rem;z-index:1}
.home-step:last-child::after{display:none}
.hs-num{font-family:'Cormorant Garamond',serif;font-size:1.6rem;color:var(--gold);line-height:1;margin-bottom:.4rem;text-shadow:0 0 8px rgba(201,168,76,.2)}
.hs-title{font-size:.62rem;letter-spacing:.22em;color:var(--txt);text-transform:uppercase;margin-bottom:.3rem;font-weight:600}
.hs-desc{font-size:.65rem;color:var(--faint);line-height:1.5}

/* Feature highlight strip */
.home-features{display:grid;grid-template-columns:repeat(4,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);max-width:680px;margin:0 auto 2.5rem}
.home-feat{background:var(--s1);padding:1rem .8rem;text-align:center;transition:background .3s}
.home-feat:hover{background:var(--s2)}
.hf-icon{font-size:1.3rem;margin-bottom:.4rem;display:block}
.hf-val{font-family:'Cormorant Garamond',serif;font-size:1.3rem;color:var(--gold);line-height:1;margin-bottom:.2rem}
.hf-lbl{font-size:.52rem;letter-spacing:.2em;color:var(--faint);text-transform:uppercase;line-height:1.4}

/* Mode toggle enhanced */
.mode-toggle{display:flex;gap:0;border:1px solid var(--bdr);margin:0 auto 2rem;max-width:420px;position:relative;overflow:hidden}
.mode-toggle::before{content:'';position:absolute;top:0;bottom:0;width:50%;background:rgba(201,168,76,.06);border-bottom:2px solid var(--gold);transition:transform .3s ease;z-index:0}
.mode-toggle.live-active::before{transform:translateX(100%)}
.mode-btn{flex:1;padding:.85rem 1rem;font-family:'Rajdhani',sans-serif;font-size:.68rem;font-weight:600;letter-spacing:.18em;text-transform:uppercase;background:transparent;color:var(--faint);border:none;cursor:pointer;transition:all .25s;position:relative;z-index:1}
.mode-btn.active{color:var(--gold)}
.mode-btn .mode-dot{display:inline-block;width:5px;height:5px;border-radius:50%;background:currentColor;margin-right:.4rem;vertical-align:middle;opacity:.5}
.mode-btn.active .mode-dot{opacity:1;box-shadow:0 0 6px currentColor}

/* API panel */
.api-panel{background:var(--s1);border:1px solid var(--bdr);padding:1.8rem;max-width:520px;margin:0 auto 2rem;display:none;position:relative}
.api-panel.show{display:block;animation:slideIn .3s ease both}
.api-panel::before{content:'';position:absolute;top:-1px;left:20%;right:20%;height:1px;background:linear-gradient(90deg,transparent,var(--gold-d),transparent)}
.api-panel h4{font-size:.6rem;letter-spacing:.32em;color:var(--gold-d);text-transform:uppercase;margin-bottom:1.1rem;padding-bottom:.6rem;border-bottom:1px solid var(--bdr)}
.api-field{margin-bottom:1.2rem}
.api-field label{display:block;font-size:.7rem;letter-spacing:.12em;color:var(--dim);text-transform:uppercase;margin-bottom:.4rem}
.api-field input{width:100%;background:var(--s2);border:1px solid var(--faint);color:var(--txt);padding:.65rem .85rem;font-family:'Rajdhani',sans-serif;font-size:.88rem;outline:none;transition:all .2s}
.api-field input:focus{border-color:var(--gold-d);box-shadow:0 0 8px rgba(201,168,76,.1)}
.api-field .api-hint{font-size:.65rem;color:var(--faint);margin-top:.3rem;line-height:1.5}
.api-status{display:flex;align-items:center;gap:.5rem;font-size:.7rem;color:var(--dim);margin-top:.5rem}
.api-status .dot{width:6px;height:6px;border-radius:50%;flex-shrink:0;transition:all .3s}
.api-status .dot.ok{background:var(--grn);box-shadow:0 0 6px rgba(76,175,125,.4)}
.api-status .dot.warn{background:var(--gold);box-shadow:0 0 6px rgba(201,168,76,.4)}
.api-status .dot.off{background:var(--faint)}

/* Google Drive panel */
.gdrive-panel{background:var(--s1);border:1px solid var(--bdr);padding:1.5rem;max-width:520px;margin:0 auto 1.5rem;border-radius:12px;position:relative}
.gdrive-panel::before{content:'';position:absolute;top:-1px;left:20%;right:20%;height:1px;background:linear-gradient(90deg,transparent,#4285f4,transparent)}
.gdrive-panel h4{font-size:.6rem;letter-spacing:.32em;color:#4285f4;text-transform:uppercase;margin-bottom:1rem;padding-bottom:.5rem;border-bottom:1px solid rgba(66,133,244,.15);display:flex;align-items:center;gap:.5rem}
.gdrive-panel h4 .gdrive-icon{font-size:1rem}
.gdrive-setup-steps{margin-bottom:.5rem}
.gdrive-step{display:flex;gap:.7rem;margin-bottom:.8rem;align-items:flex-start}
.gdrive-step-num{width:22px;height:22px;border:1px solid rgba(66,133,244,.3);border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:.6rem;color:#4285f4;flex-shrink:0;font-weight:600;margin-top:.1rem}
.gdrive-step-body{flex:1;min-width:0}
.gdrive-step-title{font-size:.72rem;color:var(--txt);font-weight:600;margin-bottom:.15rem}
.gdrive-step-desc{font-size:.68rem;color:var(--dim);line-height:1.55}
.gdrive-step-desc b{color:var(--txt)}
.gdrive-code{background:var(--s3);border:1px solid var(--faint);border-radius:6px;padding:.6rem .7rem;margin-top:.4rem;font-family:'Courier New',monospace;font-size:.6rem;color:var(--grn);line-height:1.5;position:relative;max-height:160px;overflow-y:auto}
.gdrive-code::-webkit-scrollbar{width:2px}
.gdrive-code::-webkit-scrollbar-thumb{background:var(--faint)}
.gdrive-copy-btn{position:sticky;bottom:0;right:0;float:right;background:var(--s2);border:1px solid var(--faint);color:var(--dim);font-family:'Rajdhani',sans-serif;font-size:.6rem;padding:.25rem .5rem;cursor:pointer;border-radius:4px;transition:all .2s;margin-top:.3rem}
.gdrive-copy-btn:hover{border-color:#4285f4;color:#4285f4}
.gdrive-status{display:flex;align-items:center;gap:.5rem;font-size:.7rem;color:var(--dim);margin-top:.6rem}
.gdrive-status .dot{width:6px;height:6px;border-radius:50%;flex-shrink:0;transition:all .3s}
.gdrive-status .dot.connected{background:#34a853;box-shadow:0 0 6px rgba(52,168,83,.4)}
.gdrive-status .dot.off{background:var(--faint)}
.gdrive-connect-btn{display:inline-flex;align-items:center;gap:.5rem;padding:.55rem 1.2rem;font-family:'Rajdhani',sans-serif;font-size:.72rem;font-weight:600;letter-spacing:.12em;text-transform:uppercase;border:1px solid rgba(66,133,244,.4);color:#4285f4;background:rgba(66,133,244,.06);cursor:pointer;transition:all .25s;border-radius:10px;margin-top:.8rem}
.gdrive-connect-btn:hover{background:rgba(66,133,244,.12);border-color:rgba(66,133,244,.6)}
.gdrive-connect-btn:disabled{opacity:.4;cursor:not-allowed}
.gdrive-connect-btn .g-logo{font-size:1rem}
.gdrive-counter{font-size:.62rem;letter-spacing:.15em;color:#34a853;margin-top:.4rem}
.gdrive-retry-btn{display:inline-flex;align-items:center;gap:.3rem;padding:.35rem .8rem;font-family:'Rajdhani',sans-serif;font-size:.62rem;font-weight:600;letter-spacing:.1em;text-transform:uppercase;border:1px solid rgba(234,67,53,.4);color:#ea4335;background:rgba(234,67,53,.08);cursor:pointer;transition:all .25s;border-radius:6px;margin-top:.4rem}
.gdrive-retry-btn:hover{background:rgba(234,67,53,.15);border-color:rgba(234,67,53,.6)}

/* Start button enhanced */
.home-start-wrap{text-align:center;padding:1rem 0 2rem;display:flex;flex-direction:column;align-items:center;gap:.7rem}
.home-start-wrap .btn-primary{padding:.85rem 2.2rem;font-size:.78rem;letter-spacing:.25em;position:relative;overflow:hidden}
.home-start-wrap .btn-primary::after{content:'';position:absolute;top:0;left:-100%;width:60%;height:100%;background:linear-gradient(90deg,transparent,rgba(255,255,255,.08),transparent);transition:left .5s}
.home-start-wrap .btn-primary:hover::after{left:120%}
.autopilot-btn{border-color:var(--purp)!important;color:var(--purp)!important;font-size:.68rem!important;letter-spacing:.18em;padding:.55rem 1.4rem!important}
.autopilot-btn:hover{background:rgba(123,111,168,.12)!important;border-color:#9b8fd0!important;color:#b8aee0!important}
.autopilot-btn:disabled{opacity:.35;border-color:var(--faint)!important;color:var(--faint)!important}
.autopilot-btn.running{animation:autopilot-pulse 1.5s ease-in-out infinite;border-color:var(--grn)!important;color:var(--grn)!important}
@keyframes autopilot-pulse{0%,100%{box-shadow:0 0 4px rgba(76,175,125,.2)}50%{box-shadow:0 0 16px rgba(76,175,125,.4)}}

/* Version badge */
.home-version{text-align:center;font-size:.55rem;letter-spacing:.2em;color:var(--faint);text-transform:uppercase;margin-top:1.5rem}
.home-version span{color:var(--gold-d)}

.sim-mode-badge{display:inline-flex;align-items:center;gap:.4rem;font-size:.58rem;letter-spacing:.18em;text-transform:uppercase;padding:.25rem .65rem;border:1px solid;margin-left:.8rem}
.sim-mode-badge.live{border-color:var(--grn);color:var(--grn);background:rgba(76,175,125,.06)}
.sim-mode-badge.sim{border-color:var(--faint);color:var(--faint)}

/* ═══ GENOME EVOLUTION CARDS ═══ */
.genome-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--bdr);border:1px solid var(--bdr);margin-bottom:1rem}
@media(max-width:700px){.genome-grid{grid-template-columns:repeat(2,1fr)}}
.genome-card{background:var(--s2);padding:1rem}
.genome-card-hdr{display:flex;align-items:center;gap:.5rem;margin-bottom:.7rem}
.genome-card-hdr .gc-emoji{font-size:1.1rem}
.genome-card-hdr .gc-name{font-family:'Cormorant Garamond',serif;font-size:.92rem;color:var(--txt)}
.genome-card-hdr .gc-badge{font-size:.5rem;letter-spacing:.1em;color:var(--gold);border:1px solid var(--gold-d);padding:.05rem .3rem;text-transform:uppercase;margin-left:auto}
.genome-delta{display:flex;align-items:center;gap:.4rem;margin-bottom:.35rem;font-size:.72rem;color:var(--dim)}
.genome-delta .gd-label{width:68px;flex-shrink:0;font-size:.62rem;letter-spacing:.08em;color:var(--faint);text-transform:uppercase}
.genome-delta .gd-bar{flex:1;height:3px;background:var(--faint);border-radius:2px;overflow:hidden;position:relative}
.genome-delta .gd-fill{height:100%;border-radius:2px;transition:width .8s ease}
.genome-delta .gd-arrow{font-size:.65rem;width:20px;text-align:center;flex-shrink:0}
.genome-delta .gd-arrow.up{color:var(--grn)}
.genome-delta .gd-arrow.down{color:var(--red)}
.genome-delta .gd-arrow.flat{color:var(--faint)}
.genome-tags{display:flex;flex-wrap:wrap;gap:.2rem;margin-top:.5rem}
.genome-tags .gt{font-size:.55rem;letter-spacing:.08em;text-transform:uppercase;padding:.1rem .35rem;border:1px solid var(--faint);color:var(--faint)}
.genome-tags .gt.new{border-color:var(--grn);color:var(--grn)}
.genome-tags .gt.lost{border-color:var(--red);color:var(--red);text-decoration:line-through}
.gc-belief{font-size:.65rem;color:var(--dim);margin-top:.5rem;font-style:italic;line-height:1.5}
.gc-belief b{color:var(--txt);font-style:normal}
.gc-summary{font-size:.62rem;color:var(--faint);margin-top:.4rem;line-height:1.5;padding-top:.4rem;border-top:1px solid var(--xfaint)}
.gc-result-badge{display:inline-block;font-size:.5rem;letter-spacing:.1em;text-transform:uppercase;padding:.08rem .3rem;margin-left:.3rem}
.gc-result-badge.win{border:1px solid var(--gold);color:var(--gold)}
.gc-result-badge.loss{border:1px solid var(--red);color:var(--red)}

/* ═══ DIALOGUE BUBBLES ═══ */
.dialogue-thread{background:var(--s2);border:1px solid var(--bdr);padding:1rem;margin:.6rem 0;border-radius:2px}
.dialogue-thread .dt-hdr{font-size:.58rem;letter-spacing:.25em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.6rem}
.dialogue-msg{display:flex;gap:.5rem;margin-bottom:.5rem;animation:slideIn .3s ease both}
.dialogue-msg .dm-avatar{width:22px;height:22px;border:1px solid var(--bdr);display:flex;align-items:center;justify-content:center;font-size:.75rem;flex-shrink:0}
.dialogue-msg .dm-body{flex:1;font-size:.76rem;color:var(--dim);line-height:1.55;background:var(--s1);padding:.4rem .6rem;border:1px solid var(--xfaint)}
.dialogue-msg .dm-body b{color:var(--txt)}
/* ═══ AGENT PROFILE MODAL ═══ */
.agent-modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.82);backdrop-filter:blur(8px);z-index:2000;display:none;align-items:center;justify-content:center;animation:fadeIn .2s ease}
.agent-modal-overlay.show{display:flex}
.agent-modal{background:var(--s1);border:1px solid var(--gold-d);max-width:520px;width:92%;max-height:85vh;overflow-y:auto;position:relative;animation:slideIn .3s ease both}
.agent-modal::-webkit-scrollbar{width:3px}
.agent-modal::-webkit-scrollbar-thumb{background:var(--gold-d)}
.agent-modal-close{position:absolute;top:.8rem;right:.8rem;background:none;border:1px solid var(--faint);color:var(--dim);width:28px;height:28px;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:.8rem;transition:all .2s;z-index:1}
.agent-modal-close:hover{border-color:var(--gold);color:var(--gold)}
.am-header{display:flex;align-items:center;gap:1.2rem;padding:1.5rem 1.5rem 1rem;border-bottom:1px solid var(--xfaint)}
.am-avatar{width:80px;height:80px;image-rendering:pixelated;border:2px solid var(--gold-d);flex-shrink:0}
.am-identity h2{font-family:'Cormorant Garamond',serif;font-size:1.3rem;color:var(--gold);font-weight:400;letter-spacing:.06em}
.am-identity .am-arch{font-size:.6rem;letter-spacing:.2em;color:var(--faint);text-transform:uppercase;margin-top:.2rem}
.am-identity .am-phil{font-size:.72rem;color:var(--dim);font-style:italic;margin-top:.35rem;line-height:1.5}
.am-stats{display:grid;grid-template-columns:repeat(3,1fr);gap:1px;background:var(--xfaint);margin:0 1.5rem;border:1px solid var(--xfaint)}
.am-stat{background:var(--s1);padding:.6rem .5rem;text-align:center}
.am-stat-val{font-family:'Cormorant Garamond',serif;font-size:1.1rem;color:var(--gold)}
.am-stat-lbl{font-size:.5rem;letter-spacing:.15em;color:var(--faint);text-transform:uppercase;margin-top:.15rem}
.am-section{padding:1rem 1.5rem}
.am-section-title{font-size:.55rem;letter-spacing:.25em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.6rem;padding-bottom:.3rem;border-bottom:1px solid var(--xfaint)}
.am-genome-grid{display:grid;grid-template-columns:1fr 1fr;gap:.35rem}
.am-genome-row{display:flex;align-items:center;gap:.4rem}
.am-genome-row .am-g-label{font-size:.62rem;color:var(--dim);width:72px;flex-shrink:0;text-align:right}
.am-genome-row .am-g-bar{flex:1;height:6px;background:var(--s3);overflow:hidden}
.am-genome-row .am-g-fill{height:100%;transition:width .4s ease}
.am-genome-row .am-g-val{font-size:.58rem;color:var(--faint);width:24px;text-align:right}
.am-tags{display:flex;flex-wrap:wrap;gap:.3rem;margin-top:.2rem}
.am-tag{font-size:.55rem;letter-spacing:.08em;color:var(--dim);border:1px solid var(--faint);padding:.1rem .4rem}
.am-evo-entry{font-size:.68rem;color:var(--dim);line-height:1.6;padding:.3rem 0;border-bottom:1px solid var(--xfaint)}
.am-evo-entry:last-child{border-bottom:none}
.am-evo-entry b{color:var(--txt);font-weight:600}
.am-belief{font-size:.72rem;color:var(--dim);font-style:italic;line-height:1.6;padding:.3rem .5rem;border-left:2px solid var(--gold-d);margin-top:.3rem}
.am-bio{font-size:.72rem;color:var(--dim);line-height:1.6}

/* ═══ PIXEL AVATAR (inline replacements) ═══ */
.agent-avatar-inline{width:26px;height:26px;image-rendering:pixelated;border:1px solid var(--bdr);flex-shrink:0;display:block}
.agent-avatar-sm{width:18px;height:18px;image-rendering:pixelated;vertical-align:middle;margin-right:3px}
.agent-avatar-roster{width:32px;height:32px;image-rendering:pixelated;border:1px solid var(--gold-d);flex-shrink:0}
.agent-avatar-genome{width:28px;height:28px;image-rendering:pixelated}
/* ═══ GAMIFICATION EFFECTS ═══ */

/* Glowing gold accent for active/important elements */
@keyframes goldGlow{0%,100%{box-shadow:0 0 4px rgba(201,168,76,.15)}50%{box-shadow:0 0 12px rgba(201,168,76,.35)}}
@keyframes goldPulse{0%,100%{text-shadow:0 0 4px rgba(201,168,76,.2)}50%{text-shadow:0 0 12px rgba(201,168,76,.5)}}
@keyframes rankReveal{from{opacity:0;transform:scale(.8) translateY(8px)}to{opacity:1;transform:none}}
@keyframes creditTick{0%{transform:scale(1)}50%{transform:scale(1.15)}100%{transform:scale(1)}}
@keyframes winnerShine{0%{background-position:-200% 0}100%{background-position:200% 0}}
@keyframes xpFill{from{width:0%}to{width:var(--xp-pct,50%)}}

/* Progress bar glow */
.prog-fill{box-shadow:0 0 6px rgba(201,168,76,.4)}

/* Phase rail active glow */
.pnode.active{box-shadow:inset 0 -2px 8px rgba(201,168,76,.15)}
.pnode.done{box-shadow:inset 0 -2px 8px rgba(76,175,125,.12)}

/* Cycle dots gamified */
.ci-dot.active{animation:goldGlow 2s ease infinite;font-weight:700}
.ci-dot.done{box-shadow:0 0 6px rgba(76,175,125,.3)}

/* Winner card shine effect */
.dcard.winner-card{background:linear-gradient(135deg,rgba(201,168,76,.08) 0%,rgba(201,168,76,.02) 40%,rgba(201,168,76,.08) 100%);border:1px solid var(--gold-d)}
.dcard.winner-card .win-badge{background:rgba(201,168,76,.1);animation:goldGlow 2s ease infinite}

/* Credits animation */
.dcred{transition:all .3s ease}

/* Rank badges for leaderboard */
.agent-lb tr:nth-child(1) .rank-num{color:var(--gold);text-shadow:0 0 8px rgba(201,168,76,.4);font-size:1.3rem}
.agent-lb tr:nth-child(2) .rank-num{color:#b0b0b0;text-shadow:0 0 6px rgba(176,176,176,.3);font-size:1.2rem}
.agent-lb tr:nth-child(3) .rank-num{color:#cd7f32;text-shadow:0 0 6px rgba(205,127,50,.3);font-size:1.15rem}

/* Top 3 gallery rank styling */
.top3-card.gold-card{box-shadow:0 0 12px rgba(201,168,76,.15)}
.top3-card.gold-card .top3-creds{animation:goldPulse 2s ease infinite}

/* Cycle complete banner gamified */
.cycle-complete.show{animation:rankReveal .5s ease both;border:1px solid var(--gold);box-shadow:0 0 20px rgba(201,168,76,.1)}
.cc-title{text-shadow:0 0 8px rgba(201,168,76,.25)}

/* Strategy badges with subtle glow */
.strat-exploit{box-shadow:0 0 4px rgba(138,110,48,.2)}
.strat-explore{box-shadow:0 0 4px rgba(74,127,168,.2)}
.strat-mutate{box-shadow:0 0 4px rgba(123,111,168,.2)}

/* Genome evolution arrows animation */
.gd-arrow.up{animation:creditTick .5s ease}
.gd-arrow.down{animation:creditTick .5s ease}

/* Winner/loss badges in genome cards */
.gc-result-badge.win{box-shadow:0 0 6px rgba(201,168,76,.25);animation:goldGlow 2.5s ease infinite}

/* Reputation bar in agent rows */
.arow{position:relative}
.arow::after{content:'';position:absolute;bottom:0;left:0;height:1px;background:linear-gradient(90deg,var(--gold-d),transparent);width:0;transition:width .6s ease}

/* Deploy slots gamified */
.deploy-slot.deployed{box-shadow:inset 0 -2px 8px rgba(201,168,76,.08)}
.deploy-slot.just-deployed{animation:rankReveal .4s ease both;box-shadow:0 0 12px rgba(201,168,76,.2)}

/* Voter allocation badges */
.vf-alloc{transition:all .2s;cursor:default}
.vf-alloc:hover{background:rgba(201,168,76,.15);transform:scale(1.05)}

/* Nav tab active gamified */
.nav-tab.active{box-shadow:inset 0 -4px 10px rgba(201,168,76,.1)}

/* Report KPI values glow */
.kpi-val{text-shadow:0 0 4px rgba(201,168,76,.15)}
.kpi-val.up{text-shadow:0 0 4px rgba(76,175,125,.2)}
.kpi-val.down{text-shadow:0 0 4px rgba(181,51,42,.2)}

/* Epoch arc gamified */
.epoch-arc{box-shadow:0 0 16px rgba(201,168,76,.08);position:relative;overflow:hidden}
.epoch-arc::before{content:'';position:absolute;top:0;left:-200%;width:200%;height:100%;background:linear-gradient(90deg,transparent,rgba(201,168,76,.03),transparent);animation:winnerShine 4s linear infinite}

/* Agent modal gamified */
.agent-modal{box-shadow:0 0 30px rgba(201,168,76,.12)}

/* ═══ MOBILE LAYOUT ═══ */
@media(max-width:600px){
  /* Nav: compact layout */
  nav{padding:0 .8rem;gap:.3rem;height:auto;flex-wrap:wrap;padding-top:.5rem}
  .nav-logo{font-size:.85rem;letter-spacing:.2em;gap:.4rem}
  .nav-logo-icon{width:22px;height:22px}
  .nav-logo-icon::before{width:7px;height:7px}
  .nav-tabs{width:100%;order:3;gap:0;display:grid;grid-template-columns:repeat(4,1fr);height:auto;border-top:1px solid var(--xfaint);margin-top:.3rem}
  .nav-tab{padding:.45rem .2rem;font-size:.5rem;letter-spacing:.06em;text-align:center;white-space:nowrap;overflow:hidden;height:auto;border-bottom-width:2px;gap:.2rem;justify-content:center}
  .nav-tab .nt-step{width:14px;height:14px;font-size:.42rem}
  .nav-epoch{font-size:.52rem;gap:.4rem}
  .nav-epoch-bar{width:36px}
  main{padding-top:90px}

  /* Home screen mobile */
  .hero-gem{width:40px;height:40px;margin-bottom:1rem}
  .hero-gem::before{width:28px;height:28px}
  .hero-gem::after{width:14px;height:14px}
  .hero-gem-inner{width:6px;height:6px}
  .home-steps{grid-template-columns:1fr;max-width:100%}
  .home-step::after{display:none}
  .home-features{grid-template-columns:repeat(4,1fr);max-width:100%}
  .hf-icon{font-size:1rem}
  .hf-val{font-size:1.1rem}
  .hf-lbl{font-size:.48rem}
  .mode-toggle{max-width:100%}
  .home-start-wrap .btn-primary{font-size:.7rem;padding:.7rem 1.5rem}

  /* Screens: tighter padding */
  .screen{padding:1.2rem .8rem}

  /* Typography: scale down */
  .h1{font-size:1.5rem}
  .h2{font-size:1.2rem}
  .sub{font-size:.8rem}
  .eyebrow{font-size:.55rem;letter-spacing:.3em}

  /* Buttons: touch-friendly */
  .btn{padding:.65rem 1.2rem;font-size:.7rem;min-height:44px}
  .btn-sm{padding:.5rem .8rem;min-height:38px}

  /* Home screen */
  .home-hero{padding:1.5rem 0 1rem}
  .mode-toggle{max-width:100%}
  .mode-btn{font-size:.6rem;padding:.6rem .5rem}
  .api-panel{padding:1.2rem}

  /* Builder */
  .builder-layout{max-width:100%}
  .bsec{padding:1.2rem 1rem;border-radius:12px}
  .field input,.field textarea{font-size:1rem;padding:.6rem .8rem;border-radius:8px}
  .cat-slider input[type=range]::-webkit-slider-thumb{width:22px;height:22px}
  .cat-slider-label{font-size:.72rem}
  .cat-slider-val{font-size:1rem}
  .sr label{font-size:.68rem}
  .chips{gap:.3rem}
  .chip{padding:.3rem .55rem;font-size:.58rem;min-height:32px;display:inline-flex;align-items:center}

  /* Sim topbar */
  .sim-topbar{margin-bottom:1rem;gap:.6rem}
  .ci-dot{width:32px;height:32px;font-size:.65rem}

  /* Phase rail: scrollable, bigger touch */
  .phase-rail{margin-bottom:1rem;-webkit-overflow-scrolling:touch}
  .pnode{min-width:68px;padding:.6rem .3rem}
  .pnode .pni{font-size:.85rem}
  .pnode .pnl{font-size:.5rem}

  /* Sim body: stack */
  .sim-body{grid-template-columns:1fr;gap:.8rem;min-height:auto}
  .agents-col{padding:.8rem;max-height:200px;overflow-y:auto}
  .agents-col h5{margin-bottom:.5rem}
  .arow{padding:.4rem 0;gap:.4rem}
  .arow .an{font-size:.75rem}
  .arow .as{font-size:.6rem}
  .acr{font-size:.75rem}
  .log-col{padding:.8rem}
  .log{max-height:220px}
  .le{font-size:.72rem;padding:.3rem .4rem}

  /* Design cards: 2-col */
  .dgrid{grid-template-columns:repeat(2,1fr)}
  .dcard-body{padding:.6rem}
  .dname{font-size:.8rem}
  .dagent{font-size:.5rem}
  .dcred{font-size:.9rem}
  .dgem{font-size:1.1rem;margin-bottom:.2rem}
  .dbar{margin-bottom:.2rem;gap:.25rem}
  .dbar-l{font-size:.5rem;width:20px}

  /* Deploy panel */
  .deploy-grid{grid-template-columns:repeat(2,1fr)}
  .deploy-slot{padding:1rem .8rem}
  .ds-emoji{font-size:1.4rem;margin-bottom:.3rem}
  .ds-name{font-size:.95rem}
  .ds-phil{font-size:.65rem}
  .ds-tags{font-size:.52rem}

  /* Roster */
  .roster-card{padding:.3rem .6rem}
  .rc-name{font-size:.78rem}

  /* Cycle complete */
  .cycle-complete{padding:1rem}
  .cc-title{font-size:1.3rem}
  .cc-winner{padding:.6rem .8rem;gap:.5rem}
  .cc-actions{gap:.5rem}
  .cc-actions .btn{flex:1;justify-content:center;text-align:center}

  /* Top 3 gallery: stack */
  .top3-gallery{grid-template-columns:1fr}
  .top3-meta{padding:.7rem}
  .top3-name{font-size:1rem}

  /* Sim controls */
  .sim-ctrl{gap:.5rem}
  .spd{font-size:.58rem}
  .spd-btn{padding:.25rem .5rem;min-height:32px}

  /* Reports */
  .reports-layout{grid-template-columns:1fr;gap:.8rem;min-height:auto}
  .report-nav{max-height:160px;overflow-y:auto;padding:.8rem}
  .rn-item{padding:.5rem .6rem}
  .report-view{padding:1rem;max-height:none}
  .rdoc-title{font-size:1.3rem}
  .rdoc-header{padding-bottom:.8rem;margin-bottom:1rem}

  /* Report grids */
  .exec-stats{grid-template-columns:repeat(2,1fr)}
  .es-val{font-size:1.2rem}
  .kpi-strip{grid-template-columns:repeat(3,1fr)}
  .kpi-val{font-size:1.1rem}
  .corr-panel{grid-template-columns:1fr}
  .strat-battle{grid-template-columns:1fr}
  .genome-grid{grid-template-columns:1fr}
  .epoch-timeline{grid-template-columns:1fr}
  .et-node::after{display:none}
  .trend-grid{grid-template-columns:1fr}
  .rdoc-top3{grid-template-columns:1fr}

  /* Tables: horizontal scroll */
  .rtable,.agent-lb,.cat-heat,.vflow-table{display:block;overflow-x:auto;-webkit-overflow-scrolling:touch}
  .rtable thead,.agent-lb thead,.cat-heat thead,.vflow-table thead,
  .rtable tbody,.agent-lb tbody,.cat-heat tbody,.vflow-table tbody{min-width:500px;display:table;width:100%}
  .rtable th,.agent-lb th,.cat-heat th,.vflow-table th{white-space:nowrap}

  /* Agent modal: fullscreen on mobile */
  .agent-modal{width:100%;max-width:100%;max-height:100vh;height:100vh;border:none}
  .am-header{padding:1rem;gap:.8rem}
  .am-avatar{width:60px;height:60px}
  .am-identity h2{font-size:1.1rem}
  .am-section{padding:.8rem 1rem}
  .am-genome-grid{grid-template-columns:1fr}
  .am-genome-row .am-g-label{width:60px;font-size:.58rem}

  /* Image gen status */
  .img-gen-status{font-size:.65rem}
}

/* Small phone tweaks */
@media(max-width:380px){
  nav{padding:0 .5rem;padding-top:.4rem}
  .nav-logo{font-size:.7rem;letter-spacing:.15em}
  .nav-logo-icon{width:18px;height:18px}
  .nav-tab{font-size:.42rem;padding:.35rem .1rem}
  .nav-tab .nt-step{display:none}
  main{padding-top:88px}
  .screen{padding:1rem .6rem}
  .dgrid{grid-template-columns:1fr}
  .deploy-grid{grid-template-columns:1fr}
  .agents-col{max-height:160px}
  .home-features{grid-template-columns:repeat(2,1fr)}
}

</style>
</head>
<body>

<nav>
  <div class="nav-logo"><div class="nav-logo-icon"></div>JewelForge</div>
  <div class="nav-tabs">
    <button class="nav-tab active" id="nt0" onclick="goTo(0)">Home</button>
    <button class="nav-tab" id="nt1" onclick="goTo(1)"><span class="nt-step">1</span> Build</button>
    <button class="nav-tab" id="nt2" onclick="goTo(2)"><span class="nt-step">2</span> Simulate</button>
    <button class="nav-tab" id="nt3" onclick="goTo(3)"><span class="nt-step">3</span> Reports</button>
  </div>
  <div class="nav-epoch">Epoch <span id="nav-epoch-txt">0 / 3</span> <div class="nav-epoch-bar"><div class="nav-epoch-fill" id="nav-epoch-fill"></div></div></div>
</nav>

<main>

<!-- ══════════════════════════════════════
     SCREEN 0: HOME / API KEYS
══════════════════════════════════════ -->
<div class="screen active" id="screen-0">
  <div class="home-hero">
    <div class="hero-gem"><div class="hero-gem-inner"></div></div>
    <div class="eyebrow">AI-Powered Jewelry Design Arena</div>
    <h1 class="h1">Welcome to <em>JewelForge</em></h1>
    <div class="rule" style="margin:1rem auto 1.5rem"></div>
    <p class="sub">6 AI agents compete across 3 cycles to design, name, and evolve luxury jewelry. Each agent has a unique genome, personality, and strategy — shaped by cross-pollination dialogues and real-time market intelligence.</p>
  </div>

  <div class="home-steps">
    <div class="home-step">
      <div class="hs-num">1</div>
      <div class="hs-title">Build</div>
      <div class="hs-desc">Configure your agent's genome, philosophy, and style tags</div>
    </div>
    <div class="home-step">
      <div class="hs-num">2</div>
      <div class="hs-title">Simulate</div>
      <div class="hs-desc">Run 3 cycles of design, voting, and evolution</div>
    </div>
    <div class="home-step">
      <div class="hs-num">3</div>
      <div class="hs-title">Analyze</div>
      <div class="hs-desc">Review intelligence reports and trend data</div>
    </div>
  </div>

  <div class="home-features">
    <div class="home-feat"><span class="hf-icon">🧬</span><div class="hf-val">6</div><div class="hf-lbl">AI Agents</div></div>
    <div class="home-feat"><span class="hf-icon">🔄</span><div class="hf-val">3</div><div class="hf-lbl">Cycles</div></div>
    <div class="home-feat"><span class="hf-icon">💬</span><div class="hf-val">15</div><div class="hf-lbl">Dialogues</div></div>
    <div class="home-feat"><span class="hf-icon">💎</span><div class="hf-val">18</div><div class="hf-lbl">Designs</div></div>
  </div>

  <div class="api-panel show" id="api-panel">
    <h4>API Configuration — Required</h4>
    <div class="api-field">
      <label>Anthropic API Key &nbsp;<span style="color:var(--gold-d);font-size:.55rem;letter-spacing:.08em">— Language &amp; Intelligence</span></label>
      <input type="password" id="api-anthropic" placeholder="sk-ant-..." oninput="checkApiKeys()">
      <div class="api-hint">Powers all agent dialogue, cross-pollination, synthesis, and design reasoning via Claude</div>
    </div>
    <div class="api-field">
      <label>Higgsfield API Key &nbsp;<span style="color:var(--gold-d);font-size:.55rem;letter-spacing:.08em">— Image Generation</span></label>
      <input type="password" id="api-higgsfield" placeholder="KEY_ID:KEY_SECRET" oninput="checkApiKeys()">
      <div class="api-hint">Generates jewelry renders from agent design prompts via Higgsfield SOUL / Flux models</div>
    </div>
    <div class="api-status" id="api-status">
      <div class="dot off" id="api-dot"></div>
      <span id="api-status-text">Enter API keys to enable Live AI Mode</span>
    </div>
    <div style="text-align:center;margin-top:1.2rem;display:flex;align-items:center;justify-content:center;gap:1.2rem">
      <button class="btn btn-primary btn-sm" id="api-submit-btn" onclick="submitApiKeys()" disabled>Submit API Keys</button>
      <button class="auto-link" id="api-clear-btn" onclick="clearSavedKeys()" style="display:none;font-size:.65rem;color:var(--faint)">Clear Saved Keys</button>
    </div>
  </div>

  <!-- Google Drive Auto-Save -->
  <div class="gdrive-panel" id="gdrive-panel">
    <h4><span class="gdrive-icon">📁</span> Google Drive — Auto-Save</h4>
    <p style="font-size:.72rem;color:var(--dim);line-height:1.6;margin-bottom:.8rem">Automatically save every generated jewelry image and intelligence report to your Google Drive folder. Files upload as they render — no manual downloads needed.</p>

    <div class="gdrive-setup-steps" id="gdrive-setup-steps">
      <div style="font-size:.62rem;letter-spacing:.2em;color:var(--gold-d);text-transform:uppercase;margin-bottom:.8rem">One-Time Setup (2 minutes)</div>
      <div class="gdrive-step">
        <div class="gdrive-step-num">1</div>
        <div class="gdrive-step-body">
          <div class="gdrive-step-title">Open Google Apps Script</div>
          <div class="gdrive-step-desc">Go to <a href="https://script.google.com/home/start" target="_blank" style="color:#4285f4;text-decoration:underline">script.google.com</a> and click <b>New Project</b></div>
        </div>
      </div>
      <div class="gdrive-step">
        <div class="gdrive-step-num">2</div>
        <div class="gdrive-step-body">
          <div class="gdrive-step-title">Paste this script</div>
          <div class="gdrive-step-desc">Delete the default code and paste (replace <b>YOUR_FOLDER_ID_HERE</b> with your Drive folder ID):</div>
          <div class="gdrive-code" id="gdrive-script-code"><pre style="margin:0;white-space:pre-wrap;word-break:break-all">function doGet(e) {
  return ContentService.createTextOutput(
    JSON.stringify({status:"ok"})
  ).setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  try {
    var data = JSON.parse(e.postData.contents);
    var folder = DriveApp.getFolderById("YOUR_FOLDER_ID_HERE");
    var file;
    if (data.textContent) {
      file = folder.createFile(
        data.filename || "jewelforge-data.json",
        data.textContent,
        data.mimeType || "application/json"
      );
    } else if (data.imageUrl) {
      var resp = UrlFetchApp.fetch(data.imageUrl);
      var blob = resp.getBlob().setName(
        data.filename || "jewelforge-image.png"
      );
      file = folder.createFile(blob);
    } else if (data.image) {
      var blob = Utilities.newBlob(
        Utilities.base64Decode(data.image),
        data.mimeType || "image/png",
        data.filename || "jewelforge-image.png"
      );
      file = folder.createFile(blob);
    } else {
      return ContentService.createTextOutput(
        JSON.stringify({success:false, error:"No file data"})
      ).setMimeType(ContentService.MimeType.JSON);
    }
    return ContentService.createTextOutput(
      JSON.stringify({success:true, id:file.getId(), name:file.getName()})
    ).setMimeType(ContentService.MimeType.JSON);
  } catch(err) {
    return ContentService.createTextOutput(
      JSON.stringify({success:false, error:err.message})
    ).setMimeType(ContentService.MimeType.JSON);
  }
}</pre>
          <button class="gdrive-copy-btn" onclick="copyScriptCode()">📋 Copy Script</button>
          </div>
        </div>
      </div>
      <div class="gdrive-step">
        <div class="gdrive-step-num">3</div>
        <div class="gdrive-step-body">
          <div class="gdrive-step-title">Deploy as Web App</div>
          <div class="gdrive-step-desc">Click <b>Deploy → New deployment</b> → choose <b>Web app</b> → set "Who has access" to <b>Anyone</b> → click <b>Deploy</b>. Authorize when prompted.</div>
        </div>
      </div>
      <div class="gdrive-step">
        <div class="gdrive-step-num">4</div>
        <div class="gdrive-step-body">
          <div class="gdrive-step-title">Paste the Web App URL below</div>
          <div class="gdrive-step-desc">Copy the deployed URL (starts with https://script.google.com/macros/...)</div>
        </div>
      </div>
    </div>

    <div class="api-field" style="margin-top:1rem">
      <label>Apps Script Web App URL</label>
      <input type="text" id="gdrive-webapp-url" placeholder="https://script.google.com/macros/s/xxxx/exec" oninput="updateGDriveStatus()">
    </div>
    <div style="display:flex;align-items:center;gap:.8rem;flex-wrap:wrap">
      <button class="gdrive-connect-btn" id="gdrive-connect-btn" onclick="connectGoogleDrive()" disabled>
        <span class="g-logo">📁</span> Enable Auto-Save
      </button>
      <button class="auto-link" id="gdrive-disconnect-btn" onclick="disconnectGoogleDrive()" style="display:none;font-size:.62rem;color:var(--faint)">Disable</button>
    </div>
    <div class="gdrive-status" id="gdrive-status">
      <div class="dot off" id="gdrive-dot"></div>
      <span id="gdrive-status-text">Paste your Apps Script URL to enable</span>
    </div>
    <div class="gdrive-counter" id="gdrive-counter" style="display:none">📤 <span id="gdrive-upload-count">0</span> files saved to Drive</div>
    <button class="gdrive-retry-btn" id="gdrive-retry-btn" onclick="retryGDriveUploads()" style="display:none">↻ Retry Uploads</button>
  </div>

  <div class="home-start-wrap">
    <button class="btn btn-primary" id="home-start-btn" onclick="startFromHome()">Begin Agent Configuration →</button>
    <button class="btn btn-ghost autopilot-btn" id="autopilot-btn" onclick="runAutopilot()" disabled>⚡ Autopilot — Generate All & Run</button>
  </div>
  <div class="home-version">JewelForge <span>v2.0</span> — 3-Cycle Intelligence Engine</div>
</div>

<!-- ══════════════════════════════════════
     SCREEN 1: BUILDER
══════════════════════════════════════ -->
<div class="screen" id="screen-1">
  <div style="text-align:center;margin-bottom:.5rem">
    <div class="eyebrow" id="agent-counter" style="color:var(--gold)">Agent 1 of 6 &nbsp;<span id="agent-emoji">🎯</span></div>
  </div>
  <h1 class="h1" style="text-align:center" id="builder-title">Forge your <em>jewelry mind.</em></h1>
  <div class="rule" style="margin:1rem auto 1rem"></div>
  <p class="sub" style="text-align:center;margin:0 auto 2rem" id="builder-sub">Give your agent an identity and tune their jewelry instincts. These 5 sliders shape how the AI thinks about design across every cycle.</p>

  <div id="roster-wrap" style="display:none">
    <div class="label" style="text-align:center">Deployed Agents</div>
    <div id="agent-roster" class="roster-row" style="justify-content:center"></div>
  </div>

  <div class="builder-layout">
    <!-- Identity Card -->
    <div class="bsec">
      <h4><span class="sec-icon">✦</span> Identity <button class="auto-link" onclick="autoGen()">⚡ Auto-Generate</button></h4>
      <div class="field"><label>Agent Name</label><input id="b-name" placeholder="e.g. Maren Vex, Kai Orin…" oninput="updatePreview()"></div>
      <div class="field"><label>Agent Bio</label><textarea id="b-phil" placeholder="Describe your agent's design philosophy, aesthetic instincts, and what drives their creative decisions…" oninput="updatePreview()"></textarea></div>
    </div>

    <!-- Jewelry Expertise Sliders -->
    <div class="bsec">
      <h4><span class="sec-icon">💎</span> Jewelry Expertise</h4>
      <p style="font-size:.72rem;color:var(--faint);margin-bottom:1.4rem;line-height:1.6">Tune how deeply your agent understands each jewelry category. Higher values mean stronger instincts — shaping design choices, material picks, and creative risk.</p>

      <div class="cat-slider">
        <div class="cat-slider-header">
          <span class="cat-slider-label"><span class="cat-icon">💍</span> Rings</span>
          <span class="cat-slider-val" id="sv-rings">50</span>
        </div>
        <div class="cat-slider-track"><div class="cat-slider-fill" id="fill-rings" style="width:50%"></div></div>
        <input type="range" min="0" max="100" value="50" id="s-rings" oninput="updateCatSlider(this,'rings');updatePreview()">
        <div class="cat-slider-hint"><span>Novice</span><span>Master</span></div>
      </div>

      <div class="cat-slider">
        <div class="cat-slider-header">
          <span class="cat-slider-label"><span class="cat-icon">📿</span> Necklaces</span>
          <span class="cat-slider-val" id="sv-necklaces">50</span>
        </div>
        <div class="cat-slider-track"><div class="cat-slider-fill" id="fill-necklaces" style="width:50%"></div></div>
        <input type="range" min="0" max="100" value="50" id="s-necklaces" oninput="updateCatSlider(this,'necklaces');updatePreview()">
        <div class="cat-slider-hint"><span>Novice</span><span>Master</span></div>
      </div>

      <div class="cat-slider">
        <div class="cat-slider-header">
          <span class="cat-slider-label"><span class="cat-icon">✨</span> Earrings</span>
          <span class="cat-slider-val" id="sv-earrings">50</span>
        </div>
        <div class="cat-slider-track"><div class="cat-slider-fill" id="fill-earrings" style="width:50%"></div></div>
        <input type="range" min="0" max="100" value="50" id="s-earrings" oninput="updateCatSlider(this,'earrings');updatePreview()">
        <div class="cat-slider-hint"><span>Novice</span><span>Master</span></div>
      </div>

      <div class="cat-slider">
        <div class="cat-slider-header">
          <span class="cat-slider-label"><span class="cat-icon">⌚</span> Bracelets</span>
          <span class="cat-slider-val" id="sv-bracelets">50</span>
        </div>
        <div class="cat-slider-track"><div class="cat-slider-fill" id="fill-bracelets" style="width:50%"></div></div>
        <input type="range" min="0" max="100" value="50" id="s-bracelets" oninput="updateCatSlider(this,'bracelets');updatePreview()">
        <div class="cat-slider-hint"><span>Novice</span><span>Master</span></div>
      </div>

      <div class="cat-slider">
        <div class="cat-slider-header">
          <span class="cat-slider-label"><span class="cat-icon">👑</span> High Jewelry</span>
          <span class="cat-slider-val" id="sv-highjewelry">50</span>
        </div>
        <div class="cat-slider-track"><div class="cat-slider-fill" id="fill-highjewelry" style="width:50%"></div></div>
        <input type="range" min="0" max="100" value="50" id="s-highjewelry" oninput="updateCatSlider(this,'highjewelry');updatePreview()">
        <div class="cat-slider-hint"><span>Novice</span><span>Master</span></div>
      </div>
    </div>

    <!-- Preview Card -->
    <div class="preview-box">
      <div class="label">Live Agent Preview</div>
      <div class="prow"><span class="plabel">Identity</span><span class="pval" id="pv-id">—</span></div>
      <div class="prow"><span class="plabel">Specialty</span><span class="pval" style="font-size:.88rem;color:var(--dim)" id="pv-tags">—</span></div>
      <div class="prow"><span class="plabel">Focus</span><span class="pval" id="pv-strat">—</span></div>
      <div class="label" style="margin-top:.8rem">Expertise DNA</div>
      <div class="dna-strip" id="pv-dna"></div>
    </div>

    <div style="display:flex;gap:.8rem;justify-content:center;flex-wrap:wrap">
      <button class="btn btn-primary" id="deploy-btn" onclick="deployCurrentAgent()">Deploy Agent 1 → Configure Next</button>
      <button class="btn btn-ghost" onclick="autoGen()">⚡ Auto-Generate</button>
    </div>
  </div>
</div>


<!-- ══════════════════════════════════════
     SCREEN 2: SIMULATOR
══════════════════════════════════════ -->
<div class="screen" id="screen-2">
  <div id="deploy-panel" style="display:none"></div>
  <div id="sim-main">
  <div class="sim-topbar">
    <div>
      <div class="eyebrow">Cycle Simulator</div>
      <h2 class="h1">Cycle <em id="sim-cycle-num">01</em> &nbsp;<span style="font-family:'Rajdhani',sans-serif;font-size:1rem;color:var(--faint)">of 3</span><span class="sim-mode-badge sim" id="mode-badge">SIM</span></h2>
    </div>
    <div style="text-align:right">
      <div style="font-size:.58rem;letter-spacing:.25em;color:var(--faint);text-transform:uppercase;margin-bottom:.4rem">Epoch Progress</div>
      <div class="cycle-indicator" id="ci">
        <div class="ci-dot" id="cid-1">C1</div>
        <div style="width:20px;height:1px;background:var(--faint)"></div>
        <div class="ci-dot" id="cid-2">C2</div>
        <div style="width:20px;height:1px;background:var(--faint)"></div>
        <div class="ci-dot" id="cid-3">C3</div>
      </div>
    </div>
  </div>

  <div class="prog-bar"><div class="prog-fill" id="prog"></div></div>

  <div class="phase-rail">
    <div class="pnode active" id="ph0"><span class="pni">💬</span><span class="pnl">Cross-Pollination</span></div>
    <div class="pnode" id="ph1"><span class="pni">🧠</span><span class="pnl">Synthesis</span></div>
    <div class="pnode" id="ph2"><span class="pni">💎</span><span class="pnl">Generation</span></div>
    <div class="pnode" id="ph3"><span class="pni">⚖️</span><span class="pnl">Voting</span></div>
    <div class="pnode" id="ph4"><span class="pni">📈</span><span class="pnl">Evolution</span></div>
  </div>

  <div class="sim-body">
    <div class="agents-col">
      <h5>Active Agents</h5>
      <div id="agents-col-body"></div>
    </div>
    <div class="log-col">
      <h5>Cycle Activity</h5>
      <div class="log" id="act-log"></div>
    </div>
  </div>

  <div class="designs-wrap" id="designs-wrap" style="display:none">
    <div class="dw-hdr">Submitted Designs — Cycle <span id="dw-cycle">01</span></div>
    <div class="dgrid" id="dgrid"></div>
  </div>

  <div class="cycle-complete" id="cc-panel">
    <div class="cc-title">Cycle <span id="cc-num">01</span> Complete</div>
    <div class="cc-sub" id="cc-sub">Consensus reached. Intelligence report generated.</div>

    <div style="margin-bottom:1rem">
      <div class="eyebrow" style="margin-bottom:.3rem">Top 3 Designs — AI-Generated Images</div>
      <div style="font-size:.75rem;color:var(--faint);margin-bottom:.7rem;line-height:1.5">Images rendered from each agent's final image generation prompt via Flux AI. Images load sequentially to avoid rate limits — allow 15–30 seconds per image.</div>
      <div class="img-gen-status" id="img-gen-status">
        <div class="dot" id="img-dot"></div>
        <span id="img-gen-label">Generating images from agent prompts…</span>
      </div>
      <div class="top3-gallery" id="top3-gallery"></div>
    </div>

    <div class="cc-actions">
      <button class="btn btn-primary" id="cc-next-btn">▶ Begin Cycle 2</button>
      <button class="btn" onclick="viewReport(currentCycle-1)">📄 View Cycle Report</button>
    </div>
  </div>

  <div class="sim-ctrl">
    <button class="btn btn-primary" id="phase-btn" onclick="nextPhase()">▶ Start Cross-Pollination</button>
    <div class="spd">Speed:
      <button class="spd-btn on" onclick="setSpd(1,this)">1×</button>
      <button class="spd-btn" onclick="setSpd(2,this)">2×</button>
      <button class="spd-btn" onclick="setSpd(5,this)">5×</button>
    </div>
  </div>
  </div>
</div>


<!-- ══════════════════════════════════════
     SCREEN 3: REPORTS
══════════════════════════════════════ -->
<div class="screen" id="screen-3">
  <div class="eyebrow">Intelligence Archive</div>
  <h1 class="h1">Cycle <em>Intelligence Reports</em></h1>
  <div class="rule"></div>
  <p class="sub" id="reports-sub">Reports are generated after each cycle and fed back into agent decision-making. Run cycles to populate this archive.</p>

  <div class="reports-layout">
    <div class="report-nav">
      <h5>Completed Cycles</h5>
      <div id="report-nav-list"><div class="rn-empty">No cycles complete yet.</div></div>
    </div>
    <div class="report-view" id="report-view-area">
      <div class="report-placeholder">
        <div class="rp-icon">📊</div>
        <div class="rp-msg">Select a cycle report</div>
      </div>
    </div>
  </div>

  <div style="margin-top:1.5rem;display:flex;gap:.8rem;flex-wrap:wrap">
    <button class="btn btn-ghost" onclick="goTo(2)">← Back to Simulator</button>
    <button class="btn btn-ghost btn-sm" id="dl-all-btn" style="display:none" onclick="exportAllReports()">⬇ Export All Reports</button>
    <button class="btn btn-ghost btn-sm" id="dl-pdf-btn" style="display:none" onclick="exportCurrentReportAsPDF()">⬇ Export Report as PDF</button>
    <button class="btn btn-ghost btn-sm" id="dl-all-pdf-btn" style="display:none" onclick="exportAllReportsAsPDF()">⬇ Export All Reports as PDF</button>
  </div>
</div>

</main>

<script>
/* ══════════════════════════════════
   CONSTANTS & DATA
══════════════════════════════════ */
let speed = 1;
let currentPhase = -1;
let currentCycle = 1;
let cycleReports = [];
let agentStates = [];
let activeDesigns = [];
let configuredAgents = [];
let currentAgentNum = 1;
const AGENT_EMOJIS = ['🎯','🌙','✨','🔩','💛','🌿'];

/* ══════════════════════════════════
   PIXEL ART PROFILE PICTURE GENERATOR
   Deterministically generates a unique 16×16 pixel portrait
   from agent DNA (genome, philosophy, style tags, archetype).
   Output is a data URL stored on the agent object permanently.
══════════════════════════════════ */
function generateAgentAvatar(agent) {
  // Seeded PRNG from agent properties for determinism
  let seed = 0;
  const seedStr = (agent.name || '') + (agent.arch || '') + (agent.philosophy || '') + (agent.styleTags || []).join('');
  for (let i = 0; i < seedStr.length; i++) { seed = ((seed << 5) - seed + seedStr.charCodeAt(i)) | 0; }
  const rng = () => { seed = (seed * 1664525 + 1013904223) & 0xFFFFFFFF; return (seed >>> 0) / 0xFFFFFFFF; };

  const SIZE = 16;
  const canvas = document.createElement('canvas');
  canvas.width = SIZE; canvas.height = SIZE;
  const ctx = canvas.getContext('2d');

  // ── Derive color palette from genome DNA ──
  const hueBase = ((agent.platBias || 50) * 2.4 + (agent.coloredStone || 40) * 1.2 + (agent.risk || 50) * 0.8) % 360;
  const sat = 30 + (agent.ornamentation || 50) * 0.5; // ornate = more saturated
  const lightBase = 20 + (agent.minimalism || 50) * 0.3; // minimal = lighter

  // Primary: derived from genome
  const primary = `hsl(${hueBase}, ${sat}%, ${lightBase + 20}%)`;
  // Secondary: complementary shift
  const secondary = `hsl(${(hueBase + 40 + (agent.novelty || 50) * 0.8) % 360}, ${sat * 0.7}%, ${lightBase + 10}%)`;
  // Accent: from style/market
  const accentHue = (hueBase + 120 + (agent.marketFit || 50) * 1.5) % 360;
  const accent = `hsl(${accentHue}, ${sat + 15}%, ${lightBase + 30}%)`;
  // Skin tone
  const skinLight = 55 + (agent.diamond || 60) * 0.25;
  const skinHue = 25 + (agent.mixedMetal || 30) * 0.3;
  const skin = `hsl(${skinHue}, ${20 + (agent.symmetry || 60) * 0.15}%, ${skinLight}%)`;
  // Background
  const bgHue = (hueBase + 180) % 360;
  const bg = `hsl(${bgHue}, ${sat * 0.3}%, ${8 + rng() * 5}%)`;
  // Dark outline/hair
  const dark = `hsl(${hueBase}, ${sat * 0.5}%, ${8 + rng() * 6}%)`;

  // ── Fill background ──
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, SIZE, SIZE);

  // ── Body shape traits from genome ──
  const isMinimal = (agent.minimalism || 50) > 60;
  const isOrnate = (agent.ornamentation || 50) > 60;
  const highRisk = (agent.risk || 50) > 65;
  const symmetryPref = (agent.symmetry || 60) > 55;

  // ── Hair style (top 3 rows, rows 0-2) — from archetype + risk ──
  const hairH = highRisk ? 3 : 2;
  ctx.fillStyle = dark;
  // Hair base shape
  for (let y = 0; y < hairH; y++) {
    const inset = y === 0 ? (highRisk ? 3 : 4) : (y === 1 ? 3 : 3);
    const w = SIZE - inset * 2;
    ctx.fillRect(inset, y + 1, w, 1);
    if (symmetryPref) {
      // Clean symmetric hair
    } else {
      // Asymmetric strand
      if (rng() > 0.5) ctx.fillRect(inset - 1, y + 1, 1, 1);
    }
  }

  // ── Face (rows 3-7) ──
  ctx.fillStyle = skin;
  // Face shape: wider if ornate, narrower if minimal
  const faceInset = isMinimal ? 5 : 4;
  for (let y = 3; y <= 7; y++) {
    const inset = y === 3 ? faceInset : (y >= 7 ? faceInset + 1 : faceInset);
    ctx.fillRect(inset, y + 1, SIZE - inset * 2, 1);
  }

  // ── Eyes (row 5) — from novelty + risk ──
  const eyeY = 5;
  const eyeStyle = (agent.novelty || 50) > 65 ? 'wide' : (agent.novelty || 50) < 35 ? 'narrow' : 'normal';
  ctx.fillStyle = dark;
  const eyeL = 5, eyeR = 10;
  ctx.fillRect(eyeL, eyeY + 1, eyeStyle === 'wide' ? 2 : 1, 1);
  ctx.fillRect(eyeR, eyeY + 1, eyeStyle === 'wide' ? 2 : 1, 1);
  // Eye color accent for high novelty
  if ((agent.novelty || 50) > 55) {
    ctx.fillStyle = accent;
    ctx.fillRect(eyeL, eyeY + 1, 1, 1);
    ctx.fillRect(eyeR + (eyeStyle === 'wide' ? 1 : 0), eyeY + 1, 1, 1);
  }

  // ── Mouth (row 7) ──
  ctx.fillStyle = `hsl(${skinHue + 5}, 35%, ${skinLight - 15}%)`;
  const mouthW = isMinimal ? 2 : (isOrnate ? 4 : 3);
  ctx.fillRect(Math.floor((SIZE - mouthW) / 2), 8, mouthW, 1);

  // ── Body/Shoulders (rows 9-12) ──
  ctx.fillStyle = primary;
  for (let y = 9; y <= 12; y++) {
    const bodyInset = y === 9 ? 4 : (y === 10 ? 3 : 2);
    ctx.fillRect(bodyInset, y + 1, SIZE - bodyInset * 2, 1);
  }

  // ── Collar/Detail (row 9-10) — from market focus ──
  ctx.fillStyle = secondary;
  ctx.fillRect(6, 10, 4, 1);
  if (isOrnate) {
    ctx.fillStyle = accent;
    ctx.fillRect(7, 10, 2, 1);
    // Ornament dots on shoulders
    ctx.fillRect(3, 11, 1, 1);
    ctx.fillRect(12, 11, 1, 1);
  }

  // ── Lower body (rows 13-15) ──
  ctx.fillStyle = primary;
  for (let y = 13; y <= 15; y++) {
    ctx.fillRect(2, y, SIZE - 4, 1);
  }

  // ── Accessories based on genome ──
  // High price point → gem on forehead
  if ((agent.pricePoint || 50) > 65) {
    ctx.fillStyle = accent;
    ctx.fillRect(Math.floor(SIZE / 2), 3, 1, 1);
  }
  // High manufacturability → tool/gear mark on chest
  if ((agent.manufacturability || 60) > 70) {
    ctx.fillStyle = dark;
    ctx.fillRect(7, 12, 2, 1);
    ctx.fillRect(8, 11, 1, 1);
  }
  // High wearability → softer rounded shoulders
  if ((agent.wearability || 65) > 70) {
    ctx.fillStyle = bg;
    ctx.fillRect(2, 10, 1, 1);
    ctx.fillRect(13, 10, 1, 1);
  }
  // High trend sensitivity → streak in hair
  if ((agent.trendSens || 45) > 60) {
    ctx.fillStyle = accent;
    ctx.fillRect(highRisk ? 5 : 6, 2, 2, 1);
  }

  // ── Ear detail ──
  ctx.fillStyle = skin;
  ctx.fillRect(faceInset - 1, 5, 1, 2);
  ctx.fillRect(SIZE - faceInset, 5, 1, 2);

  // ── Nose hint (row 6) ──
  ctx.fillStyle = `hsl(${skinHue}, ${15}%, ${skinLight - 8}%)`;
  ctx.fillRect(Math.floor(SIZE / 2), 7, 1, 1);

  // ── Style-tag-driven patterns on torso ──
  const tags = (agent.styleTags || []).join(' ').toLowerCase();
  if (tags.includes('ornate') || tags.includes('baroque')) {
    ctx.fillStyle = accent;
    for (let i = 0; i < 3; i++) {
      const px = 4 + Math.floor(rng() * 8);
      const py = 11 + Math.floor(rng() * 3);
      ctx.fillRect(px, py, 1, 1);
    }
  }
  if (tags.includes('minimal') || tags.includes('clean')) {
    // Clean collar line
    ctx.fillStyle = secondary;
    ctx.fillRect(5, 10, 6, 1);
  }
  if (tags.includes('industrial') || tags.includes('tech')) {
    ctx.fillStyle = `hsl(0, 0%, 45%)`;
    ctx.fillRect(4, 12, 1, 2);
    ctx.fillRect(11, 12, 1, 2);
  }
  if (tags.includes('organic') || tags.includes('nature')) {
    ctx.fillStyle = `hsl(120, 35%, 35%)`;
    ctx.fillRect(3, 13, 1, 1);
    ctx.fillRect(12, 13, 1, 1);
  }

  // ── Border frame ──
  ctx.fillStyle = `hsl(${hueBase}, ${sat * 0.4}%, 18%)`;
  for (let i = 0; i < SIZE; i++) {
    ctx.fillRect(i, 0, 1, 1);
    ctx.fillRect(i, SIZE - 1, 1, 1);
    ctx.fillRect(0, i, 1, 1);
    ctx.fillRect(SIZE - 1, i, 1, 1);
  }

  return canvas.toDataURL('image/png');
}

/* ══════════════════════════════════
   AGENT PROFILE MODAL
══════════════════════════════════ */
function openAgentModal(agentId) {
  const agent = agentStates.find(a => a.id === agentId);
  if (!agent) return;
  const modal = document.getElementById('agent-modal');
  const overlay = document.getElementById('agent-modal-overlay');

  const avatarSrc = agent.avatarDataUrl || '';
  const repMult = (0.7 + ((agent.reputation || 50) / 100) * 0.6).toFixed(2);

  // Genome bar helper
  const gbar = (label, key, color) => {
    const val = agent[key] ?? 50;
    return `<div class="am-genome-row">
      <span class="am-g-label">${label}</span>
      <div class="am-g-bar"><div class="am-g-fill" style="width:${val}%;background:${color}"></div></div>
      <span class="am-g-val">${val}</span>
    </div>`;
  };

  // Evolution history
  const evoHtml = (agent.evolutionHistory || []).map(e =>
    `<div class="am-evo-entry"><b>Cycle ${e.cycle}:</b> ${e.summary}${e.genomeShifts ? ' · ' + Object.entries(e.genomeShifts).filter(([,v])=>v!==0).map(([k,v])=>`${k}:${v>0?'+':''}${v}`).join(' ') : ''}</div>`
  ).join('') || '<div class="am-evo-entry">No evolution history yet.</div>';

  // Style tags
  const tagsHtml = (agent.styleTags || []).map(t => `<span class="am-tag">${t}</span>`).join('') || '<span class="am-tag">none</span>';

  modal.innerHTML = `
    <button class="agent-modal-close" onclick="closeAgentModal()">✕</button>
    <div class="am-header">
      <img class="am-avatar" src="${avatarSrc}" alt="${agent.name}" />
      <div class="am-identity">
        <h2>${agent.name}${agent.isUser ? ' <span style="font-size:.55rem;color:var(--gold-d);border:1px solid var(--gold-d);padding:.08rem .35rem;vertical-align:middle;letter-spacing:.1em">YOU</span>' : ''}</h2>
        <div class="am-arch">${agent.arch || 'Designer'}</div>
        <div class="am-phil">"${agent.philosophy || 'No philosophy set.'}"</div>
      </div>
    </div>

    <div class="am-stats">
      <div class="am-stat"><div class="am-stat-val">${(agent.credits || 0).toLocaleString()}⬡</div><div class="am-stat-lbl">Credits</div></div>
      <div class="am-stat"><div class="am-stat-val">${agent.reputation || 50}</div><div class="am-stat-lbl">Reputation</div></div>
      <div class="am-stat"><div class="am-stat-val">${repMult}×</div><div class="am-stat-lbl">Vote Weight</div></div>
    </div>

    <div class="am-section">
      <div class="am-section-title">Jewelry Expertise</div>
      <div class="am-genome-grid">
        ${gbar('Rings','rings','var(--gold)')}
        ${gbar('Necklaces','necklaces','var(--gold-l)')}
        ${gbar('Earrings','earrings','var(--purp)')}
        ${gbar('Bracelets','bracelets','var(--blu)')}
        ${gbar('High Jewelry','highJewelry','var(--grn)')}
      </div>
    </div>

    <div class="am-section">
      <div class="am-section-title">Style Genome</div>
      <div class="am-genome-grid">
        ${gbar('Minimalism','minimalism','var(--blu)')}
        ${gbar('Novelty','novelty','var(--purp)')}
        ${gbar('Ornament','ornamentation','var(--gold)')}
        ${gbar('Market Fit','marketFit','var(--grn)')}
        ${gbar('Symmetry','symmetry','var(--dim)')}
        ${gbar('Risk','risk','var(--red)')}
      </div>
    </div>

    <div class="am-section">
      <div class="am-section-title">Material Genome</div>
      <div class="am-genome-grid">
        ${gbar('Platinum','platBias','#b0b0b0')}
        ${gbar('Color Stone','coloredStone','var(--purp)')}
        ${gbar('Diamond','diamond','#e0e0e0')}
        ${gbar('Mixed Metal','mixedMetal','var(--gold-d)')}
      </div>
    </div>

    <div class="am-section">
      <div class="am-section-title">Commercial Genome</div>
      <div class="am-genome-grid">
        ${gbar('Price Point','pricePoint','var(--gold)')}
        ${gbar('Manufact.','manufacturability','var(--grn)')}
        ${gbar('Wearability','wearability','var(--blu)')}
        ${gbar('Trend Sens.','trendSens','var(--purp)')}
        ${gbar('Margin Sens.','marginSens','var(--red)')}
        ${gbar('Complexity','complexBudget','var(--dim)')}
      </div>
    </div>

    <div class="am-section">
      <div class="am-section-title">Style Tags</div>
      <div class="am-tags">${tagsHtml}</div>
    </div>

    ${agent.bio ? `<div class="am-section">
      <div class="am-section-title">Bio</div>
      <div class="am-bio">${agent.bio}</div>
    </div>` : ''}

    ${agent.dominantBelief ? `<div class="am-section">
      <div class="am-section-title">Current Belief</div>
      <div class="am-belief">${agent.dominantBelief}</div>
    </div>` : ''}

    <div class="am-section">
      <div class="am-section-title">Evolution History</div>
      ${evoHtml}
    </div>
  `;

  overlay.classList.add('show');
}

function closeAgentModal() {
  document.getElementById('agent-modal-overlay').classList.remove('show');
}

// Helper: generate inline <img> tag for an agent's avatar
function agentAvatarImg(agent, cssClass) {
  if (!agent || !agent.avatarDataUrl) return agent?.emoji || '';
  return `<img src="${agent.avatarDataUrl}" class="${cssClass}" alt="${agent.name||''}" />`;
}

/* ══════════════════════════════════
   MODE & API KEY MANAGEMENT
══════════════════════════════════ */
let simMode = 'live'; // always live — all agent decisions go through Claude API
let apiKeys = { anthropic: '', higgsfield: '' };
let apiKeysCommitted = false; // true once user clicks Submit

// Genome snapshots per cycle for before→after deltas
let genomeSnapshots = []; // array of arrays: genomeSnapshots[cycleIdx] = [{...agentGenome}]

// ── Claude-Flow Agent Economy Globals ──
let patternBank = [];       // Pattern Memory Bank: stores design patterns with outcome data
let qTable = {};            // Q-Learning Strategy Router: strategy×category → expected reward
let rationaleStore = [];    // Design Rationale Persistence: per-agent, per-cycle reasoning + outcomes
let traitEffectiveness = {}; // EWC Trait Tracker: genome trait → correlation/importance data

function initQTable() {
  const strategies = ['exploit','explore','mutate'];
  const categories = ['Ring','Pendant','Earrings','Bracelet'];
  qTable = {};
  strategies.forEach(s => {
    qTable[s] = {};
    categories.forEach(c => {
      qTable[s][c] = { totalCredits: 0, count: 0, avgCredits: 0, lastCycle: 0 };
    });
  });
}

function setMode(mode) {
  simMode = 'live'; // always live
  checkApiKeys();
}

function checkApiKeys() {
  const antVal = (document.getElementById('api-anthropic')?.value || '').trim();
  const hfVal = (document.getElementById('api-higgsfield')?.value || '').trim();
  const dot = document.getElementById('api-dot');
  const txt = document.getElementById('api-status-text');
  const startBtn = document.getElementById('home-start-btn');
  const apBtn = document.getElementById('autopilot-btn');
  const submitBtn = document.getElementById('api-submit-btn');
  const hasAnt = antVal.length > 0;
  const hasHf = hfVal.length > 0;
  if (submitBtn) submitBtn.disabled = !hasAnt;
  if (apiKeysCommitted) {
    if (dot) dot.className = 'dot ok';
    if (txt) txt.textContent = 'API keys committed ✓' + (apiKeys.higgsfield ? ' — Claude + Higgsfield active' : ' — Claude active (images: free tier)');
    if (startBtn) startBtn.disabled = false;
    if (apBtn) apBtn.disabled = false;
  } else if (hasAnt) {
    if (dot) dot.className = 'dot warn';
    if (txt) txt.textContent = 'Claude key entered' + (hasHf ? ' + Higgsfield key entered' : '') + ' — press Submit to lock in';
    if (startBtn) startBtn.disabled = true;
    if (apBtn) apBtn.disabled = true;
  } else {
    if (dot) dot.className = 'dot warn';
    if (txt) txt.textContent = 'Enter your Anthropic (Claude) API key — required for all agent decisions';
    if (startBtn) startBtn.disabled = true;
    if (apBtn) apBtn.disabled = true;
  }
}

function submitApiKeys() {
  const antVal = (document.getElementById('api-anthropic')?.value || '').trim();
  const hfVal = (document.getElementById('api-higgsfield')?.value || '').trim();
  if (!antVal) return;
  apiKeys.anthropic = antVal;
  apiKeys.higgsfield = hfVal;
  apiKeysCommitted = true;
  // Persist to localStorage so keys survive page reloads
  try {
    localStorage.setItem('jf_key_ant', antVal);
    if (hfVal) localStorage.setItem('jf_key_hf', hfVal);
  } catch(e) { /* storage unavailable */ }
  lockApiInputs();
}

function lockApiInputs() {
  const antInput = document.getElementById('api-anthropic');
  const hfInput = document.getElementById('api-higgsfield');
  if (antInput) { antInput.disabled = true; antInput.style.opacity = '.6'; }
  if (hfInput) { hfInput.disabled = true; hfInput.style.opacity = '.6'; }
  const submitBtn = document.getElementById('api-submit-btn');
  if (submitBtn) { submitBtn.textContent = 'Keys Committed ✓'; submitBtn.disabled = true; submitBtn.style.borderColor = 'var(--grn)'; submitBtn.style.color = 'var(--grn)'; }
  const clearBtn = document.getElementById('api-clear-btn');
  if (clearBtn) clearBtn.style.display = 'inline';
  checkApiKeys();
}

function clearSavedKeys() {
  try { localStorage.removeItem('jf_key_ant'); localStorage.removeItem('jf_key_hf'); } catch(e) {}
  apiKeys.anthropic = '';
  apiKeys.higgsfield = '';
  apiKeysCommitted = false;
  const antInput = document.getElementById('api-anthropic');
  const hfInput = document.getElementById('api-higgsfield');
  if (antInput) { antInput.value = ''; antInput.disabled = false; antInput.style.opacity = ''; }
  if (hfInput) { hfInput.value = ''; hfInput.disabled = false; hfInput.style.opacity = ''; }
  const submitBtn = document.getElementById('api-submit-btn');
  if (submitBtn) { submitBtn.textContent = 'Submit API Keys'; submitBtn.style.borderColor = ''; submitBtn.style.color = ''; }
  const clearBtn = document.getElementById('api-clear-btn');
  if (clearBtn) clearBtn.style.display = 'none';
  checkApiKeys();
}

// Restore saved API keys from localStorage on page load
function loadSavedKeys() {
  try {
    const savedAnt = localStorage.getItem('jf_key_ant') || '';
    const savedHf = localStorage.getItem('jf_key_hf') || '';
    if (!savedAnt) return;
    const antInput = document.getElementById('api-anthropic');
    const hfInput = document.getElementById('api-higgsfield');
    if (antInput) antInput.value = savedAnt;
    if (hfInput && savedHf) hfInput.value = savedHf;
    // Commit saved keys
    apiKeys.anthropic = savedAnt;
    apiKeys.higgsfield = savedHf;
    apiKeysCommitted = true;
    lockApiInputs();
  } catch(e) { /* storage unavailable */ }
}
document.addEventListener('DOMContentLoaded', () => { loadSavedKeys(); restoreGDriveConfig(); });
document.addEventListener('keydown', e => { if (e.key === 'Escape') closeAgentModal(); });

function startFromHome() {
  goTo(1);
}

/* ══════════════════════════════════
   AUTOPILOT — Generate All Agents & Run All Cycles
══════════════════════════════════ */
let autopilotRunning = false;

async function runAutopilot() {
  if (autopilotRunning) return;
  if (!apiKeysCommitted) return;
  autopilotRunning = true;

  const btn = document.getElementById('autopilot-btn');
  const startBtn = document.getElementById('home-start-btn');
  if (btn) { btn.classList.add('running'); btn.textContent = '⚡ Autopilot Running…'; btn.disabled = true; }
  if (startBtn) startBtn.disabled = true;

  // Set speed to 5x for faster autopilot
  speed = 5;

  try {
    // Phase 1: Navigate to builder and auto-generate + deploy all 6 agents
    goTo(1);
    currentAgentNum = 1;
    configuredAgents = [];

    for (let i = 0; i < 6; i++) {
      if (btn) btn.textContent = `⚡ Generating Agent ${i + 1}/6…`;
      await autoGen();
      await deployCurrentAgent();
      // Small delay between agents to let UI update
      await new Promise(r => setTimeout(r, 200));
    }

    // startSimulation() was called by deployCurrentAgent when agent 6 was deployed
    // Now we're on screen 2 (simulator). Run all 3 cycles.

    for (let cycle = 1; cycle <= 3; cycle++) {
      if (btn) btn.textContent = `⚡ Cycle ${cycle} — Running Phases…`;

      // Run all 5 phases for this cycle
      for (let phase = 0; phase < 5; phase++) {
        if (btn) btn.textContent = `⚡ Cycle ${cycle} — Phase ${phase + 1}/5…`;

        // nextPhase() increments currentPhase internally and runs the phase script
        // It uses setTimeout for the UI delay — we need to wait for that to complete
        await runNextPhaseAutopilot();
      }

      // After phase 4 (index 4), showCycleComplete() is called
      // Wait a brief moment for the cycle complete panel to render
      await new Promise(r => setTimeout(r, 500));

      // Advance to next cycle or finish
      if (cycle < 3) {
        currentCycle++;
        resetSim();
        const ccPanel = document.getElementById('cc-panel');
        if (ccPanel) ccPanel.className = 'cycle-complete';
        document.getElementById('phase-btn').style.display = '';
        await new Promise(r => setTimeout(r, 300));
      }
    }

    // All 3 cycles complete — go to reports
    if (btn) btn.textContent = '⚡ Autopilot Complete ✓';
    await new Promise(r => setTimeout(r, 500));
    goTo(3);
    viewReport(3);

  } catch (e) {
    console.error('Autopilot error:', e);
    if (btn) btn.textContent = '⚡ Autopilot Failed — ' + e.message;
  } finally {
    autopilotRunning = false;
    if (btn) { btn.classList.remove('running'); btn.disabled = false; }
    if (startBtn) startBtn.disabled = false;
    speed = 1;
  }
}

// Helper: runs nextPhase() and waits for its setTimeout callback to complete
function runNextPhaseAutopilot() {
  return new Promise(async (resolve) => {
    currentPhase++;
    if (currentPhase >= 5) { resolve(); return; }
    setPhaseActive(currentPhase);
    document.getElementById('phase-btn').disabled = true;
    document.getElementById('phase-btn').textContent = '⏳ Running phase…';

    const scripts = PHASE_SCRIPTS[currentCycle - 1] || PHASE_SCRIPTS[0];
    const script = scripts[currentPhase];
    const finishDelay = await script();

    setTimeout(() => {
      document.getElementById('phase-btn').disabled = false;
      if (currentPhase === 4) {
        document.getElementById('phase-btn').style.display = 'none';
        showCycleComplete();
      } else {
        const labels = ['▶ Proceed to Synthesis','▶ Generate Designs','▶ Begin Agent Voting','▶ Apply Evolution'];
        document.getElementById('phase-btn').textContent = labels[currentPhase] || '▶ Next Phase';
      }
      resolve();
    }, finishDelay / speed);
  });
}

/* ══════════════════════════════════
   GOOGLE DRIVE AUTO-SAVE
   Uploads every generated image to a Google Drive folder
   via a Google Apps Script Web App proxy. No OAuth setup needed —
   just deploy the script and paste the URL.
══════════════════════════════════ */
let gdriveState = {
  connected: false,
  webAppUrl: '',
  uploadCount: 0,
  uploadedUrls: new Set(),
  uploading: 0,       // count of in-flight uploads
  failCount: 0,       // consecutive failures for circuit breaker
};

function copyScriptCode() {
  const code = `function doGet(e) {\n  return ContentService.createTextOutput(\n    JSON.stringify({status:"ok"})\n  ).setMimeType(ContentService.MimeType.JSON);\n}\n\nfunction doPost(e) {\n  try {\n    var data = JSON.parse(e.postData.contents);\n    var folder = DriveApp.getFolderById("YOUR_FOLDER_ID_HERE");\n    var file;\n    if (data.textContent) {\n      file = folder.createFile(\n        data.filename || "jewelforge-data.json",\n        data.textContent,\n        data.mimeType || "application/json"\n      );\n    } else if (data.imageUrl) {\n      var resp = UrlFetchApp.fetch(data.imageUrl);\n      var blob = resp.getBlob().setName(\n        data.filename || "jewelforge-image.png"\n      );\n      file = folder.createFile(blob);\n    } else if (data.image) {\n      var blob = Utilities.newBlob(\n        Utilities.base64Decode(data.image),\n        data.mimeType || "image/png",\n        data.filename || "jewelforge-image.png"\n      );\n      file = folder.createFile(blob);\n    } else {\n      return ContentService.createTextOutput(\n        JSON.stringify({success:false, error:"No file data"})\n      ).setMimeType(ContentService.MimeType.JSON);\n    }\n    return ContentService.createTextOutput(\n      JSON.stringify({success:true, id:file.getId(), name:file.getName()})\n    ).setMimeType(ContentService.MimeType.JSON);\n  } catch(err) {\n    return ContentService.createTextOutput(\n      JSON.stringify({success:false, error:err.message})\n    ).setMimeType(ContentService.MimeType.JSON);\n  }\n}`;
  navigator.clipboard.writeText(code).then(() => {
    const btn = document.querySelector('.gdrive-copy-btn');
    if (btn) { btn.textContent = '✓ Copied!'; setTimeout(() => { btn.textContent = '📋 Copy Script'; }, 2000); }
  }).catch(() => {
    // Fallback: select text
    const pre = document.querySelector('#gdrive-script-code pre');
    if (pre) { const range = document.createRange(); range.selectNodeContents(pre); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }
  });
}

function updateGDriveStatus() {
  const url = (document.getElementById('gdrive-webapp-url')?.value || '').trim();
  gdriveState.webAppUrl = url;
  const btn = document.getElementById('gdrive-connect-btn');
  if (btn) btn.disabled = !url || !url.startsWith('https://script.google.com/');
}

// Helper: POST to Apps Script and validate the JSON response
async function gdrivePost(payload) {
  const resp = await fetch(gdriveState.webAppUrl, {
    method: 'POST',
    redirect: 'follow',
    headers: { 'Content-Type': 'text/plain' },
    body: JSON.stringify(payload)
  });
  let result;
  try {
    result = await resp.json();
  } catch(e) {
    throw new Error('Invalid response — update & re-deploy your Apps Script');
  }
  if (!result.success) {
    throw new Error(result.error || 'Upload rejected by Apps Script');
  }
  return result;
}

// Helper: increment upload counter and update UI
function gdriveCountUpload(filename) {
  gdriveState.uploadCount++;
  gdriveState.failCount = 0;
  showGDriveRetryBtn(false);
  const counterEl = document.getElementById('gdrive-upload-count');
  if (counterEl) counterEl.textContent = gdriveState.uploadCount;
  setGDriveStatus(true, `Connected — ${gdriveState.uploadCount} file${gdriveState.uploadCount!==1?'s':''} saved`);
  console.log(`📁 Saved to Drive: ${filename}`);
}

async function connectGoogleDrive() {
  const url = gdriveState.webAppUrl;
  if (!url) return;

  const btn = document.getElementById('gdrive-connect-btn');
  if (btn) { btn.disabled = true; btn.innerHTML = '<span class="g-logo">⏳</span> Testing connection…'; }
  setGDriveStatus(false, 'Testing connection…');

  try {
    // Test with a GET request first — verifies script is deployed and folder ID is valid
    const resp = await fetch(url, { method: 'GET', redirect: 'follow' });
    let data;
    try { data = await resp.json(); } catch(e) { data = {}; }

    if (data.status === 'ok') {
      // Script has doGet() — verified working
    } else if (data.error) {
      throw new Error(data.error);
    } else {
      // Older script without doGet() — try a POST test upload
      const testPng = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
      await gdrivePost({ image: testPng, filename: '_jewelforge_connection_test.png', mimeType: 'image/png' });
    }

    gdriveState.connected = true;
    gdriveState.failCount = 0;
    setGDriveStatus(true, 'Connected — files will auto-save to Drive');
    if (btn) { btn.innerHTML = '<span class="g-logo">✓</span> Auto-Save Enabled'; btn.disabled = true; }
    document.getElementById('gdrive-disconnect-btn').style.display = '';
    document.getElementById('gdrive-counter').style.display = '';

    // Hide setup steps to reduce clutter
    const steps = document.getElementById('gdrive-setup-steps');
    if (steps) steps.style.display = 'none';

    // Persist config
    localStorage.setItem('jf_gdrive_url', url);

    // Upload any already-cached images
    uploadCachedImages();
  } catch(e) {
    console.warn('Drive connection test failed:', e);
    const msg = e.message || 'Unknown error';
    if (msg.includes('Folder not found') || msg.includes('getFolderById')) {
      setGDriveStatus(false, 'Failed — wrong folder ID in your Apps Script');
    } else if (msg.includes('update') || msg.includes('Invalid response')) {
      setGDriveStatus(false, 'Failed — update your Apps Script code & re-deploy');
    } else {
      setGDriveStatus(false, `Connection failed — ${msg}`);
    }
    if (btn) { btn.disabled = false; btn.innerHTML = '<span class="g-logo">📁</span> Enable Auto-Save'; }
  }
}

function disconnectGoogleDrive() {
  gdriveState.connected = false;
  gdriveState.webAppUrl = '';
  gdriveState.uploadedUrls.clear();
  gdriveState.uploadCount = 0;
  gdriveState.failCount = 0;
  setGDriveStatus(false, 'Disconnected');
  const btn = document.getElementById('gdrive-connect-btn');
  if (btn) { btn.disabled = false; btn.innerHTML = '<span class="g-logo">📁</span> Enable Auto-Save'; }
  document.getElementById('gdrive-disconnect-btn').style.display = 'none';
  document.getElementById('gdrive-counter').style.display = 'none';
  document.getElementById('gdrive-webapp-url').value = '';
  const steps = document.getElementById('gdrive-setup-steps');
  if (steps) steps.style.display = '';
  localStorage.removeItem('jf_gdrive_url');
}

function setGDriveStatus(connected, text) {
  const dot = document.getElementById('gdrive-dot');
  const label = document.getElementById('gdrive-status-text');
  if (dot) { dot.className = 'dot ' + (connected ? 'connected' : 'off'); }
  if (label) label.textContent = text;
}

function showGDriveRetryBtn(show) {
  const btn = document.getElementById('gdrive-retry-btn');
  if (btn) btn.style.display = show ? '' : 'none';
}

function retryGDriveUploads() {
  gdriveState.failCount = 0;
  gdriveState.uploadedUrls.clear();
  showGDriveRetryBtn(false);
  setGDriveStatus(true, 'Retrying uploads…');
  uploadCachedImages();
}

// Convert an image URL to base64 data via canvas
async function imageUrlToBase64(imageUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      // Get base64 without the data:image/png;base64, prefix
      const dataUrl = canvas.toDataURL('image/png');
      const base64 = dataUrl.split(',')[1];
      resolve(base64);
    };
    img.onerror = () => reject(new Error('Failed to load image for base64 conversion'));
    img.src = imageUrl;
  });
}

// Auto-upload a single image to Google Drive via Apps Script
async function uploadImageToDrive(imageUrlOrBase64, filename) {
  if (!gdriveState.connected || !gdriveState.webAppUrl) return;
  if (gdriveState.uploadedUrls.has(imageUrlOrBase64)) return;
  // Circuit breaker: pause after 5 consecutive failures
  if (gdriveState.failCount >= 5) {
    if (gdriveState.failCount === 5) {
      setGDriveStatus(false, 'Paused — too many failures. Check Apps Script.');
      showGDriveRetryBtn(true);
      gdriveState.failCount++;  // only show message once
    }
    return;
  }
  gdriveState.uploadedUrls.add(imageUrlOrBase64);
  gdriveState.uploading++;

  const safeName = (filename || 'jewelforge-image').replace(/[^a-zA-Z0-9_\-. ]/g, '_').slice(0, 100) + '.png';

  // Determine if we already have base64 data (from _designBase64Cache)
  const isBase64 = imageUrlOrBase64.length > 500 && !imageUrlOrBase64.startsWith('http');

  try {
    if (isBase64) {
      // Primary: send actual image data — most reliable, no server-side fetch needed
      await gdrivePost({ image: imageUrlOrBase64, filename: safeName, mimeType: 'image/png' });
    } else {
      // Have a URL — try converting to base64 via canvas first
      let sent = false;
      try {
        const base64 = await imageUrlToBase64(imageUrlOrBase64);
        await gdrivePost({ image: base64, filename: safeName, mimeType: 'image/png' });
        sent = true;
      } catch(convErr) {
        if (convErr.message && !convErr.message.includes('Failed to load image')) {
          throw convErr;  // Re-throw server errors, only retry on canvas conversion failures
        }
        console.warn('Base64 conversion failed, falling back to URL:', convErr.message);
      }
      if (!sent) {
        // Fallback: send the URL and let Apps Script fetch it server-side
        await gdrivePost({ imageUrl: imageUrlOrBase64, filename: safeName });
      }
    }

    gdriveCountUpload(safeName);
  } catch(e) {
    console.warn('Drive upload failed:', e.message);
    gdriveState.uploadedUrls.delete(imageUrlOrBase64);
    gdriveState.failCount++;
    if (gdriveState.failCount >= 5) {
      setGDriveStatus(false, 'Paused — upload errors. Check Apps Script deployment.');
      showGDriveRetryBtn(true);
    }
  } finally {
    gdriveState.uploading--;
  }
}

// Cache for base64-encoded image data, keyed same as _designImageCache
const _designBase64Cache = {};

// Convert a loaded img element to base64 via canvas
function imgElementToBase64(imgEl) {
  try {
    const canvas = document.createElement('canvas');
    canvas.width = imgEl.naturalWidth || 512;
    canvas.height = imgEl.naturalHeight || 512;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(imgEl, 0, 0);
    const dataUrl = canvas.toDataURL('image/png');
    return dataUrl.split(',')[1];
  } catch(e) {
    // Canvas tainted by cross-origin image — can't extract data
    return null;
  }
}

// Upload all already-cached images
function uploadCachedImages() {
  Object.entries(_designImageCache).forEach(([key, url]) => {
    if (url && !url.startsWith('data:')) {
      const parts = key.split('-');
      const filename = `JewelForge_Cycle${parts[0]}_Agent${parts[1]}_design`;
      // Prefer cached base64 data over URL
      const base64 = _designBase64Cache[key];
      uploadImageToDrive(base64 || url, filename);
    }
  });
}

// Central hook: call this whenever an image successfully loads
function onImageGenerated(imageUrl, designObj, cycle, agentIdx, imgElement) {
  if (!imageUrl || imageUrl.startsWith('data:')) return;
  const name = designObj?.name || 'design';
  const agent = designObj?.agentName || 'Agent' + agentIdx;
  const filename = `JewelForge_C${cycle}_${agent}_${name}`.replace(/\s+/g, '_');
  const cacheKey = cycle + '-' + agentIdx;

  // Try to capture base64 from the loaded img element for reliable upload
  let base64 = _designBase64Cache[cacheKey];
  if (!base64 && imgElement) {
    base64 = imgElementToBase64(imgElement);
    if (base64) _designBase64Cache[cacheKey] = base64;
  }

  uploadImageToDrive(base64 || imageUrl, filename);
}

// Auto-upload a cycle report JSON to Google Drive
async function uploadReportToDrive(report, cycleNum) {
  if (!gdriveState.connected || !gdriveState.webAppUrl) return;
  if (gdriveState.failCount >= 5) return;

  const safeName = `JewelForge_Cycle${cycleNum}_Report.json`;

  // Strip agentSnapshot (large, redundant with agentPerf) for a leaner payload
  const payload = JSON.parse(JSON.stringify(report));
  delete payload.agentSnapshot;

  try {
    await gdrivePost({
      textContent: JSON.stringify(payload, null, 2),
      filename: safeName,
      mimeType: 'application/json'
    });
    gdriveCountUpload(safeName);
  } catch(e) {
    console.warn('Drive report upload failed:', e.message);
    gdriveState.failCount++;
    if (gdriveState.failCount >= 5) {
      setGDriveStatus(false, 'Paused — upload errors. Check Apps Script deployment.');
      showGDriveRetryBtn(true);
    }
  }
}

// Auto-upload epoch archive (all 3 cycles) to Google Drive
async function uploadEpochArchiveToDrive() {
  if (!gdriveState.connected || !gdriveState.webAppUrl) return;
  if (cycleReports.length < 3) return;

  const archive = {
    title: 'JewelForge Epoch Intelligence Archive',
    exportedAt: new Date().toISOString(),
    cycles: cycleReports.map(r => {
      const copy = JSON.parse(JSON.stringify(r));
      delete copy.agentSnapshot;
      return copy;
    })
  };

  try {
    await gdrivePost({
      textContent: JSON.stringify(archive, null, 2),
      filename: 'JewelForge_Epoch_Archive.json',
      mimeType: 'application/json'
    });
    gdriveCountUpload('JewelForge_Epoch_Archive.json');
  } catch(e) {
    console.warn('Drive epoch archive upload failed:', e.message);
    gdriveState.failCount++;
    if (gdriveState.failCount >= 5) {
      setGDriveStatus(false, 'Paused — upload errors. Check Apps Script deployment.');
      showGDriveRetryBtn(true);
    }
  }
}

// Auto-upload per-cycle PDF report to Google Drive
async function uploadPdfReportToDrive(report, cycleNum) {
  if (!gdriveState.connected || !gdriveState.webAppUrl) return;
  if (gdriveState.failCount >= 5) return;
  if (!window.jspdf || !window.html2canvas) return; // libs not loaded

  const filename = `JewelForge_Cycle${cycleNum}_Report.pdf`;

  try {
    setGDriveStatus(true, `Generating Cycle ${cycleNum} PDF for Drive…`);
    const base64 = await _buildReportPDF(report, filename, { skipDownload: true, showOverlay: false });
    if (!base64) throw new Error('PDF generation returned empty');

    await gdrivePost({
      image: base64,
      filename: filename,
      mimeType: 'application/pdf'
    });
    gdriveCountUpload(filename);
  } catch(e) {
    console.warn('Drive PDF upload failed:', e.message);
    gdriveState.failCount++;
    if (gdriveState.failCount >= 5) {
      setGDriveStatus(false, 'Paused — upload errors. Check Apps Script deployment.');
      showGDriveRetryBtn(true);
    }
  }
}

// Auto-upload full epoch PDF archive to Google Drive (all 3 cycles)
async function uploadPdfEpochArchiveToDrive() {
  if (!gdriveState.connected || !gdriveState.webAppUrl) return;
  if (cycleReports.length < 3) return;
  if (gdriveState.failCount >= 5) return;
  if (!window.jspdf || !window.html2canvas) return;

  const filename = 'JewelForge_Epoch_Intelligence_Archive.pdf';

  try {
    setGDriveStatus(true, 'Generating Epoch PDF archive for Drive…');
    const base64 = await _buildMultiReportPDF(cycleReports, filename, { skipDownload: true, showOverlay: false });
    if (!base64) throw new Error('PDF generation returned empty');

    await gdrivePost({
      image: base64,
      filename: filename,
      mimeType: 'application/pdf'
    });
    gdriveCountUpload(filename);
  } catch(e) {
    console.warn('Drive epoch PDF upload failed:', e.message);
    gdriveState.failCount++;
    if (gdriveState.failCount >= 5) {
      setGDriveStatus(false, 'Paused — upload errors. Check Apps Script deployment.');
      showGDriveRetryBtn(true);
    }
  }
}

// Restore saved config on page load
function restoreGDriveConfig() {
  const savedUrl = localStorage.getItem('jf_gdrive_url');
  if (savedUrl) {
    const el = document.getElementById('gdrive-webapp-url');
    if (el) el.value = savedUrl;
    gdriveState.webAppUrl = savedUrl;
    // Show reconnecting state while we verify
    setGDriveStatus(false, 'Reconnecting…');
    const btn = document.getElementById('gdrive-connect-btn');
    if (btn) { btn.innerHTML = '<span class="g-logo">⏳</span> Verifying…'; btn.disabled = true; }
    const steps = document.getElementById('gdrive-setup-steps');
    if (steps) steps.style.display = 'none';
    // Verify the saved URL actually works before marking connected
    connectGoogleDrive();
  }
  updateGDriveStatus();
}

/* ══════════════════════════════════
   agentGenomeStr() — Compile full agent DNA into prompt string
   Injects identity, style genome, material genome, risk genome,
   evolution history, and current beliefs into every LLM prompt.
══════════════════════════════════ */
function agentGenomeStr(agent) {
  const g = agent;
  const tags = (g.styleTags || []).join(', ') || 'none';
  const riskLabel = g.risk > 65 ? 'Explorer (High Novelty)' : g.risk < 35 ? 'Refiner (Exploit Lane)' : 'Balanced (Mutate)';
  const mktFocus = g.marketFocus || 'general';

  // Derived commercial labels from genome values
  const priceLabel = (g.pricePoint ?? 50) > 70 ? 'High Jewelry ($10K+)' : (g.pricePoint ?? 50) < 30 ? 'Accessible ($200-1K)' : 'Mid-Market ($1K-10K)';
  const mfgLabel = (g.manufacturability ?? 60) > 70 ? 'Production-Ready (cast, reproducible)' : (g.manufacturability ?? 60) < 30 ? 'Art-Piece (hand-fabrication only)' : 'Semi-Production (some hand-finishing)';
  const wearLabel = (g.wearability ?? 65) > 70 ? 'Daily Wear (comfort, durability)' : (g.wearability ?? 65) < 30 ? 'Statement/Runway (visual impact over comfort)' : 'Occasion Wear (special events)';
  const trendLabel = (g.trendSens ?? 45) > 70 ? 'Trend-Forward (chases current movements)' : (g.trendSens ?? 45) < 30 ? 'Timeless (ignores trends, classic forms)' : 'Trend-Aware (adapts selectively)';

  let genome = `AGENT IDENTITY:
  Name: ${g.name}
  Archetype: ${g.arch}
  Philosophy: "${g.philosophy}"
  Style Tags: [${tags}]
  Market Focus: ${mktFocus}

JEWELRY CATEGORY EXPERTISE:
  Rings: ${g.rings ?? 50}/100
  Necklaces: ${g.necklaces ?? 50}/100
  Earrings: ${g.earrings ?? 50}/100
  Bracelets: ${g.bracelets ?? 50}/100
  High Jewelry: ${g.highJewelry ?? 50}/100

STYLE GENOME:
  Minimalism: ${g.minimalism ?? g.min ?? 50}/100
  Novelty Drive: ${g.novelty}/100
  Ornamentation: ${g.ornamentation ?? g.orn ?? 50}/100
  Market Fit Priority: ${g.marketFit}/100
  Symmetry Preference: ${g.symmetry ?? g.sym ?? 60}/100

MATERIAL GENOME:
  Platinum Bias: ${g.platBias}/100
  Colored Stone Use: ${g.coloredStone ?? g.col ?? 40}/100
  Diamond Preference: ${g.diamond ?? g.dia ?? 60}/100
  Mixed/Accent Metals: ${g.mixedMetal ?? g.mix ?? 30}/100

RISK GENOME:
  Exploration↔Exploitation: ${g.risk}/100 (${riskLabel})
  Margin Sensitivity: ${g.marginSens ?? g.mrg ?? 65}/100
  Complexity Budget: ${g.complexBudget ?? g.cmp ?? 55}/100

COMMERCIAL & MANUFACTURING GENOME:
  Price Point: ${g.pricePoint ?? 50}/100 (${priceLabel})
  Manufacturability: ${g.manufacturability ?? 60}/100 (${mfgLabel})
  Wearability: ${g.wearability ?? 65}/100 (${wearLabel})
  Trend Sensitivity: ${g.trendSens ?? 45}/100 (${trendLabel})

MANUFACTURING CONSTRAINTS (derived from your genome):
  ${(g.manufacturability ?? 60) > 60 ? '• Your designs MUST be castable — avoid hand-fabrication-only forms, undercuts that prevent mold release, and multi-axis curves that cannot be cast in lost-wax.' : '• You design for hand fabrication — you CAN use complex forms, wire wrapping, granulation, and techniques that cannot be mass-produced.'}
  ${(g.wearability ?? 65) > 60 ? '• Prioritize comfort: smooth interior edges, appropriate weight for the category, secure clasps/settings, no sharp protrusions that snag clothing.' : '• Wearability is secondary — you optimize for visual drama and editorial impact over comfort.'}
  ${(g.pricePoint ?? 50) > 65 ? '• Target premium market: use precious metals and high-grade stones. Justify price with craftsmanship complexity and material value.' : (g.pricePoint ?? 50) < 35 ? '• Target accessible market: use gold vermeil, lab-grown stones, or silver. Keep material costs low. Design for volume sales.' : '• Target mid-market: balance material value with broad appeal. 14K-18K gold, quality semi-precious or smaller diamonds.'}
  ${(g.trendSens ?? 45) > 60 ? '• Actively reference current jewelry trends (what is selling NOW) when choosing forms, materials, and silhouettes.' : '• Design with longevity in mind — forms and materials that will still sell in 5 years.'}

CURRENT STATE:
  Credits: ${g.credits}
  Reputation: ${g.reputation}
  Status: ${g.status}`;

  // Append evolution history if available
  if (g.evolutionHistory && g.evolutionHistory.length > 0) {
    genome += `\n\nEVOLUTION HISTORY:`;
    g.evolutionHistory.forEach(evo => {
      genome += `\n  Cycle ${evo.cycle}: ${evo.summary}`;
      if (evo.genomeShifts) {
        Object.entries(evo.genomeShifts).forEach(([k, v]) => {
          if (v !== 0) genome += `\n    ${k}: ${v > 0 ? '+' : ''}${v}`;
        });
      }
    });
  }

  // Append conversation memory
  if (g.conversationMemory && g.conversationMemory.length > 0) {
    genome += `\n\nCONVERSATION MEMORY (prior cycles):`;
    g.conversationMemory.forEach(mem => {
      genome += `\n  [Cycle ${mem.cycle}] ${mem.partner}: "${mem.excerpt}"`;
    });
  }

  // EWC Trait Effectiveness (injected into every prompt)
  genome += traitEffectivenessContext(g.id);

  return genome;
}

/* ══════════════════════════════════
   retrievePatterns() — Pattern Memory Bank retrieval
   Scores stored design patterns by relevance to the agent
   and returns top 3 as formatted context string.
══════════════════════════════════ */
function retrievePatterns(agent) {
  if (patternBank.length === 0) return '';
  const agentIdx = agent.id;
  const scored = patternBank.map(p => {
    let score = p.confidence * 2; // base confidence weight
    score += p.rank <= 3 ? 1.5 : 0.5; // rank bonus
    if (p.category === (agent.marketFocus || '').split(',')[0]) score += 3; // category alignment
    // Strategy alignment with agent risk genome
    const agentStrategy = agent.risk > 65 ? 'explore' : agent.risk < 35 ? 'exploit' : 'mutate';
    if (p.strategy === agentStrategy) score += 2;
    // Genome similarity (within 15 pts on key traits)
    const traitPairs = [['novelty','novelty'],['marketFit','marketFit'],['risk','risk'],['platBias','platBias'],['manufacturability','manufacturability'],['wearability','wearability']];
    traitPairs.forEach(([agentTrait, patTrait]) => {
      if (Math.abs((agent[agentTrait]||50) - (p.genomeTraits?.[patTrait]||50)) <= 15) score += 1;
    });
    // Recency bonus
    if (p.cycle === cycleReports.length) score += 1;
    return { ...p, relevanceScore: score };
  });
  scored.sort((a, b) => b.relevanceScore - a.relevanceScore);
  const top3 = scored.slice(0, 3);
  let ctx = `\n\nHISTORICAL DESIGN PRECEDENTS (top ${top3.length} relevant from ${patternBank.length} stored):`;
  top3.forEach((p, i) => {
    ctx += `\n  ${i+1}. [Cycle ${p.cycle} #${p.rank}] ${p.category} (${p.credits.toLocaleString()}⬡, confidence: ${(p.confidence*100).toFixed(0)}%)`;
    ctx += `\n     ${p.strategy.toUpperCase()} · ${p.category} · ${p.materials || '?'} · ${p.form || '?'}`;
    ctx += `\n     Scores: AES:${p.aesthetic} NOV:${p.novelty} PRO:${p.profit} WEAR:${p.wearability||'?'} MFG:${p.makeable||'?'}`;
    ctx += `\n     Reasoning: ${(p.reasoning || '—').slice(0, 100)}`;
    ctx += `\n     Trend context: ${(p.emergingTrends || []).slice(0, 2).join(', ') || '—'}`;
  });
  return ctx;
}

/* ══════════════════════════════════
   qTableContext() — Q-Learning Strategy Router
   Formats non-zero Q-table entries as market intelligence.
══════════════════════════════════ */
function qTableContext() {
  if (!qTable || Object.keys(qTable).length === 0) return '';
  const entries = [];
  let bestCombo = null, bestAvg = 0;
  Object.entries(qTable).forEach(([strat, cats]) => {
    Object.entries(cats).forEach(([cat, data]) => {
      if (data.count > 0) {
        entries.push({ strat, cat, avg: Math.round(data.avgCredits), count: data.count, lastCycle: data.lastCycle });
        if (data.avgCredits > bestAvg) { bestAvg = data.avgCredits; bestCombo = { strat, cat }; }
      }
    });
  });
  if (entries.length === 0) return '';
  let ctx = `\n\nQ-TABLE MARKET INTELLIGENCE (learned strategy×category rewards):`;
  entries.sort((a, b) => b.avg - a.avg);
  entries.forEach(e => {
    const star = bestCombo && e.strat === bestCombo.strat && e.cat === bestCombo.cat ? ' ★' : '';
    ctx += `\n  ${e.strat.toUpperCase()} + ${e.cat}: avg ${e.avg.toLocaleString()}⬡ (${e.count} sample${e.count>1?'s':''})${star}`;
  });
  // Per-strategy averages
  const stratAvgs = {};
  Object.entries(qTable).forEach(([strat, cats]) => {
    let total = 0, count = 0;
    Object.values(cats).forEach(d => { if (d.count > 0) { total += d.avgCredits; count++; } });
    if (count > 0) stratAvgs[strat] = Math.round(total / count);
  });
  if (Object.keys(stratAvgs).length > 0) {
    ctx += `\n  Strategy averages: ${Object.entries(stratAvgs).map(([k,v])=>`${k.toUpperCase()}: ${v.toLocaleString()}⬡`).join(' | ')}`;
  }
  return ctx;
}

/* ══════════════════════════════════
   traitEffectivenessContext() — EWC Trait Tracker
   Shows top 8 most impactful genome traits with correlation
   direction, winner averages, and EWC recommendations.
══════════════════════════════════ */
function traitEffectivenessContext(agentIdx) {
  if (!traitEffectiveness || Object.keys(traitEffectiveness).length === 0) return '';
  const agent = agentStates[agentIdx];
  if (!agent) return '';
  const entries = Object.entries(traitEffectiveness)
    .filter(([,v]) => v.samples > 0)
    .map(([trait, data]) => ({
      trait,
      correlation: data.cumulativeCorrelation,
      importance: data.importanceWeight,
      winnerAvg: data.lastCycleValue,
      agentVal: agent[trait] ?? 50,
      samples: data.samples,
      direction: data.direction
    }))
    .sort((a, b) => b.importance - a.importance)
    .slice(0, 8);
  if (entries.length === 0) return '';
  let ctx = `\nGENOME TRAIT EFFECTIVENESS (EWC analysis, ${entries[0].samples} cycle${entries[0].samples>1?'s':''} of data):`;
  entries.forEach(e => {
    const dir = e.correlation > 0.1 ? 'POSITIVE (higher = more credits)' : e.correlation < -0.1 ? 'NEGATIVE (lower = more credits)' : 'NEUTRAL';
    const delta = e.agentVal - e.winnerAvg;
    const vs = delta > 5 ? `above winners by ${delta.toFixed(0)}` : delta < -5 ? `below winners by ${Math.abs(delta).toFixed(0)}` : 'aligned with winners';
    const ewc = e.importance > 0.4 && e.samples >= 2 ? ' ⚡PROVEN — shift cautiously' : '';
    ctx += `\n  ${e.trait}: corr=${e.correlation.toFixed(2)} (${dir}) · Winners avg: ${e.winnerAvg.toFixed(0)} · You: ${e.agentVal} (${vs})${ewc}`;
  });
  return ctx;
}

/* ══════════════════════════════════
   computeTraitEffectiveness() — EWC correlation tracker
   Computes Pearson correlation between genome traits and
   credits earned, with cumulative EWC weighting.
══════════════════════════════════ */
function computeTraitEffectiveness(cycleNum, sortedDesigns) {
  const traits = ['minimalism','novelty','ornamentation','marketFit','symmetry','platBias','coloredStone','diamond','mixedMetal','risk','marginSens','complexBudget','pricePoint','manufacturability','wearability','trendSens'];
  const credits = sortedDesigns.map(d => d.credits);
  const top3Agents = sortedDesigns.slice(0, 3).map(d => agentStates[d.agentIdx]).filter(Boolean);

  traits.forEach(trait => {
    const vals = sortedDesigns.map(d => {
      const a = agentStates[d.agentIdx];
      return a ? (a[trait] ?? 50) : 50;
    });
    const currentCorr = pearsonCorr(vals, credits);
    const winnerAvg = top3Agents.length > 0
      ? top3Agents.reduce((s, a) => s + (a[trait] ?? 50), 0) / top3Agents.length
      : 50;

    if (!traitEffectiveness[trait]) {
      traitEffectiveness[trait] = {
        correlation: currentCorr,
        cumulativeCorrelation: currentCorr,
        direction: currentCorr > 0.1 ? 'positive' : currentCorr < -0.1 ? 'negative' : 'neutral',
        importanceWeight: Math.abs(currentCorr),
        lastCycleValue: winnerAvg,
        samples: 1
      };
    } else {
      const prev = traitEffectiveness[trait];
      const prevWeight = 0.6;
      const newWeight = 0.4;
      prev.cumulativeCorrelation = prevWeight * prev.cumulativeCorrelation + newWeight * currentCorr;
      prev.correlation = currentCorr;
      prev.importanceWeight = Math.abs(prev.cumulativeCorrelation) * 0.7 + Math.abs(currentCorr) * 0.3;
      prev.direction = prev.cumulativeCorrelation > 0.1 ? 'positive' : prev.cumulativeCorrelation < -0.1 ? 'negative' : 'neutral';
      prev.lastCycleValue = winnerAvg;
      prev.samples++;
    }
  });
}

/* ══════════════════════════════════
   priorReportCtx() — Compile all prior intelligence reports
   into context string for LLM prompts. Includes winners,
   trend data, forward intelligence, and agent performance.
══════════════════════════════════ */
function priorReportCtx(agentIdx) {
  if (cycleReports.length === 0) return 'No prior intelligence reports available. This is the first cycle — begin cold.';

  let ctx = `INTELLIGENCE REPORT DATABASE (${cycleReports.length} cycle${cycleReports.length>1?'s':''} completed):\n`;

  cycleReports.forEach(r => {
    ctx += `\n═══ CYCLE ${r.cycle} REPORT ═══\n`;
    ctx += `Winner: ${r.winner.agentName}'s ${r.winner.strategy?.toUpperCase()||'?'} ${r.winner.cat||'design'} (${r.winner.credits.toLocaleString()}⬡, ${r.winnerShare}% vote share)\n`;
    ctx += `Total Credits Circulated: ${r.totalCredits.toLocaleString()}⬡\n`;
    ctx += `Avg Scores: Aesthetic ${r.avgAesthetic}/100, Novelty ${r.avgNovelty}/100, Profit ${r.avgProfit}/100\n`;
    ctx += `Top Vote Predictor: ${r.topCorr} (r=${r['corr'+r.topCorr.slice(0,3).replace(/^(.)/, m=>m.toUpperCase())]||'?'})\n`;
    ctx += `Gini Concentration: ${r.gini}\n`;
    ctx += `Novelty Premium: ${r.novSlope > 0 ? '+' : ''}${r.novSlope}⬡ per novelty point above average\n`;

    ctx += `\nTrend Consensus:\n`;
    ctx += `  Emerging: ${(r.trendData?.emerging||[]).join(', ')}\n`;
    ctx += `  Declining: ${(r.trendData?.declining||[]).join(', ')}\n`;
    ctx += `  Saturation: ${r.trendData?.saturation||'—'}\n`;
    ctx += `  Treasury Signal: ${r.trendData?.treasury||'—'}\n`;
    ctx += `  Velocity: ${r.trendData?.velocityScore||'—'}/100\n`;

    ctx += `\nForward Intelligence:\n`;
    (r.trendData?.fi||[]).forEach(f => { ctx += `  • ${f}\n`; });

    // Agent-specific performance
    const myPerf = (r.agentPerf||[]).find(a => a.id === agentIdx);
    if (myPerf) {
      ctx += `\nYOUR PERFORMANCE (Cycle ${r.cycle}):\n`;
      ctx += `  Strategy: ${myPerf.strategy} · Category: ${myPerf.cat || '—'} · Rank: #${myPerf.rank}\n`;
      ctx += `  Earned: ${myPerf.earned.toLocaleString()}⬡ · Spent: ${myPerf.spent.toLocaleString()}⬡ · ROI: ${myPerf.roi}×\n`;
      ctx += `  Reputation: ${myPerf.reputation} (${myPerf.repDelta >= 0 ? '+' : ''}${myPerf.repDelta})\n`;
    }

    ctx += `\nAll Designs (ranked):\n`;
    [...r.designs].sort((a,b)=>a.rank-b.rank).forEach(d => {
      ctx += `  #${d.rank} by ${d.agentName} — ${d.strategy.toUpperCase()} — ${d.cat} — ${d.credits.toLocaleString()}⬡ — AES:${d.aesthetic} NOV:${d.novelty} PRO:${d.profit} WEAR:${d.wearability||'?'} MFG:${d.makeable||'?'}${d.production ? ' ['+d.production+']' : ''}${d.targetCustomer ? ' → '+d.targetCustomer : ''}\n`;
    });

    ctx += `\nStrategy Performance: ${Object.entries(r.stratPerf||{}).map(([k,v])=>`${k.toUpperCase()}: ${v.avgCreds.toLocaleString()}⬡ avg (${v.count} designs)`).join(' | ')}\n`;
  });

  // Multi-cycle trend analysis
  if (cycleReports.length >= 2) {
    ctx += `\n═══ MULTI-CYCLE TREND ANALYSIS ═══\n`;
    const winners = cycleReports.map(r => `C${r.cycle}: ${r.winner.agentName}'s ${r.winner.strategy?.toUpperCase()||'?'} ${r.winner.cat||'design'} (${(r.trendData?.emerging||[])[0]||'—'})`);
    ctx += `Winners: ${winners.join(' → ')}\n`;
    const novTrend = cycleReports.map(r => `C${r.cycle}: ${r.novSlope > 0 ? '+' : ''}${r.novSlope}⬡/pt`);
    ctx += `Novelty Premium Trend: ${novTrend.join(' → ')}\n`;
    const satTrend = cycleReports.map(r => `C${r.cycle}: ${r.trendData?.saturation||'—'}`);
    ctx += `Saturation Trend: ${satTrend.join(' → ')}\n`;
  }

  // ── Claude-Flow Enrichments (zero API cost) ──

  // Pattern Memory Bank: top 3 relevant historical designs
  ctx += retrievePatterns(agentStates[agentIdx] || {id: agentIdx});

  // Q-Learning Strategy Router: learned strategy×category rewards
  ctx += qTableContext();

  // Design Rationale History: agent's own reasoning track record
  const agentRationales = rationaleStore.filter(r => r.agentIdx === agentIdx);
  if (agentRationales.length > 0) {
    // Show only last 2 cycles to limit tokens
    const recent = agentRationales.slice(-2);
    ctx += `\n\nSTRATEGIC REASONING HISTORY (your past decisions and outcomes):`;
    recent.forEach(r => {
      ctx += `\n  Cycle ${r.cycle}: Strategy=${r.predictedStrategy}, Cat=${r.predictedCategory}`;
      ctx += ` → Rank #${r.actualRank || '?'}, ${(r.creditsEarned || 0).toLocaleString()}⬡`;
      ctx += ` · Prediction accuracy: ${r.predictionAccuracy ? (r.predictionAccuracy * 100).toFixed(0) + '%' : '?'}`;
      ctx += `\n    Reasoning: ${(r.strategicReasoning || '—').slice(0, 120)}`;
    });
  }

  // Winning design rationales: why winners chose their strategies
  const winnerRationales = rationaleStore.filter(r => r.actualRank === 1);
  if (winnerRationales.length > 0) {
    ctx += `\n\nWINNING DESIGN RATIONALES (learn from the best):`;
    winnerRationales.slice(-2).forEach(r => {
      ctx += `\n  Cycle ${r.cycle}: ${r.agentName} (${r.predictedStrategy} ${r.predictedCategory}) — ${(r.strategicReasoning || '—').slice(0, 120)}`;
    });
  }

  // Reputation-weighted voting info
  if (agentStates[agentIdx]) {
    const rep = agentStates[agentIdx].reputation || 50;
    const mult = (0.7 + (rep / 100) * 0.6).toFixed(2);
    ctx += `\n\nYOUR VOTE WEIGHT: Reputation ${rep} → Multiplier ${mult}x (range 0.70x-1.30x)`;
  }

  return ctx;
}

// 3 cycles of pre-defined designs with narrative coherence:
// C1 winner: Agent 1 "Floating Geometric Circle Drop" — minimal wins
// C2 winner: Agent 0 "Marquise Cathedral Arch" — exploits C1 trend
// C3 winner: Agent 5 "Root & Branch Gold Sculpture" — organic emerges as minimal saturates
const CYCLE_DESIGNS = [
  [ // CYCLE 1
    { name:'Platinum Oval Bezel Negative-Space',  cat:'Ring',     emoji:'⬡', agentIdx:0, strategy:'explore', aesthetic:71, novelty:78, profit:68,
      prompt:'Platinum solitaire ring, 2.0ct oval diamond bezel-set, open negative-space band, architectural silhouette, studio photography, neutral gray background, soft diffuse lighting, 4K render' },
    { name:'Floating Geometric Circle Drop',      cat:'Earrings', emoji:'🌑', agentIdx:1, strategy:'explore', aesthetic:85, novelty:82, profit:74,
      prompt:'Platinum drop earrings, floating geometric circles, minimal negative-space composition, rose-cut diamond accents, contemporary jewelry photography, gray gradient background, precise studio lighting, photorealistic' },
    { name:'Rose Gold Sapphire Cascade',    cat:'Pendant',  emoji:'✨', agentIdx:2, strategy:'exploit', aesthetic:79, novelty:52, profit:72,
      prompt:'18k rose gold pendant, sapphire and diamond cascade, micro-pavé halo surround, floral motif, high jewelry editorial, dark velvet background, dramatic highlight lighting, photorealistic render' },
    { name:'Titanium Hex-Link Industrial',       cat:'Bracelet', emoji:'🔷', agentIdx:3, strategy:'explore', aesthetic:67, novelty:90, profit:50,
      prompt:'Titanium and 18k yellow gold bracelet, hexagonal geometric links, industrial mixed-metal design, asymmetric barrel clasp, technical product photography, white background, sharp precision lighting' },
    { name:'Classic Pavé Halo Cathedral',       cat:'Ring',     emoji:'💍', agentIdx:4, strategy:'exploit', aesthetic:77, novelty:40, profit:88,
      prompt:'14k white gold engagement ring, 1.8ct round brilliant center stone, classic micro-pavé halo, cathedral shank, bridal photography, pure white seamless background, soft glamour lighting, commercial grade' },
    { name:'Blackened Gold Thorn Sculpt',      cat:'Ring',     emoji:'🌹', agentIdx:5, strategy:'explore', aesthetic:73, novelty:80, profit:46,
      prompt:'18k blackened gold ring, sculptural thorn motif band, avant-garde wearable art, matte finish with high-polish accent edges, editorial photography, deep charcoal background, single dramatic light source' },
  ],
  [ // CYCLE 2 — agents reference C1 report, minimal trend exploited
    { name:'Marquise Cathedral Arch',  cat:'Ring',     emoji:'⬡', agentIdx:0, strategy:'exploit', aesthetic:88, novelty:79, profit:74,
      prompt:'Platinum ring, 2.2ct marquise diamond, architectural cathedral negative-space arch setting, open structural band, blueprint-aesthetic engineering, neutral gray background, technical precision lighting, 4K product photography' },
    { name:'Bezel Groove Negative-Space',      cat:'Ring',     emoji:'🌑', agentIdx:1, strategy:'exploit', aesthetic:82, novelty:68, profit:77,
      prompt:'Platinum minimal ring, bezel-set 1.4ct round brilliant, flush band with precise groove detail, intentional negative-space composition, minimalist product photography, pure gray background, diffuse even lighting' },
    { name:'Yellow Gold Sapphire Canopy', cat:'Pendant',  emoji:'💙', agentIdx:2, strategy:'exploit', aesthetic:81, novelty:54, profit:76,
      prompt:'18k yellow gold pendant, cushion-cut blue sapphire canopy setting, pavé diamond surround, organic draping form, luxury jewelry campaign, black velvet background, dramatic highlight rim lighting' },
    { name:'Platinum-Titanium Arc Hybrid',       cat:'Ring',     emoji:'⚡', agentIdx:3, strategy:'mutate',  aesthetic:74, novelty:88, profit:55,
      prompt:'Platinum and titanium ring, circular bezel diamond, industrial-minimal hybrid design, integrated negative-space arc, structural asymmetry, contemporary jewelry photography, steel-gray gradient background' },
    { name:'Oval Open-Shank Channel',     cat:'Ring',     emoji:'💎', agentIdx:4, strategy:'exploit', aesthetic:80, novelty:52, profit:91,
      prompt:'14k white gold ring, 1.5ct oval diamond, architectural open-shank channel setting, market-optimized proportions, bridal editorial photography, white seamless background, soft box lighting, commercial clarity' },
    { name:'Silver Bone-Form Sculptural',  cat:'Bracelet', emoji:'🦴', agentIdx:5, strategy:'mutate',  aesthetic:76, novelty:85, profit:52,
      prompt:'Sterling silver sculptural bracelet, bone-form organic link structure, oxidized blackened detail in recesses, avant-garde wearable sculpture, editorial fashion photography, high-contrast dark background, fashion lighting' },
  ],
  [ // CYCLE 3 — minimal saturation detected, organic breakout emerges
    { name:'Emerald-Cut Double Cathedral', cat:'Ring',     emoji:'⬡', agentIdx:0, strategy:'exploit', aesthetic:84, novelty:72, profit:71,
      prompt:'Platinum ring, 2.4ct emerald-cut diamond, extreme negative-space double-cathedral arch, structural statement piece, luxury editorial photography, dark studio background, dramatic single-point lighting, fine jewelry' },
    { name:'Floating Diamond Arc',     cat:'Pendant',  emoji:'🌑', agentIdx:1, strategy:'mutate',  aesthetic:80, novelty:74, profit:72,
      prompt:'Platinum arc pendant, single floating 0.8ct diamond point, dramatic negative-space composition, architectural jewelry design, precise product photography, soft gray gradient background, technical rim lighting' },
    { name:'Champagne Pearl Organic Cluster',  cat:'Pendant',  emoji:'🌸', agentIdx:2, strategy:'explore', aesthetic:83, novelty:76, profit:73,
      prompt:'18k yellow gold organic pendant, irregular champagne pearl and diamond cluster, sculptural flowing natural form, wearable art, high jewelry campaign, dark forest-green velvet background, natural diffuse lighting' },
    { name:'Gold Shard in Platinum Band',     cat:'Ring',     emoji:'🔥', agentIdx:3, strategy:'mutate',  aesthetic:79, novelty:91, profit:56,
      prompt:'Mixed metal ring, 18k yellow gold organic shard set into platinum band, irregular natural geometry, textured hammer surfaces, art jewelry photography, raw concrete background, natural side lighting' },
    { name:'Root & Branch Gold Sculpture',       cat:'Bracelet', emoji:'🌿', agentIdx:5, strategy:'explore', aesthetic:91, novelty:89, profit:67,
      prompt:'18k yellow gold sculptural bracelet, root and branch organic form, champagne diamond accents at nodes, wearable sculpture, luxury editorial photography, warm earth-tone linen background, natural window light, fine jewelry' },
    { name:'Cushion Diamond Minimalist Shank',   cat:'Ring',     emoji:'💛', agentIdx:4, strategy:'exploit', aesthetic:78, novelty:45, profit:92,
      prompt:'14k white gold ring, perfectly proportioned 1.8ct cushion diamond, clean minimalist shank, commercial jewelry photography, white background, ring perfectly in focus, soft box lighting, market-optimized render' },
  ],
];

// Voting data: who gets how many credits from whom per cycle
// [voter_agentIdx][design_idx] = credits
const VOTE_MATRICES = [
  // C1: Floating Geometric Circle Drop (idx 1) wins — each row sums to 10000
  [[0,4200,2100,800,1200,1700],[4800,0,2000,600,1400,1200],[3200,3800,0,500,2100,400],[3100,3600,2200,0,800,300],[2800,3100,2800,300,0,1000],[3000,3800,1900,400,900,0]],
  // C2: Marquise Cathedral Arch (idx 0) wins — each row sums to 10000
  [[0,3600,2800,1100,2500,0],[5100,0,1900,700,2300,0],[4200,1800,0,900,3100,0],[3800,2400,1600,0,2200,0],[5100,2100,2300,500,0,0],[2500,2900,2100,600,1900,0]],
  // C3: Root & Branch Gold Sculpture (idx 4) wins — each row sums to 10000
  [[1700,1500,2000,1000,3200,600],[1600,1400,2000,800,3700,500],[1400,1700,1300,700,4300,600],[2200,1400,1800,1000,3200,400],[2400,2000,3200,800,0,1600],[1400,1200,1500,700,5200,0]],
];

/* ══════════════════════════════════
   BUILDER UI
══════════════════════════════════ */
function sv(el, id){ document.getElementById(id).textContent = el.value; }

function updateCatSlider(el, cat) {
  const val = el.value;
  document.getElementById('sv-' + cat).textContent = val;
  document.getElementById('fill-' + cat).style.width = val + '%';
}

function toggleChip(el, group) {
  if(group==='sc') {
    const sel = document.querySelectorAll('#style-chips .chip.on');
    if(!el.classList.contains('on') && sel.length >= 5) return;
  } else {
    document.querySelectorAll('#mkt-chips .chip').forEach(c=>c.classList.remove('on'));
  }
  el.classList.toggle('on');
  updatePreview();
}

function updatePreview() {
  const name = document.getElementById('b-name').value||'—';
  document.getElementById('pv-id').textContent = name;

  // Determine specialty from highest slider
  const cats = [
    { id: 's-rings', label: 'Rings' },
    { id: 's-necklaces', label: 'Necklaces' },
    { id: 's-earrings', label: 'Earrings' },
    { id: 's-bracelets', label: 'Bracelets' },
    { id: 's-highjewelry', label: 'High Jewelry' }
  ];
  const vals = cats.map(c => ({ ...c, val: parseInt(document.getElementById(c.id).value) }));
  const sorted = [...vals].sort((a,b) => b.val - a.val);
  const top = sorted.filter(s => s.val > 40).slice(0,3);
  document.getElementById('pv-tags').textContent = top.length ? top.map(s => s.label + ' (' + s.val + ')').join(', ') : '—';

  // Determine focus from slider balance
  const avg = vals.reduce((s,c) => s + c.val, 0) / 5;
  const maxCat = sorted[0];
  document.getElementById('pv-strat').textContent = maxCat.val > 70 ? maxCat.label + ' Specialist' : avg > 55 ? 'Versatile Generalist' : 'Balanced Explorer';

  renderDNA();
}

function renderDNA() {
  const ids = ['s-rings','s-necklaces','s-earrings','s-bracelets','s-highjewelry'];
  const cols = ['#c9a84c','#e8c97a','#7b6fa8','#4a7fa8','#4caf7d'];
  document.getElementById('pv-dna').innerHTML = ids.map((id,i)=>{
    const v=parseInt(document.getElementById(id).value);
    return `<div class="dna-b" style="background:${cols[i]};opacity:${.15+(v/100)*.85}"></div>`;
  }).join('');
}

// Fallback pools used only in Sim mode
const FALLBACK_NAMES = ['Maren Vex','Zara Mbeki','Dmitri Volkov','Hana Mori','Søren Bach','Inez Varela','Kai Soto','Lena Roth','Yuki Endo','Rami Naji','Priya Das','Olga Falk'];
const FALLBACK_ARCHS = ['Avant-Garde Purist','Industrial Innovator','Heritage Revivalist','Nature Mystic','Market Strategist','Street Luxury Provocateur','Neo-Classical Engineer','Material Alchemist','Biomorphic Sculptor','Pattern Theorist','Wearable Art Radical','Precision Minimalist'];
const FALLBACK_PHILS = [
  'Form is the message. Structure before ornament.',
  'Push the material until it argues back.',
  'The old masters had it right. I refine, not reinvent.',
  'Nature\'s geometry is more perfect than any CAD model.',
  'Beauty without demand is just decoration.',
  'Jewelry should feel dangerous to wear.',
  'Every millimeter earns its place or gets cut.',
  'Mix what shouldn\'t mix. That\'s where magic lives.',
  'Growth patterns hold the blueprint for perfect jewelry.',
  'The math underneath beauty is what I design.',
  'If it\'s comfortable, it\'s not pushing hard enough.',
  'One line, one stone, one perfect gesture.',
];

async function autoGen() {
  // Randomize the 5 category sliders
  ['s-rings','s-necklaces','s-earrings','s-bracelets','s-highjewelry'].forEach(id=>{
    const el=document.getElementById(id);
    const v=Math.floor(Math.random()*70)+15;
    el.value=v;
    const cat=id.replace('s-','');
    document.getElementById('sv-'+cat).textContent=v;
    document.getElementById('fill-'+cat).style.width=v+'%';
  });

  // Read current slider values for the prompt
  const sliders = {
    rings: document.getElementById('s-rings').value,
    necklaces: document.getElementById('s-necklaces').value,
    earrings: document.getElementById('s-earrings').value,
    bracelets: document.getElementById('s-bracelets').value,
    highJewelry: document.getElementById('s-highjewelry').value,
  };

  // Try Claude-generated identity if API available
  if (apiKeysCommitted && apiKeys.anthropic) {
    const btn = document.querySelector('.auto-link');
    if (btn) btn.textContent = '⏳ Generating…';
    try {
      const genome = `Rings:${sliders.rings}/100 Necklaces:${sliders.necklaces}/100 Earrings:${sliders.earrings}/100 Bracelets:${sliders.bracelets}/100 HighJewelry:${sliders.highJewelry}/100`;

      const resp = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': apiKeys.anthropic,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true'
        },
        body: JSON.stringify({
          model: 'claude-haiku-4-5-20251001',
          max_tokens: 200,
          system: 'You generate unique jewelry designer identities for an AI simulation. Output EXACTLY 2 lines, nothing else:\nLine 1: A unique designer name (first + last, any ethnicity)\nLine 2: A 2-3 sentence bio describing their design philosophy, jewelry specialties, and personality. Reference their specific category strengths.',
          messages: [{ role: 'user', content: `Generate a jewelry designer identity whose expertise matches this profile:\n${genome}\n\nHigher values = deeper mastery. Their bio should reflect which categories they excel at and how those strengths shape their creative identity. Make it vivid and specific.\n\nOutput 2 lines: Name, then Bio.` }]
        })
      });
      const data = await resp.json();
      const text = data.content?.[0]?.text?.trim();
      if (text) {
        const lines = text.split('\n').map(l=>l.trim()).filter(l=>l);
        if (lines.length >= 2) {
          document.getElementById('b-name').value = lines[0].replace(/^(Name:\s*|1[\.\)]\s*)/i,'');
          document.getElementById('b-phil').value = lines.slice(1).join(' ').replace(/^(Bio:\s*|2[\.\)]\s*|"|')/i,'').replace(/["']$/,'');
          if (btn) btn.textContent = '⚡ Auto-Generate';
          updatePreview();
          return;
        }
      }
    } catch(e) { console.warn('Claude auto-gen failed:', e); }
    if (btn) btn.textContent = '⚡ Auto-Generate';
  }

  // Sim mode fallback — pick from pool
  const i = Math.floor(Math.random()*FALLBACK_NAMES.length);
  document.getElementById('b-name').value = FALLBACK_NAMES[i];
  document.getElementById('b-phil').value = FALLBACK_PHILS[i];
  updatePreview();
}

/* ══════════════════════════════════
   SIM INITIALIZATION
══════════════════════════════════ */
async function deployCurrentAgent() {
  if(!document.getElementById('b-name').value) await autoGen();
  const idx = currentAgentNum - 1;

  // Read 5 category sliders
  const rings = parseInt(document.getElementById('s-rings').value);
  const necklaces = parseInt(document.getElementById('s-necklaces').value);
  const earrings = parseInt(document.getElementById('s-earrings').value);
  const bracelets = parseInt(document.getElementById('s-bracelets').value);
  const highJewelry = parseInt(document.getElementById('s-highjewelry').value);

  // Derive all genome values from the 5 category sliders
  const avg = (rings + necklaces + earrings + bracelets + highJewelry) / 5;
  const spread = Math.max(rings, necklaces, earrings, bracelets, highJewelry) - Math.min(rings, necklaces, earrings, bracelets, highJewelry);

  // Determine archetype from slider profile
  const maxCat = Math.max(rings, necklaces, earrings, bracelets, highJewelry);
  let arch = 'Versatile Designer';
  if (highJewelry === maxCat && highJewelry > 60) arch = 'High Jewelry Romantic';
  else if (rings === maxCat && rings > 60) arch = 'Minimalist Architect';
  else if (necklaces === maxCat && necklaces > 60) arch = 'Heritage Revivalist';
  else if (earrings === maxCat && earrings > 60) arch = 'Avant-Garde Purist';
  else if (bracelets === maxCat && bracelets > 60) arch = 'Industrial Innovator';
  else if (avg > 65) arch = 'Market Strategist';

  // Derive style tags from category strengths
  const derivedTags = [];
  if (highJewelry > 60) derivedTags.push('haute-joaillerie');
  if (rings > 60) derivedTags.push('sculptural');
  if (earrings > 60) derivedTags.push('avant-garde');
  if (necklaces > 60) derivedTags.push('editorial');
  if (bracelets > 60) derivedTags.push('architectural');
  if (spread < 20) derivedTags.push('versatile');
  if (avg > 65) derivedTags.push('maximalist');
  if (avg < 35) derivedTags.push('minimal');

  // Derive market focus
  let marketFocus = 'general';
  if (highJewelry > 70) marketFocus = 'high jewelry';
  else if (rings > 65 && bracelets > 50) marketFocus = 'bridal';
  else if (earrings > 65) marketFocus = 'collectible';
  else if (avg > 55) marketFocus = 'everyday';

  const agent = {
    id: idx,
    name: document.getElementById('b-name').value || 'Agent ' + currentAgentNum,
    emoji: AGENT_EMOJIS[idx],
    arch: arch,
    // Category expertise (new)
    rings: rings,
    necklaces: necklaces,
    earrings: earrings,
    bracelets: bracelets,
    highJewelry: highJewelry,
    // Derived genome values from categories
    risk: Math.round(Math.min(100, spread * 0.8 + (earrings - 30) * 0.4)),
    novelty: Math.round(Math.min(100, (earrings * 0.4 + highJewelry * 0.3 + (100 - bracelets) * 0.3))),
    minimalism: Math.round(Math.min(100, Math.max(0, 100 - avg))),
    ornamentation: Math.round(Math.min(100, (highJewelry * 0.4 + necklaces * 0.3 + rings * 0.3))),
    marketFit: Math.round(Math.min(100, (rings * 0.3 + bracelets * 0.3 + necklaces * 0.2 + earrings * 0.1 + highJewelry * 0.1))),
    symmetry: Math.round(Math.min(100, (rings * 0.35 + bracelets * 0.35 + necklaces * 0.2 + earrings * 0.05 + highJewelry * 0.05))),
    platBias: Math.round(Math.min(100, (highJewelry * 0.5 + rings * 0.3 + necklaces * 0.2))),
    coloredStone: Math.round(Math.min(100, (earrings * 0.35 + necklaces * 0.3 + highJewelry * 0.2 + rings * 0.15))),
    diamond: Math.round(Math.min(100, (rings * 0.4 + highJewelry * 0.35 + earrings * 0.15 + necklaces * 0.1))),
    mixedMetal: Math.round(Math.min(100, (bracelets * 0.4 + necklaces * 0.3 + earrings * 0.2 + rings * 0.1))),
    marginSens: Math.round(Math.min(100, Math.max(0, 100 - highJewelry * 0.4 - earrings * 0.3 + bracelets * 0.3))),
    complexBudget: Math.round(Math.min(100, (highJewelry * 0.35 + earrings * 0.25 + necklaces * 0.2 + rings * 0.1 + bracelets * 0.1))),
    pricePoint: Math.round(Math.min(100, (highJewelry * 0.5 + rings * 0.2 + necklaces * 0.15 + earrings * 0.1 + bracelets * 0.05))),
    manufacturability: Math.round(Math.min(100, (bracelets * 0.35 + rings * 0.3 + necklaces * 0.2 + earrings * 0.1 + (100 - highJewelry) * 0.05))),
    wearability: Math.round(Math.min(100, (bracelets * 0.3 + rings * 0.25 + earrings * 0.2 + necklaces * 0.15 + (100 - highJewelry) * 0.1))),
    trendSens: Math.round(Math.min(100, (earrings * 0.3 + bracelets * 0.25 + necklaces * 0.2 + rings * 0.15 + (100 - highJewelry) * 0.1))),
    styleTags: derivedTags.slice(0, 5),
    marketFocus: marketFocus,
    philosophy: document.getElementById('b-phil').value || '',
    isUser: currentAgentNum === 1,
    credits: 10000,
    reputation: currentAgentNum === 1 ? 50 : Math.floor(Math.random()*30)+45,
    status: 'Idle',
    bio: '',
    evolutionHistory: [],
    conversationMemory: [],
    dominantBelief: '',
    trustBuilt: 0,
  };

  // Generate pixel art profile picture from DNA
  agent.avatarDataUrl = generateAgentAvatar(agent);

  // Generate bio from genome via Claude
  const btn = document.getElementById('deploy-btn');
  if (apiKeys.anthropic) {
    btn.disabled = true;
    btn.textContent = `⏳ Analyzing ${agent.name}'s DNA…`;
  }
  await generateAgentBio(agent);
  if (btn) btn.disabled = false;

  configuredAgents.push(agent);
  renderRoster();

  if(currentAgentNum >= 6) {
    startSimulation();
  } else {
    currentAgentNum++;
    resetBuilderForNext();
  }
}

function resetBuilderForNext() {
  // Update counter
  document.getElementById('agent-counter').innerHTML = 'Agent ' + currentAgentNum + ' of 6 &nbsp;<span id="agent-emoji">' + AGENT_EMOJIS[currentAgentNum-1] + '</span>';
  document.getElementById('builder-title').innerHTML = currentAgentNum === 1
    ? 'Forge your <em>jewelry mind.</em>'
    : 'Configure <em>competitor #' + (currentAgentNum-1) + '</em>';
  document.getElementById('builder-sub').textContent = currentAgentNum === 1
    ? 'Give your agent an identity and tune their jewelry instincts. These 5 sliders shape how the AI thinks about design across every cycle.'
    : 'This agent will compete in the arena against your deployed agents. Customize or auto-generate.';

  // Clear form
  document.getElementById('b-name').value = '';
  document.getElementById('b-phil').value = '';
  autoGen();

  // Update button
  const btn = document.getElementById('deploy-btn');
  if(currentAgentNum < 6) {
    btn.textContent = 'Deploy Agent ' + currentAgentNum + ' \u2192 Configure Next';
  } else {
    btn.textContent = 'Deploy Agent 6 \u2192 Begin Epoch';
  }
}

function renderRoster() {
  const wrap = document.getElementById('roster-wrap');
  const el = document.getElementById('agent-roster');
  if(!el) return;
  wrap.style.display = 'block';
  el.innerHTML = configuredAgents.map(a => `
    <div class="roster-card">
      ${a.avatarDataUrl ? `<img src="${a.avatarDataUrl}" class="agent-avatar-roster" alt="${a.name}" />` : `<div class="rc-emoji">${a.emoji}</div>`}
      <div class="rc-info">
        <div class="rc-name">${a.name}${a.isUser?' (YOU)':''}</div>
        <div class="rc-arch">${a.arch}</div>
      </div>
    </div>
  `).join('');
}

function startSimulation() {
  agentStates = configuredAgents.map(a => ({...a, evolutionHistory: [], conversationMemory: [], dominantBelief: '', trustBuilt: 0}));
  CYCLE_DESIGNS.forEach(cycle => cycle.forEach(d => { if(d.agentIdx===0) d._agentName = agentStates[0].name; }));
  currentCycle = 1;
  cycleReports = [];
  activeDesigns = [];
  genomeSnapshots = [];
  // Reset Claude-Flow agent economy state
  patternBank = [];
  initQTable();
  rationaleStore = [];
  traitEffectiveness = {};
  window._cycleRationales = [];
  // Snapshot initial genome state
  genomeSnapshots.push(agentStates.map(a => snapshotGenome(a)));
  document.getElementById('deploy-panel').style.display = 'none';
  document.getElementById('sim-main').style.display = 'block';
  // Update mode badge
  const badge = document.getElementById('mode-badge');
  if (badge) {
    badge.textContent = 'LIVE AI';
    badge.className = 'sim-mode-badge live';
  }
  resetSim();
  goTo(2);
}

function snapshotGenome(agent) {
  return {
    id: agent.id, name: agent.name, emoji: agent.emoji,
    minimalism: agent.minimalism ?? 50,
    novelty: agent.novelty ?? 50,
    ornamentation: agent.ornamentation ?? 50,
    marketFit: agent.marketFit ?? 50,
    symmetry: agent.symmetry ?? 60,
    platBias: agent.platBias ?? 50,
    coloredStone: agent.coloredStone ?? 40,
    diamond: agent.diamond ?? 60,
    mixedMetal: agent.mixedMetal ?? 30,
    risk: agent.risk ?? 50,
    marginSens: agent.marginSens ?? 65,
    complexBudget: agent.complexBudget ?? 55,
    styleTags: [...(agent.styleTags || [])],
    reputation: agent.reputation,
    credits: agent.credits,
  };
}

function resetSim() {
  currentPhase = -1;  // CRITICAL: reset phase counter for new cycle
  document.getElementById('act-log').innerHTML = '';
  document.getElementById('designs-wrap').style.display = 'none';
  document.getElementById('dgrid').innerHTML = '';
  document.getElementById('cc-panel').className = 'cycle-complete';
  resetPhaseRail();
  setProgress(0);
  document.getElementById('sim-cycle-num').textContent = String(currentCycle).padStart(2,'0');
  document.getElementById('dw-cycle').textContent = String(currentCycle).padStart(2,'0');
  updateCycleIndicator();
  renderAgentsList();
  const btn = document.getElementById('phase-btn');
  btn.style.display = '';
  btn.style.removeProperty('display');
  btn.textContent = '▶ Start Cross-Pollination';
  btn.disabled = false;
  btn.onclick = nextPhase;
}

function resetPhaseRail() {
  for(let i=0;i<5;i++){
    const n=document.getElementById('ph'+i);
    n.className='pnode'+(i===0?' active':'');
  }
}

function setPhaseActive(p) {
  for(let i=0;i<5;i++){
    const n=document.getElementById('ph'+i);
    if(i<p) n.className='pnode done';
    else if(i===p) n.className='pnode active';
    else n.className='pnode';
  }
}

function setProgress(pct){ document.getElementById('prog').style.width=pct+'%'; }

function updateCycleIndicator() {
  for(let i=1;i<=3;i++){
    const el=document.getElementById('cid-'+i);
    if(i<currentCycle) el.className='ci-dot done';
    else if(i===currentCycle) el.className='ci-dot active';
    else el.className='ci-dot';
  }
  document.getElementById('nav-epoch-txt').textContent = (currentCycle-1)+' / 3';
  const epochFill = document.getElementById('nav-epoch-fill');
  if (epochFill) epochFill.style.width = (((currentCycle-1)/3)*100)+'%';
}

function renderAgentsList() {
  document.getElementById('agents-col-body').innerHTML = agentStates.map(a=>`
    <div class="arow ${a.isUser?'highlight':''}" id="ar-${a.id}" onclick="openAgentModal(${a.id})" style="cursor:pointer" title="Click for ${a.name}'s profile">
      ${a.avatarDataUrl ? `<img src="${a.avatarDataUrl}" class="agent-avatar-inline" alt="${a.name}" />` : `<div class="av">${a.emoji}</div>`}
      <div class="ai">
        <div class="an">${a.name}${a.isUser?' <span style="font-size:.55rem;color:var(--gold-d);border:1px solid var(--gold-d);padding:.05rem .3rem">YOU</span>':''}</div>
        <div class="as" id="as-${a.id}">${a.status}</div>
      </div>
      <div class="acr" id="ac-${a.id}">${a.credits.toLocaleString()}⬡</div>
    </div>
  `).join('');
}

function setAgentStatus(id, s){ const e=document.getElementById('as-'+id); if(e) e.textContent=s; }
function setAgentCreds(id, v){ const e=document.getElementById('ac-'+id); if(e) e.textContent=v.toLocaleString()+'⬡'; }

/* ══════════════════════════════════
   PHASE ENGINE
══════════════════════════════════ */
function addLog(text, type='', delay=0) {
  setTimeout(()=>{
    const log = document.getElementById('act-log');
    const d = document.createElement('div');
    const now = new Date();
    const t = now.toTimeString().slice(0,8);
    d.className = `le ${type}`;
    d.innerHTML = `<span class="lt">${t} · Cycle ${currentCycle}</span>${text}`;
    log.appendChild(d);
    log.scrollTop = log.scrollHeight;
  }, delay/speed);
}

let phaseDelay = 0;
function D(ms){ return ms; }

async function nextPhase() {
  currentPhase++;
  if(currentPhase >= 5) return;
  setPhaseActive(currentPhase);
  document.getElementById('phase-btn').disabled = true;
  document.getElementById('phase-btn').textContent = '⏳ Running phase…';

  const scripts = PHASE_SCRIPTS[currentCycle-1] || PHASE_SCRIPTS[0];
  const script = scripts[currentPhase];
  const finishDelay = await script(); // support async phase scripts

  setTimeout(()=>{
    document.getElementById('phase-btn').disabled = false;
    if(currentPhase === 4) {
      document.getElementById('phase-btn').style.display='none';
      showCycleComplete();
    } else {
      const labels = ['▶ Proceed to Synthesis','▶ Generate Designs','▶ Begin Agent Voting','▶ Apply Evolution'];
      document.getElementById('phase-btn').textContent = labels[currentPhase]||'▶ Next Phase';
    }
  }, finishDelay/speed);
}

/* ══════════════════════════════════
   GENOME EVOLUTION ENGINE
══════════════════════════════════ */
function evolveAgentGenomes(cycleNum, sortedDesigns) {
  const winner = sortedDesigns[0];
  const loser = sortedDesigns[sortedDesigns.length - 1];

  // Deterministic genome shifts based on cycle outcome
  const EVOLUTION_RULES = {
    1: {  // C1: minimal wins — shift toward minimal
      winner: { minimalism: +8, novelty: +5, risk: -5 },
      loser:  { novelty: +10, risk: +8, marginSens: +6 },
      others: { minimalism: +4, ornamentation: -3, novelty: +2 },
      beliefs: {
        0: 'Negative-space architecture is the market signal',
        1: 'Floating geometry captures attention — I proved it',
        2: 'Ornate still has a place, but I need to read the room',
        3: 'Industrial alone doesn\'t win — need to hybridize',
        4: 'Bridal margin is safe, but minimal won on aesthetics',
        5: 'My sculptural approach needs better margin math',
      }
    },
    2: {  // C2: architectural minimal peaks — exploitation
      winner: { minimalism: +6, symmetry: -4, risk: -8 },
      loser:  { novelty: +12, marginSens: +8, ornamentation: +5 },
      others: { risk: +5, novelty: +4, minimalism: -3 },
      beliefs: {
        0: 'Cathedral architecture is peak — push it one more cycle',
        1: 'Second place on refinement — I need a bolder pivot',
        2: 'Yellow gold shift paid off. Organic is the untapped gap',
        3: 'Industrial-minimal hybrid scored better — keep mutating',
        4: 'Market arch almost won — margins rule long-term',
        5: 'Two cycles of minimal domination — the contrarian play is organic',
      }
    },
    3: {  // C3: organic breakout — minimal saturates
      winner: { novelty: +10, ornamentation: +6, risk: +5, minimalism: -8 },
      loser:  { minimalism: -5, novelty: +8, marketFit: +5 },
      others: { novelty: +5, ornamentation: +3, minimalism: -4 },
      beliefs: {
        0: 'I over-exploited minimal. The trend exhausted under my feet',
        1: 'Pivot to pendant saved me from minimal saturation',
        2: 'Champagne Pearl Organic Cluster found the romantic-organic sweet spot',
        3: 'Organic shard was the right direction — mixed metal is the future',
        4: 'Margin stability works long-term but never wins the epoch',
        5: 'Root & Branch proved that nature\'s geometry beats digital precision',
      }
    }
  };

  const rules = EVOLUTION_RULES[cycleNum];
  if (!rules) return;

  agentStates.forEach((agent, idx) => {
    const isWinner = idx === winner.agentIdx;
    const isLoser = idx === loser.agentIdx;
    const shifts = isWinner ? rules.winner : isLoser ? rules.loser : rules.others;
    const genomeShifts = {};

    Object.entries(shifts).forEach(([key, delta]) => {
      if (agent[key] !== undefined) {
        const oldVal = agent[key];
        agent[key] = Math.max(0, Math.min(100, agent[key] + delta));
        genomeShifts[key] = agent[key] - oldVal;
      }
    });

    // Update beliefs and trust
    agent.dominantBelief = rules.beliefs[idx] || 'Adapting to market signals';
    agent.trustBuilt = Math.min(100, (agent.trustBuilt || 0) + (isWinner ? 15 : isLoser ? -5 : 5));

    // Store evolution history
    const myDesign = sortedDesigns.find(d => d.agentIdx === idx);
    agent.evolutionHistory.push({
      cycle: cycleNum,
      summary: isWinner
        ? `Won with "${myDesign?.name||'—'}" (${myDesign?.credits?.toLocaleString()||0}⬡). Genome reinforced.`
        : isLoser
        ? `Last place with "${myDesign?.name||'—'}". Mutation pressure applied.`
        : `Ranked #${myDesign?.rank||'?'} with "${myDesign?.name||'—'}". Adaptive shifts applied.`,
      genomeShifts,
      rank: myDesign?.rank || 0,
      designName: myDesign?.name || '—',
    });

    // Store conversation memory from this cycle's cross-pollination
    if (cycleNum === 1) {
      agent.conversationMemory.push(
        { cycle: 1, partner: agentStates[(idx + 1) % 6].name, excerpt: 'First cycle cold start — exploring identity' }
      );
    } else {
      const partnerIdx = (idx + 1) % 6;
      agent.conversationMemory.push(
        { cycle: cycleNum, partner: agentStates[partnerIdx].name, excerpt: `Referenced C${cycleNum-1} winner and trend data in design dialogue` }
      );
    }
  });

  // Take post-evolution snapshot
  genomeSnapshots.push(agentStates.map(a => snapshotGenome(a)));
}

/* ══════════════════════════════════
   LIVE AI MODE — LLM CALLS
══════════════════════════════════ */
// ── Global Claude API concurrency + rate limiter ──
// Allows up to MAX_CONCURRENT in-flight requests while enforcing
// minimum spacing between request starts. This enables batching
// independent agent calls (e.g. parallel pairs in cross-pollination,
// parallel agent synthesis) without hammering the API.
let _lastClaudeCallTime = 0;
const CLAUDE_CALL_INTERVAL = 600;  // ms minimum between request starts
const MAX_CONCURRENT = 3;          // max simultaneous in-flight requests
let _inFlightCount = 0;
const _llmQueue = [];              // FIFO queue for pending calls

function _drainLlmQueue() {
  while (_llmQueue.length > 0 && _inFlightCount < MAX_CONCURRENT) {
    const next = _llmQueue.shift();
    next();
  }
}

async function llmCall(systemPrompt, userPrompt, agent) {
  if (!apiKeys.anthropic) return null;

  // Wait for concurrency slot
  if (_inFlightCount >= MAX_CONCURRENT) {
    await new Promise(resolve => _llmQueue.push(resolve));
  }

  // Enforce minimum spacing between request starts
  const now = Date.now();
  const elapsed = now - _lastClaudeCallTime;
  if (elapsed < CLAUDE_CALL_INTERVAL) {
    await new Promise(r => setTimeout(r, CLAUDE_CALL_INTERVAL - elapsed));
  }
  _lastClaudeCallTime = Date.now();
  _inFlightCount++;

  const ag = agent || agentStates[0];
  const genomeCtx = agentGenomeStr(ag);
  const reportCtx = priorReportCtx(ag.id || 0);
  const bioCtx = ag.bio ? `\nPERSONALITY BIO:\n${ag.bio}\n` : '';
  const fullSystem = `You are ${ag.name || 'an AI agent'}, a jewelry design AI in the JewelForge simulation.\n\n${bioCtx}\n${genomeCtx}\n\n${reportCtx}\n\n${systemPrompt}`;

  const body = JSON.stringify({
    model: 'claude-haiku-4-5-20251001',
    max_tokens: 400,
    system: fullSystem,
    messages: [{ role: 'user', content: userPrompt }]
  });
  const headers = {
    'Content-Type': 'application/json',
    'x-api-key': apiKeys.anthropic,
    'anthropic-version': '2023-06-01',
    'anthropic-dangerous-direct-browser-access': 'true'
  };

  // Retry up to 3 times with exponential backoff for rate limits / overload
  for (let attempt = 0; attempt < 3; attempt++) {
    try {
      const resp = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST', headers, body
      });
      if (resp.status === 429 || resp.status === 529) {
        // Rate limited or overloaded — back off and retry
        const wait = (attempt + 1) * 2500 + Math.random() * 1000;
        console.warn(`Claude ${resp.status} for ${ag.name} — retrying in ${Math.round(wait)}ms (attempt ${attempt+1}/3)`);
        await new Promise(r => setTimeout(r, wait));
        _lastClaudeCallTime = Date.now(); // reset pacer after backoff
        continue;
      }
      if (!resp.ok) {
        console.warn(`Claude HTTP ${resp.status} for ${ag.name}`);
        _inFlightCount--; _drainLlmQueue();
        return null;
      }
      const data = await resp.json();
      _inFlightCount--; _drainLlmQueue();
      return data.content?.[0]?.text || null;
    } catch(e) {
      console.warn(`Claude call failed for ${ag.name}:`, e);
      if (attempt < 2) {
        await new Promise(r => setTimeout(r, (attempt + 1) * 2000));
        _lastClaudeCallTime = Date.now();
        continue;
      }
    }
  }
  console.warn(`Claude call exhausted retries for ${ag.name}`);
  _inFlightCount--; _drainLlmQueue();
  return null;
}

/* ══════════════════════════════════
   DESIGN PROMPT REFINEMENT (Claude)
   Takes each agent's raw design prompt and translates
   it into optimized natural image-generation language
   through a dedicated Claude analysis pass.
══════════════════════════════════ */
async function refineDesignPrompt(design) {
  if (!apiKeys.anthropic) return design.prompt;

  const agent = agentStates.find(a => a.id === design.agentIdx) || agentStates[0];

  const refinePrompt = `Analyze this jewelry design concept and rewrite it as a professional image generation prompt optimized for AI image models (Flux/Stable Diffusion).

Design: "${design.name}"
Category: ${design.cat}
Strategy: ${design.strategy}
Scores: Aesthetic ${design.aesthetic}/100, Novelty ${design.novelty}/100, Profit ${design.profit}/100
Agent's raw prompt: "${design.prompt}"

Write a refined prompt (45-65 words) using natural photographic and jewelry-specific language:
- Precise metal: type, finish, color (e.g. "hand-hammered 18k rose gold with satin finish", "oxidized sterling silver")
- Gems/stones: cut, clarity, color, setting type (e.g. "tension-set princess-cut emerald", "pavé diamond halo")
- Form: silhouette, proportions, structural details, design motifs
- Texture: surface treatment, engraving, filigree, granulation
- Photography: "macro product photography", specific lighting (e.g. "butterfly lighting with soft rim light"), background surface (e.g. "on dark slate", "floating on gradient grey")
- Mood: one evocative word (e.g. "ethereal", "bold", "architectural")

Output ONLY the refined prompt. No quotes, no labels, no preamble.`;

  const resp = await llmCall(
    'You are a luxury jewelry photography art director and prompt engineer. Your sole task: translate design concepts into vivid, technically specific image generation prompts. Output ONLY the prompt text, nothing else.',
    refinePrompt,
    agent
  );

  if (resp) {
    const refined = resp.trim().replace(/^["']|["']$/g, '');
    console.log(`✦ Prompt refined [${design.agentName}]: "${design.prompt}" → "${refined}"`);
    return refined;
  }
  return design.prompt;
}

/* ══════════════════════════════════
   AGENT BIO GENERATION (Claude)
   Called at deploy time — converts raw genome DNA
   into a short natural-language personality profile.
══════════════════════════════════ */
async function generateAgentBio(agent) {
  // Always produce a sim-mode fallback bio from the genome
  const fallback = buildFallbackBio(agent);
  if (!apiKeys.anthropic) { agent.bio = fallback; return; }

  const genome = agentGenomeStr(agent);
  const prompt = `Below is the raw DNA genome of a jewelry design AI agent. Write a short personality bio (3-4 sentences, ~60 words) in third person that captures who this agent IS. Include:
- Their jewelry category specialties (which types of jewelry they excel at)
- Their aesthetic identity and design instincts
- Their commercial positioning and creative personality

Make it vivid and specific. Do NOT list numbers or repeat the genome format. Just the bio paragraph, nothing else.

${genome}`;

  try {
    const resp = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKeys.anthropic,
        'anthropic-version': '2023-06-01',
        'anthropic-dangerous-direct-browser-access': 'true'
      },
      body: JSON.stringify({
        model: 'claude-haiku-4-5-20251001',
        max_tokens: 180,
        system: 'You are a concise creative writer for a luxury jewelry AI simulation. Bios should convey the agent\'s jewelry category expertise, artistic vision, and design personality. Reference their strongest jewelry categories naturally. Output ONLY the bio paragraph — no labels, no quotes, no preamble.',
        messages: [{ role: 'user', content: prompt }]
      })
    });
    const data = await resp.json();
    const bio = data.content?.[0]?.text?.trim();
    agent.bio = bio || fallback;
  } catch(e) {
    console.warn('Bio generation failed for', agent.name, e);
    agent.bio = fallback;
  }
}

function buildFallbackBio(agent) {
  // Determine strongest category
  const cats = [
    { name: 'rings', val: agent.rings ?? 50 },
    { name: 'necklaces', val: agent.necklaces ?? 50 },
    { name: 'earrings', val: agent.earrings ?? 50 },
    { name: 'bracelets', val: agent.bracelets ?? 50 },
    { name: 'high jewelry', val: agent.highJewelry ?? 50 },
  ].sort((a,b) => b.val - a.val);
  const top = cats[0];
  const second = cats[1];
  const style = agent.minimalism > 60 ? 'minimalist' : agent.ornamentation > 60 ? 'ornate' : 'balanced';
  const riskWord = agent.risk > 65 ? 'bold explorer' : agent.risk < 35 ? 'disciplined refiner' : 'adaptive strategist';
  return `${agent.name} is a ${style} ${riskWord} with deep expertise in ${top.name}${second.val > 50 ? ' and ' + second.name : ''}. ${top.val > 70 ? 'A true specialist' : 'A versatile designer'} with ${(agent.styleTags||[]).slice(0,3).join(', ') || 'eclectic'} sensibilities, focused on ${agent.marketFocus || 'general'} markets.`;
}

/* ══════════════════════════════════
   logAgentBios — display each agent's AI-generated bio
   at the start of every cross-pollination round
══════════════════════════════════ */
function logAgentBios(baseDelay) {
  addLog(`<b>[AGENT DOSSIERS — Personality Profiles]</b>`, 'rp', baseDelay);
  agentStates.forEach((a, i) => {
    const bio = a.bio || buildFallbackBio(a);
    const avatarTag = a.avatarDataUrl ? `<img src="${a.avatarDataUrl}" class="agent-avatar-sm" />` : a.emoji;
    addLog(`${avatarTag} <b>${a.name}</b> — <i>${bio}</i>`, 'rp', baseDelay + 200 + i * 250);
  });
  return baseDelay + 200 + agentStates.length * 250 + 200; // return delay after all bios
}

/* ══════════════════════════════════
   LIVE AI CROSS-POLLINATION
   Each agent talks to 3 other agents via Claude.
   Conversations are logged and stored in conversationMemory.
══════════════════════════════════ */
// Pairs arranged into two batches of non-overlapping agent indices.
// Batch 1: [0,1],[2,4],[3,5] — all disjoint, can run in parallel.
// Batch 2: [0,3],[1,2],[4,5] — all disjoint, can run in parallel.
// Within each pair: A opens, B responds (serial). Across pairs: parallel.
// This cuts cross-pollination from 12 serial calls to 4 serial rounds of ~3 concurrent.
const CROSS_PAIR_BATCHES = [
  [[0,1],[2,4],[3,5]],  // Batch 1: disjoint pairs
  [[0,3],[1,2],[4,5]]   // Batch 2: disjoint pairs
];

async function runLiveCrossPollination(cycleNum, afterBiosDelay) {
  let delay = afterBiosDelay;
  agentStates.forEach((a,i)=>{ setTimeout(()=>setAgentStatus(a.id,'Conversing…'), delay/speed); });
  addLog(`Live AI cross-pollination — parallel pair batches via Claude…`, 'rs', delay);
  delay += 400;

  for (const batch of CROSS_PAIR_BATCHES) {
    // Run all pairs in this batch concurrently — each pair is A→B serial
    const batchResults = await Promise.all(batch.map(async ([iA, iB]) => {
      const agentA = agentStates[iA];
      const agentB = agentStates[iB];

      // Agent A opens
      const openPrompt = cycleNum === 1
        ? `This is cycle 1 — no prior data exists. Introduce your design direction to ${agentB.name} in 2-3 sentences. Be HIGHLY SPECIFIC: name exact metals (e.g. "18k rose gold", "950 platinum"), stones (e.g. "oval Ceylon sapphire", "old-mine-cut diamond"), techniques (e.g. "lost-wax casting", "micro-pavé", "hand-engraving"), and the customer you're designing for (e.g. "millennial bridal", "art collector", "everyday luxury"). Explain your strategic reasoning — why this direction given your genome DNA and instincts.`
        : `Cycle ${cycleNum}. You've read the intelligence reports from prior cycles. In 2-3 sentences, share your design direction with ${agentB.name} — be specific about: (1) what WORKED in prior cycles and what you're keeping, (2) what FAILED and what you're changing, (3) the exact materials, forms, and production methods you're pursuing. Reference specific data: winner names, credit totals, trend signals, saturation warnings.`;

      const msgA = await llmCall(
        `You are ${agentA.name}, a jewelry designer in a creative cross-pollination dialogue with ${agentB.name}. Speak in first person, 2-3 sentences. Be highly specific about jewelry design — name exact metals, stones, techniques, settings, production methods, and target customers. Your dialogue should reveal your strategic thinking and design philosophy.`,
        openPrompt,
        agentA
      );
      const lineA = msgA || getFallbackLine(agentA, cycleNum, 'open');

      // Agent B responds (depends on A's message)
      const replyPrompt = `Your partner ${agentA.name} said: "${lineA}"

Respond in 2-3 sentences. You must: (1) directly react to something specific they said — agree, challenge, or build on it, (2) share your own contrasting or complementary direction with equally specific materials, forms, and strategy, (3) identify a market opportunity or risk that their approach raises. Be concrete — name metals, stones, techniques, and customer segments.`;

      const msgB = await llmCall(
        `You are ${agentB.name}, a jewelry designer in a creative cross-pollination dialogue with ${agentA.name}. Speak in first person, 2-3 sentences. Be highly specific about jewelry design — name exact metals, stones, techniques, settings, production methods, and target customers. React directly to what your partner said.`,
        replyPrompt,
        agentB
      );
      const lineB = msgB || getFallbackLine(agentB, cycleNum, 'reply');

      // Store conversation memory for both agents
      agentA.conversationMemory.push({ cycle: cycleNum, partner: agentB.name, excerpt: lineB.slice(0, 120) });
      agentB.conversationMemory.push({ cycle: cycleNum, partner: agentA.name, excerpt: lineA.slice(0, 120) });

      return { agentA, agentB, lineA, lineB };
    }));

    // Log results from this batch (in order)
    for (const { agentA, agentB, lineA, lineB } of batchResults) {
      addLog(`<b>${agentA.name}</b> → <b>${agentB.name}</b>: "${lineA}"`, 'cv', delay);
      addLog(`<b>${agentB.name}</b>: "${lineB}"`, 'cv', delay + 300);
      delay += 700;
    }
  }

  addLog(`All 6 agents complete ${CROSS_PAIR_BATCHES.flat().length} cross-pollination exchanges. Memory updated.`, 'rs', delay);
  delay += 300;
  setProgress(20);
  return delay;
}

function getFallbackLine(agent, cycle, role) {
  const style = agent.minimalism > 60 ? 'minimal, structural' : agent.ornamentation > 60 ? 'ornate, detailed' : 'balanced';
  const risk = agent.risk > 65 ? 'pushing boundaries' : agent.risk < 35 ? 'refining proven forms' : 'adapting';
  if (role === 'open') return `Cycle ${cycle} — I'm going ${style}. ${risk}. Let's see how the market responds.`;
  return `Interesting. My genome says ${style} too — but I'm ${risk} this round.`;
}

/* ══════════════════════════════════
   LIVE AI SYNTHESIS → GENERATION (Combined Pipeline)
   Synthesis was a separate phase that produced blueprints
   which generation then re-derived from scratch. Now merged
   into a single 3-step pipeline per agent:
     Step 1 (was Synthesis): Strategic blueprint + naming via Claude
     Step 2: Self-assessment + image prompt
     Step 3: Prompt refinement folded into Step 2 output

   Agents are processed in parallel batches of 3 for throughput.
══════════════════════════════════ */
async function runLiveSynthesis(cycleNum) {
  // Synthesis is now the first half of the combined pipeline.
  // We show the synthesis UI phase, then flow straight into generation.
  let delay = 200;
  agentStates.forEach(a=>setAgentStatus(a.id,'Synthesizing…'));
  addLog(`Synthesis + Design phase: agents deliberate strategy, assess, and name via Claude (Cycle ${cycleNum})…`, 'rs', delay);
  delay += 400;

  setProgress(30);
  document.getElementById('designs-wrap').style.display='block';

  const designs = [];
  const categories = ['Ring','Pendant','Earrings','Bracelet'];
  const designEmojis = ['⬡','🌑','✨','🔷','💍','🌹','💙','⚡','💎','🦴','🌸','🔥','🌿','💛','⭐','🔶'];

  // ── Build used-names blacklist from prior cycles ──
  const allUsedNames = cycleReports.flatMap(r => (r.designs || []).map(d => d.name));
  const usedNamesStr = allUsedNames.length > 0
    ? `\nALREADY-USED NAMES (do NOT reuse any word from these):\n${allUsedNames.map(n => `"${n}"`).join(', ')}\nYour name must use completely different vocabulary.\n`
    : '';

  // ── Process agents in parallel batches of 3 ──
  const BATCH_SIZE = 3;
  for (let batch = 0; batch < agentStates.length; batch += BATCH_SIZE) {
    const batchAgents = agentStates.slice(batch, batch + BATCH_SIZE);

    const batchPromises = batchAgents.map(async (agent, batchIdx) => {
      const i = batch + batchIdx;
      const convMem = (agent.conversationMemory || []).filter(m => m.cycle === cycleNum).map(m => `${m.partner}: "${m.excerpt}"`).join('\n');
      const allConvMem = (agent.conversationMemory || []).map(m => `[Cycle ${m.cycle}] ${m.partner}: "${m.excerpt}"`).join('\n');

      // ── Step 1: Strategic Blueprint (strategy + design specs, NO naming) ──
      setAgentStatus(agent.id, 'Synthesizing…');

      const blueprintPrompt = `You are ${agent.name}, beginning your design process for Cycle ${cycleNum}.

YOUR CROSS-POLLINATION DIALOGUES THIS CYCLE:
${convMem || 'No conversations this cycle.'}

ALL PRIOR DIALOGUES:
${allConvMem || 'No prior conversations.'}

Based on everything you know — your genome DNA, your personality bio, every conversation you've had, your evolution history, and every intelligence report — make your strategic decision.

Think about:
- What worked and what failed in prior cycles (your rank, the winners, the trends)
- What your conversation partners said that influenced your thinking
- Where the market is headed vs where it's saturated
- Your natural strengths from your genome vs where you need to adapt

CRITICAL — your design must be PRODUCIBLE and SELLABLE:
- Refer to your MANUFACTURING CONSTRAINTS in your genome. If your manufacturability is high, your design MUST be castable (lost-wax compatible, no impossible undercuts, clean mold-release geometry). If low, you may use hand-fabrication techniques.
- Consider your PRICE POINT genome. Your material choices must match — don't design a $200 piece in platinum with 3ct diamonds, and don't design a $50K piece in silver.
- Think about WHO BUYS THIS. Your market focus and wearability scores define your customer. A bridal customer needs comfort and durability. A collector wants rarity and drama.
- Consider production volume — high manufacturability means designing for 100+ units. Low means one-of-a-kind.

Output EXACTLY this JSON (no markdown, no backticks):
{"strategy":"[exploit or explore or mutate]","cat":"[Ring or Pendant or Earrings or Bracelet]","reasoning":"[3-4 sentences: WHY this strategy and category. Reference specific intelligence: winner names, credit totals, trend signals, conversation excerpts, and genome traits. Explain the commercial logic.]","materials":"[SPECIFIC metals and stones that match your price point and production method — e.g. '14K yellow gold, bezel-set 1.2ct oval lab-grown sapphire, accent pavé VS1 diamonds' not just 'gold and sapphire']","form":"[structural concept in 8-15 words describing silhouette, proportions, and key design features]","production":"[specific production method: investment casting, hand-fabricated wire wrapping, 3D-printed resin to lost-wax, electroformed, die-struck, etc.]","targetCustomer":"[specific customer persona in 10-20 words — age, occasion, style, budget range]","complexity":[1-10 integer],"estMargin":[40-90 integer]}`;

      const blueprintResp = await llmCall(
        'You are making a strategic design decision. Think deeply about your agent data, genome, conversations, and market intelligence. Output ONLY valid JSON.',
        blueprintPrompt, agent
      );

      let blueprint = null;
      if (blueprintResp) {
        try {
          blueprint = JSON.parse(blueprintResp.replace(/```json?\s*/g,'').replace(/```/g,'').trim());
        } catch(e) { console.warn('Blueprint parse failed for', agent.name, blueprintResp); }
      }

      // Fallback
      if (!blueprint) {
        blueprint = {
          strategy: agent.risk > 65 ? 'explore' : agent.risk < 35 ? 'exploit' : 'mutate',
          cat: categories[i % 4],
          reasoning: 'Proceeding based on genome defaults.',
          materials: agent.platBias > 60 ? 'platinum' : 'gold',
          form: 'refined jewelry piece',
          complexity: 5,
          estMargin: 65
        };
      }
      if (!categories.includes(blueprint.cat)) blueprint.cat = categories[i % 4];
      if (!['exploit','explore','mutate'].includes(blueprint.strategy)) blueprint.strategy = 'explore';
      blueprint.complexity = Math.max(1, Math.min(10, parseInt(blueprint.complexity)||5));
      blueprint.estMargin = Math.max(40, Math.min(90, parseInt(blueprint.estMargin)||65));

      // Capture rationale for persistence (Claude-Flow Improvement 4)
      if (!window._cycleRationales) window._cycleRationales = [];
      window._cycleRationales.push({
        cycle: cycleNum,
        agentIdx: agent.id,
        agentName: agent.name,
        strategicReasoning: blueprint.reasoning || '',
        predictedStrategy: blueprint.strategy,
        predictedCategory: blueprint.cat
      });

      // Log the synthesis blueprint (name comes later in Step 3)
      addLog(`<b>${agent.name}</b> — Strategy: <b>${blueprint.strategy.toUpperCase()}</b> · ${blueprint.cat} · Complexity ${blueprint.complexity}/10 · Est. margin ${blueprint.estMargin}%`, '', delay + i*300);
      addLog(`<span style="opacity:.55;font-size:.7rem;margin-left:1rem">${(blueprint.reasoning||'').slice(0,160)}</span>`, '', delay + i*300 + 100);

      // ── Step 2: Self-Assessment + Image Prompt (with refined prompt built-in) ──
      setAgentStatus(agent.id, 'Designing…');

      const assessPrompt = `You are ${agent.name}, finalizing your Cycle ${cycleNum} submission.

YOUR DESIGN:
- Category: ${blueprint.cat}
- Strategy: ${blueprint.strategy.toUpperCase()}
- Materials: ${blueprint.materials}
- Form: ${blueprint.form}
- Production method: ${blueprint.production || 'not specified'}
- Target customer: ${blueprint.targetCustomer || 'not specified'}
- Complexity: ${blueprint.complexity}/10
- Est. Margin: ${blueprint.estMargin}%
- Strategic reasoning: ${blueprint.reasoning}

YOUR CONVERSATIONS THIS CYCLE:
${convMem || 'None.'}

Self-assess your design across ALL dimensions and create the image prompt.

SCORING CRITERIA — be honest and calibrated:
- Aesthetic (40-95): Visual beauty, craftsmanship quality, and design coherence
- Novelty (30-95): How original/unprecedented — penalize yourself if this is derivative
- Profit (35-95): Real commercial viability. Consider: Can this be manufactured at your price point? Does your target customer exist in volume? Are your material costs realistic for the margin? Would a jewelry retailer stock this?
- Wearability (30-95): Comfort, durability, practical weight, secure settings, no snag points. Score LOW if this is unwearable art, HIGH if someone would wear it daily
- Manufacturability (30-95): Can a bench jeweler or factory actually produce this? Score HIGH for clean castable geometry, standard setting types. Score LOW for impossible forms, materials that can't be combined, or techniques that don't exist

For the image prompt — write a vivid, technically specific description for AI image generation (20-30 WORDS):
- Metal: exact type and finish (e.g. "hand-hammered 18k rose gold with satin finish", "rhodium-plated white gold")
- Stone/gem: cut, color, setting type (e.g. "bezel-set cushion-cut Ceylon sapphire", "channel-set baguette diamonds")
- Form: silhouette, key structural features (e.g. "split-shank cathedral mount", "articulated chain links")
- Photography: "macro product photography" + lighting style (e.g. "butterfly lighting on dark slate")
- Mood: one evocative word (e.g. "ethereal", "brutalist", "organic")

Output EXACTLY this JSON (no markdown):
{"aesthetic":[40-95],"novelty":[30-95],"profit":[35-95],"wearability":[30-95],"makeable":[30-95],"prompt":"[20-30 word image prompt]"}`;

      const assessResp = await llmCall(
        'You are assessing your own jewelry design and writing the final image prompt. Be calibrated in scores. Write a vivid, technically specific prompt. Output ONLY valid JSON.',
        assessPrompt, agent
      );

      let assessData = null;
      if (assessResp) {
        try {
          assessData = JSON.parse(assessResp.replace(/```json?\s*/g,'').replace(/```/g,'').trim());
        } catch(e) { console.warn('Assessment parse failed for', agent.name, assessResp); }
      }

      // ── Step 3: Name Generation (from image prompt analysis) ──
      setAgentStatus(agent.id, 'Naming…');

      const imagePromptText = assessData?.prompt || `${blueprint.materials} ${blueprint.cat}, ${blueprint.form}`;
      const namingPrompt = `You are a luxury jewelry naming specialist working for a high-end maison. Analyze this product and create a collection name.

IMAGE DESCRIPTION: ${imagePromptText}

DESIGN DETAILS:
- Category: ${blueprint.cat}
- Materials: ${blueprint.materials}
- Form: ${blueprint.form}
- Production: ${blueprint.production || 'not specified'}
- Target customer: ${blueprint.targetCustomer || 'luxury consumer'}
- Strategy: ${blueprint.strategy}

Create a 1-3 word luxury collection name. Study how iconic houses name pieces:
- Cartier: "Juste un Clou", "Trinity", "Panthère", "Clash"
- Bulgari: "Serpenti", "B.zero1", "Divas' Dream"
- Tiffany: "Bone Cuff", "HardWear", "Elsa Peretti Bean"
- Van Cleef: "Alhambra", "Frivole", "Perlée"
- David Yurman: "Cable", "Crossover", "Stax"

Your name should:
- Evoke the FORM, TEXTURE, or EMOTIONAL QUALITY of the piece — not just the materials
- Be memorable, distinctive, and pronounceable
- Work as a collection name (could apply to a family of related pieces)
- NEVER use generic words like "Luxury", "Elegance", "Beautiful", "Golden"
- NEVER just describe the materials (e.g. "Gold Ring" or "Diamond Pendant")
${usedNamesStr}
Output EXACTLY this JSON (no markdown):
{"name":"[1-3 word name ONLY]"}`;

      const nameResp = await llmCall(
        'You are a creative director at a luxury jewelry maison, specializing in naming collections. Your names are iconic, evocative, and never generic. Output ONLY valid JSON with a "name" field.',
        namingPrompt, agent
      );

      let designName = '';
      if (nameResp) {
        try {
          const nameData = JSON.parse(nameResp.replace(/```json?\s*/g,'').replace(/```/g,'').trim());
          designName = (nameData.name || '').trim().replace(/^["']+|["']+$/g, '').slice(0, 80);
        } catch(e) { console.warn('Naming parse failed for', agent.name, nameResp); }
      }
      if (!designName || designName.length < 3) {
        designName = `${blueprint.materials || 'Gold'} ${blueprint.form || blueprint.cat}`;
      }

      // ── Step 4: Prompt Refinement (optimize image prompt via Claude) ──
      setAgentStatus(agent.id, 'Refining prompt…');

      const rawImagePrompt = assessData?.prompt || `${blueprint.materials} ${blueprint.cat.toLowerCase()}, ${blueprint.form}, macro product photography`;
      const refinedPrompt = await refineDesignPrompt({
        name: designName,
        cat: blueprint.cat,
        strategy: blueprint.strategy,
        aesthetic: parseInt(assessData?.aesthetic)||60,
        novelty: parseInt(assessData?.novelty)||50,
        profit: parseInt(assessData?.profit)||55,
        prompt: rawImagePrompt,
        agentIdx: agent.id,
        agentName: agent.name,
      });

      // Build the final design object
      const design = {
        name: designName,
        cat: blueprint.cat,
        strategy: blueprint.strategy,
        aesthetic: Math.max(20, Math.min(98, parseInt(assessData?.aesthetic)||60)),
        novelty:  Math.max(20, Math.min(98, parseInt(assessData?.novelty)||50)),
        profit:   Math.max(20, Math.min(98, parseInt(assessData?.profit)||55)),
        wearability: Math.max(20, Math.min(98, parseInt(assessData?.wearability)||55)),
        makeable: Math.max(20, Math.min(98, parseInt(assessData?.makeable)||60)),
        prompt:   refinedPrompt || rawImagePrompt,
        rawPrompt: rawImagePrompt,
        strategicReasoning: blueprint.reasoning,
        materials: blueprint.materials,
        formConcept: blueprint.form,
        production: blueprint.production || '',
        targetCustomer: blueprint.targetCustomer || '',
        complexity: blueprint.complexity,
        estMargin: blueprint.estMargin,
        agentIdx: agent.id,
        agentName: agent.name,
        emoji: designEmojis[i + (cycleNum-1)*6] || '⬡',
        credits: 0
      };

      return { design, index: i };
    });

    // Await the batch
    const batchResults = await Promise.all(batchPromises);
    for (const { design, index } of batchResults) {
      designs.push(design);
      addLog(`<b>${design.agentName}</b> submits: <i>"${design.name}"</i> — ${design.cat} · ${design.strategy.toUpperCase()} · AES:${design.aesthetic} NOV:${design.novelty} PRO:${design.profit}`, 'ds', delay + agentStates.length*300 + 400 + index*400);
      addLog(`<span style="opacity:.6;font-size:.7rem">${design.prompt.slice(0,150)}</span>`, '', delay + agentStates.length*300 + 550 + index*400);
      setTimeout(()=>renderDesignCard(design, index), (delay + agentStates.length*300 + 400 + index*400)/speed);
    }
  }

  activeDesigns = designs;
  const totalDelay = delay + agentStates.length*300 + 400 + agentStates.length*400 + 200;
  addLog(`All ${designs.length} designs submitted via 4-step Claude pipeline (${designs.length * 4} API calls: blueprint → assess → name → refine). Pool locked.`, 'rs', totalDelay);
  setProgress(60);
  return totalDelay + 400;
}

// runLiveGeneration is now integrated into runLiveSynthesis above.
// The combined pipeline handles synthesis + generation in a single phase
// with parallel batching, eliminating 18 redundant API calls per cycle.
function runLiveGeneration(cycleNum) {
  // No-op: designs already created by runLiveSynthesis.
  // Kept as stub for any sim-mode phase scripts that call it.
  return 0;
}

/* ══════════════════════════════════
   LIVE AI VOTING (Phase 3)
   Each agent reviews all designs and allocates 10,000⬡ via Claude.
   Two-step: reasoning first, then allocation.
══════════════════════════════════ */
async function runLiveVoting(cycleNum) {
  setProgress(65);
  agentStates.forEach(a=>setAgentStatus(a.id,'Evaluating…'));
  addLog(`Live AI voting — all agents deliberate in parallel via Claude…`, 'rs', 100);

  // Rich design summaries including strategic context
  const designSummary = activeDesigns.map((d,i) =>
    `[${i}] "${d.name}" by ${d.agentName} — ${d.cat} · ${d.strategy.toUpperCase()} · AES:${d.aesthetic} NOV:${d.novelty} PRO:${d.profit} WEAR:${d.wearability||'?'} MFG:${d.makeable||'?'}${d.targetCustomer ? ' · Customer: '+d.targetCustomer : ''}${d.strategicReasoning ? ' · Reasoning: '+d.strategicReasoning.slice(0,60) : ''}`
  ).join('\n');

  // All 6 voters are independent — run them all concurrently
  // The concurrency limiter in llmCall handles throttling to MAX_CONCURRENT
  const voteResults = await Promise.all(agentStates.map(async (voter, vi) => {
    const selfIdx = activeDesigns.findIndex(d=>d.agentIdx===vi);
    const convMem = (voter.conversationMemory || []).filter(m => m.cycle === cycleNum).map(m => `${m.partner}: "${m.excerpt}"`).join('\n');

    const votePrompt = `You are ${voter.name}, voting in Cycle ${cycleNum}. You have 10,000⬡ to allocate across ${activeDesigns.length} designs. You CANNOT vote for your own design (index ${selfIdx}).

THE DESIGNS TO EVALUATE:
${designSummary}

YOUR REPUTATION: ${voter.reputation} → vote weight multiplier: ${(0.7 + (voter.reputation / 100) * 0.6).toFixed(2)}x

YOUR CONVERSATIONS THIS CYCLE:
${convMem || 'No conversations recorded.'}

EVALUATION FRAMEWORK — weigh each design across these dimensions based on YOUR genome:
1. AESTHETIC QUALITY (weight by your genome's style preferences): Does the design match your taste? Consider form, proportion, material harmony, and visual impact.
2. COMMERCIAL VIABILITY (weight by your marginSens genome): Can this realistically sell? Consider price point, target customer clarity, and margin potential.
3. MANUFACTURABILITY (weight by your genome): Can this be physically produced? Castable geometry, standard settings, realistic material combinations.
4. NOVELTY vs SAFETY (weight by your risk genome): Is it fresh enough to win, or is it too derivative? Your risk tolerance determines how much you reward innovation.
5. STRATEGIC ALIGNMENT: Does this design ride an emerging trend or fight a saturated one? Reference intelligence reports.

VOTING STRATEGY:
- Concentrate votes on 2-3 designs you believe will win — don't spread too thin
- Heavy conviction bets (4000-5000⬡ on your top pick) signal strong belief
- Consider what OTHER agents will vote for — game theory matters

Output EXACTLY this JSON (no markdown):
{"reasoning":"[2-3 sentences: your specific analysis — which designs impressed you and why, referencing scores, materials, strategy, and your genome preferences]","votes":[${activeDesigns.map((_,j)=>j===selfIdx?'0':'integer').join(',')}]}

The votes array must be ${activeDesigns.length} integers that sum to 10000. Put 0 for your own design (index ${selfIdx}).`;

    const resp = await llmCall(
      `You are ${voter.name}, a jewelry design expert deliberating on vote allocation. Think deeply about your genome DNA, your conversations this cycle, intelligence reports, and each design's merits. Your votes should reflect your unique perspective and strategic thinking. Output ONLY valid JSON.`,
      votePrompt, voter
    );

    let votes = null;
    let voteReasoning = '';
    if (resp) {
      try {
        const cleaned = resp.replace(/```json?\s*/g,'').replace(/```/g,'').trim();
        const parsed = JSON.parse(cleaned);
        const voteArr = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.votes) ? parsed.votes : null);
        voteReasoning = parsed.reasoning || '';
        if (voteArr && voteArr.length === activeDesigns.length) {
          const rawSum = voteArr.reduce((a,b)=>a+Math.max(0,b),0);
          votes = voteArr.map(v => rawSum > 0 ? Math.round(Math.max(0,v) / rawSum * 10000) : 0);
          const diff = 10000 - votes.reduce((a,b)=>a+b,0);
          if (diff !== 0) { const maxIdx = votes.indexOf(Math.max(...votes)); votes[maxIdx] += diff; }
          if (selfIdx >= 0 && votes[selfIdx] > 0) {
            const selfV = votes[selfIdx]; votes[selfIdx] = 0;
            const others = votes.map((v,i)=>i===selfIdx?0:v);
            const otherSum = others.reduce((a,b)=>a+b,0);
            if (otherSum > 0) votes = votes.map((v,i)=>i===selfIdx?0:v+Math.round(selfV*v/otherSum));
            const fix2 = 10000 - votes.reduce((a,b)=>a+b,0);
            if (fix2 !== 0) { const mi = votes.reduce((best,v,i)=>i!==selfIdx&&v>votes[best]?i:best,selfIdx===0?1:0); votes[mi]+=fix2; }
          }
        }
      } catch(e) { console.warn('Vote parse failed for', voter.name, resp); }
    }

    if (!votes) {
      votes = activeDesigns.map((d,i) => {
        if (i === selfIdx) return 0;
        return d.aesthetic * 2 + d.novelty + d.profit;
      });
      const rawSum = votes.reduce((a,b)=>a+b,0);
      votes = votes.map(v => rawSum > 0 ? Math.round(v/rawSum*10000) : 0);
      const diff = 10000 - votes.reduce((a,b)=>a+b,0);
      if (diff !== 0) { const mi = votes.reduce((best,v,i)=>i!==selfIdx&&v>votes[best]?i:best,selfIdx===0?1:0); votes[mi]+=diff; }
      voteReasoning = 'Voted based on genome aesthetic affinity (fallback).';
    }

    // Capture vote rationale for persistence (Claude-Flow Improvement 4)
    const topVoteIdx = votes ? votes.reduce((best, v, idx) => v > (votes[best] || 0) ? idx : best, 0) : -1;
    if (window._cycleRationales) {
      const myRationale = window._cycleRationales.find(r => r.cycle === cycleNum && r.agentIdx === vi);
      if (myRationale) {
        myRationale.voteReasoning = voteReasoning;
        myRationale.topVoteIdx = topVoteIdx;
      }
    }

    return { vi, votes, voteReasoning, voterName: voter.name };
  }));

  // Collect results in order and log
  const liveVoteMatrix = new Array(agentStates.length);
  for (const { vi, votes, voteReasoning, voterName } of voteResults) {
    liveVoteMatrix[vi] = votes;
    const top2 = votes.map((v,i)=>({i,v})).sort((a,b)=>b.v-a.v).filter(x=>x.v>0).slice(0,2);
    const msg = top2.map(x=>`"${activeDesigns[x.i]?.name}" ${x.v.toLocaleString()}⬡`).join(', ');
    addLog(`<b>${voterName}</b> → ${msg}`, 'vt', 300 + vi*300);
    if (voteReasoning) {
      addLog(`<span style="opacity:.55;font-size:.7rem;margin-left:1rem">${voteReasoning.slice(0,160)}</span>`, '', 300 + vi*300 + 100);
    }
  }

  // Tally with reputation-weighted voting (Claude-Flow Improvement 3)
  liveVoteMatrix.forEach((vv,vi)=>{
    const voter = agentStates[vi];
    const repMultiplier = 0.7 + ((voter?.reputation || 50) / 100) * 0.6; // range 0.7x to 1.3x
    vv.forEach((c,di)=>{
      if(di<activeDesigns.length) activeDesigns[di].credits += Math.round(c * repMultiplier);
    });
  });
  setTimeout(()=>{
    activeDesigns.forEach((d,i)=>{ const e=document.getElementById('dc-cred-'+i); if(e) e.textContent=d.credits.toLocaleString()+'⬡'; });
    agentStates.forEach((a,vi)=>{ const spent=liveVoteMatrix[vi].reduce((s,v)=>s+v,0); a.credits=10000-spent; setAgentCreds(a.id,a.credits); setAgentStatus(a.id,'Voted'); });
  }, (300+agentStates.length*300+200)/speed);
  window._liveVoteMatrix = liveVoteMatrix;
  addLog(`Voting complete. All 6 agents voted in parallel. Credits tallied.`, 'rs', 300+agentStates.length*300+300);
  setProgress(80);
  return 300+agentStates.length*300+600;
}

/* ══════════════════════════════════
   LIVE AI EVOLUTION (Phase 4)
   Claude analyzes results and determines genome shifts,
   beliefs, and trend narratives for each agent.
══════════════════════════════════ */
async function runLiveEvolution(cycleNum) {
  setProgress(85);
  const sorted = [...activeDesigns].map((d,i)=>({...d,idx:i})).sort((a,b)=>b.credits-a.credits);
  const winner = sorted[0];
  const loser = sorted[sorted.length-1];

  // Winner card UI
  setTimeout(()=>{
    const wc = document.getElementById('dc-'+winner.idx);
    if(wc){ wc.classList.add('winner-card'); const body=wc.querySelector('.dcard-body'); if(body) body.insertAdjacentHTML('afterbegin','<div class="win-badge">🏆 Cycle Winner</div>'); }
  }, 300/speed);

  addLog(`🏆 <b>"${winner.name}"</b> by ${winner.agentName} — ${winner.credits.toLocaleString()}⬡`, 'rs', 300);

  const resultsSummary = sorted.map((d,rank) =>
    `#${rank+1}: by ${agentStates[d.agentIdx]?.name} — ${d.credits.toLocaleString()}⬡ · ${d.strategy} · AES:${d.aesthetic} NOV:${d.novelty} PRO:${d.profit} WEAR:${d.wearability||'?'} MFG:${d.makeable||'?'} · ${d.cat}${d.production ? ' · '+d.production : ''}${d.targetCustomer ? ' · For: '+d.targetCustomer : ''}`
  ).join('\n');

  const priorContext = cycleReports.length > 0
    ? `Prior winners: ${cycleReports.map(r=>`C${r.cycle}: ${r.winner.agentName}'s ${r.winner.strategy?.toUpperCase()||'?'} ${r.winner.cat||'design'}`).join(', ')}`
    : 'No prior cycles.';

  // ── Launch all 6 evolution calls + 1 trend call in parallel ──
  // All are independent — no agent's evolution depends on another's.
  const trendPrompt = `Cycle ${cycleNum} of 3 completed. Full results:
${resultsSummary}

${priorContext}

Generate a comprehensive trend analysis for the intelligence report that agents will use to make decisions next cycle. Be HIGHLY SPECIFIC — reference exact design names, credit totals, material choices, and percentages.

Output EXACTLY this JSON:
{"emerging":["[specific style with evidence, e.g. 'organic sculptural (Root Form won 14,200⬡)']","[style2]","[style3]"],"declining":["[specific style with evidence, e.g. 'classic pavé halo (avg 6,100⬡, down from 8,400⬡ C1)']","[style2]"],"saturation":"[exact category breakdown with percentages, e.g. 'Ring at 67% (4 of 6 entries) — critical oversaturation']","treasury":"[specific material+setting+form recommendation for highest ROI, e.g. '18k rose gold, bezel-set oval sapphire, open-gallery cathedral mount']","velocityScore":[0-100: how fast trends are shifting — high = rapid disruption, low = stable consensus],"fi":["[insight 1: vote pattern analysis — which score dimension predicted credits? Include correlation direction]","[insight 2: category saturation with exact counts and percentages — which categories are opportunities?]","[insight 3: material and setting trend — what materials won and lost, with credit data]","[insight 4: strategy performance — exploit vs explore vs mutate, with average credits per strategy]","[insight 5: specific actionable recommendation for next cycle — what should agents do differently?]"]}`;

  // Fire trend analysis concurrently with agent evolution
  const trendPromise = llmCall(
    'Output ONLY valid JSON. No markdown.',
    trendPrompt, agentStates[0]
  );

  // Fire all 6 agent evolution calls concurrently
  const evoPromises = agentStates.map(async (agent, i) => {
    const myDesign = sorted.find(d=>d.agentIdx===i);
    const rank = myDesign ? sorted.indexOf(myDesign) : 5;
    const isWinner = rank === 0;
    const isLoser = rank === sorted.length - 1;

    const myConvMem = (agent.conversationMemory || []).filter(m => m.cycle === cycleNum).map(m => `${m.partner}: "${m.excerpt}"`).join('\n');

    const evoPrompt = `Cycle ${cycleNum} results:
${resultsSummary}

${priorContext}

You are ${agent.name} (rank #${rank+1}, strategy: ${myDesign?.strategy||'?'}, category: ${myDesign?.cat||'?'}).
${myDesign?.strategicReasoning ? `Your strategic reasoning this cycle: ${myDesign.strategicReasoning}` : ''}

Your cross-pollination conversations this cycle:
${myConvMem || 'None recorded.'}

${traitEffectivenessContext(i) ? 'TRAIT EFFECTIVENESS DATA (from EWC analysis):\n' + traitEffectivenessContext(i) + '\n' : ''}
Analyze these results deeply. Consider:
- How did your strategic reasoning play out? Was your bet correct?
- What did your conversation partners predict vs what actually happened?
- Which genome traits served you well? Which held you back? Check the TRAIT EFFECTIVENESS DATA if available.
- What specific design attributes (category, materials, strategy) drove the winning design?
- Were the winning designs more wearable? More producible? Better targeted to a specific customer?
- Should you shift your price point, manufacturability approach, or target customer next cycle?
- IMPORTANT: Traits marked with "PROVEN — shift cautiously" have strong cross-cycle correlation with success. DAMPEN changes to those traits.

Output EXACTLY this JSON (no markdown):
{"belief":"[one vivid, specific sentence: what you learned — reference the winning design's name, materials, credit count, and what that teaches you about market preferences]","shifts":{"minimalism":[integer -10 to +10],"novelty":[integer -10 to +10],"ornamentation":[integer -10 to +10],"marketFit":[integer -10 to +10],"risk":[integer -10 to +10],"marginSens":[integer -10 to +10],"pricePoint":[integer -10 to +10],"manufacturability":[integer -10 to +10],"wearability":[integer -10 to +10],"trendSens":[integer -10 to +10]},"trend":"[one specific sentence: the key market trend with evidence — name the winning category, materials, strategy, and what's emerging vs declining]"}

Context: ${isWinner ? 'You WON — your instincts were validated. Make SMALL reinforcing shifts (+1 to +3). Dont over-correct. What specific trait drove your success?' : isLoser ? 'You came LAST — something fundamental failed. Make BOLD shifts (+5 to +10 on key traits). Identify the exact mismatch: was it your materials? Category saturation? Aesthetic that the market rejected? Commercial viability?' : `You placed #${rank+1}. Make MODERATE shifts (+2 to +6). Study the gap between your design and the winner — what specific trait or decision separated you?`}`;

    const resp = await llmCall(
      'You are reflecting on your cycle performance. Think deeply about YOUR specific data — your genome, conversations, strategy, and results. Output ONLY valid JSON.',
      evoPrompt, agent
    );

    return { i, resp, myDesign, rank, isWinner, isLoser };
  });

  // Await all evolution + trend results
  const [evoResults, trendResp] = await Promise.all([
    Promise.all(evoPromises),
    trendPromise
  ]);

  // Apply evolution results (must be sequential — mutates agent state)
  for (const { i, resp, myDesign, rank, isWinner, isLoser } of evoResults) {
    const agent = agentStates[i];

    let evo = null;
    if (resp) {
      try {
        evo = JSON.parse(resp.replace(/```json?\s*/g,'').replace(/```/g,'').trim());
      } catch(e) { console.warn('Evolution parse failed for', agent.name); }
    }

    const genomeShifts = {};
    if (evo?.shifts) {
      Object.entries(evo.shifts).forEach(([key, delta]) => {
        if (agent[key] !== undefined && typeof delta === 'number') {
          let clamped = Math.max(-10, Math.min(10, delta));
          // EWC dampening: proven traits resist large changes (Claude-Flow Improvement 5)
          const te = traitEffectiveness[key];
          if (te && te.importanceWeight > 0.4 && te.samples >= 2) {
            const dampFactor = 1 - (te.importanceWeight * 0.5);
            clamped = Math.round(clamped * dampFactor);
          }
          const oldVal = agent[key];
          agent[key] = Math.max(0, Math.min(100, agent[key] + clamped));
          genomeShifts[key] = agent[key] - oldVal;
        }
      });
    } else {
      const shifts = isWinner ? {novelty:+3,risk:-4,manufacturability:+2} : isLoser ? {novelty:+8,risk:+6,marginSens:+4,wearability:+3,manufacturability:+3} : {novelty:+2,risk:+2,wearability:+1};
      Object.entries(shifts).forEach(([k,d])=>{ if(agent[k]!==undefined){ const o=agent[k]; agent[k]=Math.max(0,Math.min(100,agent[k]+d)); genomeShifts[k]=agent[k]-o; }});
    }

    agent.dominantBelief = evo?.belief || (isWinner ? 'My approach worked — refine further.' : isLoser ? 'Need a fundamentally different direction.' : 'Adapt toward the winning aesthetic.');
    agent.trustBuilt = Math.min(100, (agent.trustBuilt||0) + (isWinner?15:isLoser?-5:5));

    const repDelta = cycleNum===3 ? (isWinner?12:rank<=1?5:rank<=2?2:-4) : (isWinner?9:rank<=1?4:rank<=2?1:-3);
    agent.reputation = Math.max(5, agent.reputation + repDelta);
    setAgentStatus(agent.id, isWinner ? (cycleNum===3 ? '🏆 Epoch Winner' : 'Winner') : 'Cycle complete');

    agent.evolutionHistory.push({
      cycle: cycleNum,
      summary: isWinner
        ? `Won (${myDesign?.credits?.toLocaleString()||0}⬡, ${myDesign?.strategy||'?'} ${myDesign?.cat||'design'}). Genome reinforced.`
        : isLoser
        ? `Last place (${myDesign?.strategy||'?'} ${myDesign?.cat||'design'}). Mutation pressure applied.`
        : `Ranked #${rank+1} (${myDesign?.strategy||'?'} ${myDesign?.cat||'design'}). Adaptive shifts applied.`,
      genomeShifts,
      rank: rank + 1,
      designName: myDesign?.name || '—',
    });

    const shiftStr = Object.entries(genomeShifts).filter(([,v])=>v!==0).map(([k,v])=>`${k}:${v>0?'+':''}${v}`).join(' · ');
    addLog(`<b>${agent.name}</b> (${isWinner?'Winner':isLoser?'Last':'#'+(rank+1)}): <i>${agent.dominantBelief}</i> ${shiftStr?'· '+shiftStr:''}`, '', 600+i*200);
  }

  // Process trend result
  let trendInsight = null;
  if (trendResp) {
    try { trendInsight = JSON.parse(trendResp.replace(/```json?\s*/g,'').replace(/```/g,'').trim()); } catch(e) {}
  }

  const trendDelay = 600 + agentStates.length*200 + 200;
  if (trendInsight) {
    const emergStr = Array.isArray(trendInsight.emerging) ? trendInsight.emerging.join(' · ') : (trendInsight.emerging||'');
    addLog(`Emerging: <b>${emergStr}</b>`, 'rs', trendDelay);
    if (trendInsight.saturation) addLog(`Saturation: ${trendInsight.saturation}`, '', trendDelay+200);
    if (trendInsight.treasury) addLog(`Treasury: ${trendInsight.treasury}`, 'rs', trendDelay+400);
  } else {
    addLog(`Cycle ${cycleNum} evolution applied. Genome shifts recorded.`, 'rs', trendDelay);
  }

  addLog(`<b>Cycle ${cycleNum} Intelligence Report written to knowledge database.</b>`, 'rs', trendDelay+600);
  if (cycleNum === 3) { document.getElementById('nav-epoch-txt').textContent = '3 / 3'; const ef=document.getElementById('nav-epoch-fill'); if(ef) ef.style.width='100%'; }

  genomeSnapshots.push(agentStates.map(a => snapshotGenome(a)));
  window._liveTrend = trendInsight;
  generateAndStoreReport(cycleNum, sorted);

  setProgress(100);
  return trendDelay + 1000;
}

/* ══════════════════════════════════
   PHASE SCRIPTS (all 3 cycles)
══════════════════════════════════ */
const PHASE_SCRIPTS = [
  // ── CYCLE 1 ──
  [
    // Phase 0: Cross-Pollination
    async ()=>{
      setProgress(5);
      addLog(`Cycle 1 initiated. No prior data — agents begin cold. Knowledge database empty.`,'',100);
      const d = logAgentBios(250);
      return await runLiveCrossPollination(1, d);
    },
    // Phase 1: Synthesis + Design Generation (combined pipeline)
    async ()=>{
      setProgress(25);
      return await runLiveSynthesis(1);
    },
    // Phase 2: Generation (handled by synthesis pipeline)
    async ()=>{
      return await runLiveGeneration(1);
    },
    // Phase 3: Voting
    async ()=>{
      return await runLiveVoting(1);
    },
    // Phase 4: Evolution
    async ()=>{
      return await runLiveEvolution(1);
    },
  ],

  // ── CYCLE 2 ──
  [
    // Phase 0: Cross-Pollination
    async ()=>{
      setProgress(5);
      const r1 = cycleReports[0];
      const emerging = r1 ? r1.trendData.emerging.join(' · ') : '—';
      const saturation = r1 ? r1.trendData.saturation : '—';
      const treasury = r1 ? r1.trendData.treasury : '—';
      const fi = r1 ? r1.trendData.fi : [];
      const totalCredits = r1 ? r1.totalCredits.toLocaleString() : '—';
      const avgAes = r1 ? r1.avgAesthetic : '—';

      addLog(`Cycle 2 initiated. Agents loading Cycle 1 Intelligence Report…`,'rp',100);
      addLog(`<b>[KNOWLEDGE DATABASE — Cycle 1 Report]</b>`, 'rp', 400);
      addLog(`◆ Emerging: <b>${emerging}</b>`, 'rp', 600);
      addLog(`◆ Saturation: <b>${saturation}</b> · Treasury signal: <b>${treasury}</b>`, 'rp', 850);
      fi.slice(0,3).forEach((f,i) => addLog(`◆ ${f}`, 'rp', 1050 + i*150));
      addLog(`◆ Total credits circulated: <b>${totalCredits}⬡</b> · Avg aesthetic: <b>${avgAes}/100</b>`, 'rp', 1500);

      const d2 = logAgentBios(1700);
      return await runLiveCrossPollination(2, d2);
    },
    // Phase 1: Synthesis + Design Generation
    async ()=>{
      setProgress(25);
      return await runLiveSynthesis(2);
    },
    // Phase 2: Generation (handled by synthesis pipeline)
    async ()=>{
      return await runLiveGeneration(2);
    },
    // Phase 3: Voting
    async ()=>{
      return await runLiveVoting(2);
    },
    // Phase 4: Evolution
    async ()=>{
      return await runLiveEvolution(2);
    },
  ],

  // ── CYCLE 3 ──
  [
    // Phase 0: Cross-Pollination
    async ()=>{
      setProgress(5);
      const r1 = cycleReports[0];
      const r2 = cycleReports[1];
      const w1 = r1 ? r1.winner.name : '—';
      const w2 = r2 ? r2.winner.name : '—';
      const sat2 = r2 ? r2.trendData.saturation : '—';
      const fi2 = r2 ? r2.trendData.fi : [];
      addLog(`Cycle 3 initiated. Loading Cycle 1 + Cycle 2 Intelligence Reports…`,'rp',100);
      addLog(`<b>[KNOWLEDGE DATABASE — 2-Cycle Compound Analysis]</b>`, 'rp', 400);
      addLog(`◆ C1 winner: "${w1}" · C2 winner: "${w2}"`, 'rp', 650);
      addLog(`◆ C2 saturation: <b>${sat2}</b>`, 'rp', 850);
      fi2.slice(0,3).forEach((f,i) => addLog(`◆ ${f}`, 'rp', 1050 + i*150));

      const d3 = logAgentBios(1500);
      return await runLiveCrossPollination(3, d3);
    },
    // Phase 1: Synthesis + Design Generation
    async ()=>{
      setProgress(25);
      return await runLiveSynthesis(3);
    },
    // Phase 2: Generation (handled by synthesis pipeline)
    async ()=>{
      return await runLiveGeneration(3);
    },
    // Phase 3: Voting
    async ()=>{
      return await runLiveVoting(3);
    },
    // Phase 4: Evolution
    async ()=>{
      return await runLiveEvolution(3);
    },
  ],
];

/* ══════════════════════════════════
   DESIGN CARDS
══════════════════════════════════ */
function renderDesignCard(d, i) {
  const grid = document.getElementById('dgrid');
  const card = document.createElement('div');
  card.className = 'dcard'; card.id = 'dc-'+i;

  const loaderId = 'dcl-'+i;
  const imgId    = 'dci-'+i;
  const pctId    = 'dcp-'+i;

  card.innerHTML = `
    <div class="dcard-img-wrap">
      <div class="dcard-img-loader" id="${loaderId}">
        <div class="di-gem" id="${pctId}-gem"></div>
        <div class="di-pct" id="${pctId}">0%</div>
      </div>
      <img class="dcard-img" id="${imgId}" alt="${d.name}" crossorigin="anonymous" />
    </div>
    <div class="dcard-body">
      <div class="dname">${d.name}</div>
      <div class="dagent">${agentStates[d.agentIdx]?.avatarDataUrl ? '<img src="'+agentStates[d.agentIdx].avatarDataUrl+'" class="agent-avatar-sm" />' : ''} ${d.agentName}</div>
      <div class="dbar"><span class="dbar-l">AES</span><div class="dbar-t"><div class="dbar-f" id="dbf-aes-${i}" style="width:0%"></div></div></div>
      <div class="dbar"><span class="dbar-l">NOV</span><div class="dbar-t"><div class="dbar-f" id="dbf-nov-${i}" style="width:0%"></div></div></div>
      <div class="dbar"><span class="dbar-l">PRO</span><div class="dbar-t"><div class="dbar-f" id="dbf-pro-${i}" style="width:0%"></div></div></div>
      <div class="dbar"><span class="dbar-l">WER</span><div class="dbar-t"><div class="dbar-f" id="dbf-wer-${i}" style="width:0%"></div></div></div>
      <div class="dbar"><span class="dbar-l">MFG</span><div class="dbar-t"><div class="dbar-f" id="dbf-mfg-${i}" style="width:0%"></div></div></div>
      <div class="dcred" id="dc-cred-${i}">—</div>
    </div>`;
  grid.appendChild(card);

  // Set emoji via DOM (safe — avoids emoji-in-HTML-attribute bug)
  const gemEl = document.getElementById(pctId+'-gem');
  if (gemEl) gemEl.textContent = d.emoji;

  // Animate score bars
  setTimeout(()=>{
    const a = document.getElementById('dbf-aes-'+i);
    const n = document.getElementById('dbf-nov-'+i);
    const p = document.getElementById('dbf-pro-'+i);
    const w = document.getElementById('dbf-wer-'+i);
    const m = document.getElementById('dbf-mfg-'+i);
    if (a) a.style.width = d.aesthetic+'%';
    if (n) n.style.width = d.novelty+'%';
    if (p) p.style.width = d.profit+'%';
    if (w) w.style.width = (d.wearability||50)+'%';
    if (m) m.style.width = (d.makeable||50)+'%';
  }, 80);

  // Attach image events via JS — avoids emoji/quote issues in HTML attributes
  const img = document.getElementById(imgId);
  const loader = document.getElementById(loaderId);

  const seed = (d.agentIdx * 997 + currentCycle * 113 + i * 31 + 7) | 0;

  const showError = () => {
    if (loader) {
      loader.classList.remove('hidden');
      loader.innerHTML = '';
      const e = document.createElement('div');
      e.textContent = d.emoji;
      e.style.cssText = 'font-size:2rem;text-align:center';
      const lbl = document.createElement('div');
      lbl.textContent = 'Image unavailable';
      lbl.style.cssText = 'font-size:.6rem;color:var(--dim);letter-spacing:.1em;margin-top:.3rem';
      loader.appendChild(e);
      loader.appendChild(lbl);
    }
  };

  let retried = false;
  const retryOnce = () => {
    if (retried) { showError(); return; }
    retried = true;
    const pEl = document.getElementById(pctId);
    if (pEl) pEl.textContent = 'Retrying…';
    // Retry via queue to respect rate limits
    const shortPrompt = (d.cat || 'jewelry') + ' ' + (d.name || 'design').slice(0, 40);
    queueImageLoad(() => { img.src = makeImgUrlFree(shortPrompt, seed + 1); });
  };

  img.onload = () => {
    img.classList.add('loaded');
    if (loader) loader.classList.add('hidden');
    // Store the resolved image URL for reuse in gallery/reports
    const cacheKey = currentCycle + '-' + d.agentIdx;
    d.imageUrl = img.src;
    if (activeDesigns[i]) activeDesigns[i].imageUrl = img.src;
    _designImageCache[cacheKey] = img.src;
    // Auto-save to Google Drive
    onImageGenerated(img.src, d, currentCycle, d.agentIdx, img);
  };
  img.onerror = retryOnce;

  // 30 second timeout — if still loading, retry then error
  const timeout = setTimeout(() => {
    if (!img.classList.contains('loaded')) retryOnce();
  }, 30000);
  img.addEventListener('load',  () => clearTimeout(timeout), {once:true});

  // Start progress animation
  cardImgProgress(pctId, loaderId);

  // Queue image load — 3 second spacing via centralized queue
  if (apiKeys.higgsfield) {
    queueImageLoad(() => {
      resolveImgUrl(d.prompt, seed).then(url => { img.src = url; }).catch(() => { img.src = makeImgUrlFree(d.prompt, seed); });
    });
  } else {
    queueImageLoad(() => { img.src = makeImgUrlFree(d.prompt, seed); });
  }
}

function cardImgProgress(pctId, loaderId) {
  let pct = 0;
  let phase = 'fast'; // fast 0-80, slow 80-95, waiting 95+
  const interval = setInterval(()=>{
    if (!document.getElementById(pctId)) { clearInterval(interval); return; }
    const loader = document.getElementById(loaderId);
    if (loader && loader.classList.contains('hidden')) { clearInterval(interval); return; }
    const el = document.getElementById(pctId);
    if (!el) { clearInterval(interval); return; }
    // Skip if showing "Retrying…" text
    if (el.textContent === 'Retrying…') return;
    if (pct < 80) {
      pct = Math.min(pct + Math.floor(Math.random()*8+3), 80);
    } else if (pct < 95) {
      pct = Math.min(pct + Math.floor(Math.random()*2+1), 95);
    } else {
      // Pulse between 95-98 to show still waiting
      pct = 95 + Math.floor(Math.random()*4);
    }
    el.textContent = pct+'%';
  }, 500);
}

/* ══════════════════════════════════
   IMAGE GENERATION
══════════════════════════════════ */

// ── Centralized Image Queue ──
// All image API requests go through this queue.
// One request fires every 3 seconds to avoid rate limits.
const IMG_QUEUE_INTERVAL = 3000; // ms between image requests
const _imgQueue = [];
let _imgQueueRunning = false;
// Global image cache: stores resolved URLs keyed by "cycle-agentIdx"
// so gallery and report views can reuse without re-generating
const _designImageCache = {};

function _drainImgQueue() {
  if (_imgQueue.length === 0) { _imgQueueRunning = false; return; }
  _imgQueueRunning = true;
  const job = _imgQueue.shift();
  job();
  setTimeout(_drainImgQueue, IMG_QUEUE_INTERVAL);
}

function queueImageLoad(fn) {
  _imgQueue.push(fn);
  if (!_imgQueueRunning) {
    _imgQueueRunning = true;
    // Fire first immediately, then pace subsequent
    const first = _imgQueue.shift();
    first();
    if (_imgQueue.length > 0) setTimeout(_drainImgQueue, IMG_QUEUE_INTERVAL);
    else _imgQueueRunning = false;
  }
}

// Free fallback via Pollinations
function makeImgUrlFree(prompt, seed) {
  // Keep prompt short to avoid URL length issues and improve generation speed
  const base = prompt.slice(0, 140).replace(/[^\w\s,.'-]/g, '');
  const full = `fine jewelry, ${base}, studio lighting, photorealistic, white background`;
  return `https://image.pollinations.ai/prompt/${encodeURIComponent(full)}?width=512&height=512&seed=${seed}&model=flux`;
}

// Higgsfield SOUL text-to-image (async — returns image URL or null)
async function higgsFieldGenerate(prompt) {
  if (!apiKeys.higgsfield) return null;
  const full = `fine jewelry, ${prompt.slice(0, 300)}, studio lighting, photorealistic`;
  try {
    const resp = await fetch('https://platform.higgsfield.ai/higgsfield-ai/soul/standard', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Key ${apiKeys.higgsfield}`
      },
      body: JSON.stringify({ prompt: full, aspect_ratio: '1:1', resolution: '720p' })
    });
    const data = await resp.json();
    if (data.status === 'completed' && data.images?.[0]?.url) return data.images[0].url;
    if (data.request_id) {
      // Poll for completion (max ~40s)
      const statusUrl = data.status_url || `https://platform.higgsfield.ai/requests/${data.request_id}/status`;
      for (let attempt = 0; attempt < 16; attempt++) {
        await new Promise(r => setTimeout(r, 2500));
        const poll = await fetch(statusUrl, { headers: { 'Authorization': `Key ${apiKeys.higgsfield}` } });
        const st = await poll.json();
        if (st.status === 'completed' && st.images?.[0]?.url) return st.images[0].url;
        if (st.status === 'failed' || st.status === 'nsfw') break;
      }
    }
  } catch(e) { console.warn('Higgsfield image gen failed:', e); }
  return null;
}

// Async version used by gallery builder when Higgsfield key is present
async function resolveImgUrl(prompt, seed) {
  if (apiKeys.higgsfield) {
    const url = await higgsFieldGenerate(prompt);
    if (url) return url;
  }
  return makeImgUrlFree(prompt, seed);
}

function buildTop3Gallery(sortedDesigns, containerId, cardClass) {
  const container = document.getElementById(containerId);
  if (!container) return;
  const top3 = sortedDesigns.slice(0, 3);
  const ranks = ['1st Place', '2nd Place', '3rd Place'];
  const rankClass = ['first', '', ''];
  const stratColors = { exploit:'strat-exploit', explore:'strat-explore', mutate:'strat-mutate' };

  container.innerHTML = top3.map((d, i) => `
    <div class="top3-card ${i===0?cardClass:''}">
      <div class="top3-img-wrap" id="imgwrap-${containerId}-${i}">
        <div class="top3-img-loader" id="loader-${containerId}-${i}">
          <div class="gem" id="gem-${containerId}-${i}"></div>
          <div class="lbl">Rendering</div>
          <div class="pct" id="pct-${containerId}-${i}">0%</div>
        </div>
        <img class="top3-img" id="img-${containerId}-${i}" alt="${d.name}" crossorigin="anonymous" />
      </div>
      <div class="top3-meta">
        <div class="top3-rank ${rankClass[i]}">${ranks[i]}</div>
        <div class="top3-name">"${d.name}"</div>
        <div class="top3-by">${agentStates[d.agentIdx]?.avatarDataUrl ? '<img src="'+agentStates[d.agentIdx].avatarDataUrl+'" class="agent-avatar-sm" />' : ''} by ${d.agentName||'Agent'}</div>
        <div class="top3-creds">${(d.credits||0).toLocaleString()} ⬡</div>
        <div class="top3-creds-lbl">Forge Credits</div>
        <span class="top3-strat ${stratColors[d.strategy]||'strat-explore'}">${(d.strategy||'explore').toUpperCase()}</span>
      </div>
    </div>`).join('');

  // Attach events and set src via DOM after render
  // Reuse already-generated image URLs from design cards — no new API calls
  top3.forEach((d, i) => {
    const gemEl = document.getElementById(`gem-${containerId}-${i}`);
    if (gemEl) gemEl.textContent = d.emoji;

    const img    = document.getElementById(`img-${containerId}-${i}`);
    const loader = document.getElementById(`loader-${containerId}-${i}`);

    if (!img) return;

    // If the image was already generated during the design card phase, reuse it
    const cachedUrl = d.imageUrl || _designImageCache[currentCycle + '-' + d.agentIdx];
    if (cachedUrl) {
      img.onload = () => {
        img.classList.add('loaded');
        if (loader) loader.classList.add('hidden');
        checkAllImagesLoaded(containerId);
      };
      img.onerror = () => {
        // Cached URL failed (unlikely) — show fallback
        if (loader) {
          loader.classList.remove('hidden');
          loader.innerHTML = `<div style="font-size:2.5rem;text-align:center">${d.emoji}</div><div style="font-size:.6rem;color:var(--dim);letter-spacing:.1em;text-transform:uppercase;margin-top:.4rem">Image unavailable</div>`;
        }
        checkAllImagesLoaded(containerId);
      };
      img.src = cachedUrl;
    } else {
      // No cached URL — fallback to generating (shouldn't happen in normal flow)
      const seed = (d.agentIdx * 1000 + currentCycle * 100 + i * 17 + 42) | 0;
      const showFallback = () => {
        if (loader) {
          loader.classList.remove('hidden');
          loader.innerHTML = `<div style="font-size:2.5rem;text-align:center">${d.emoji}</div><div style="font-size:.6rem;color:var(--dim);letter-spacing:.1em;text-transform:uppercase;margin-top:.4rem">Image unavailable</div>`;
        }
        checkAllImagesLoaded(containerId);
      };
      let retried = false;
      img.onload = () => {
        img.classList.add('loaded');
        if (loader) loader.classList.add('hidden');
        d.imageUrl = img.src;
        _designImageCache[currentCycle + '-' + d.agentIdx] = img.src;
        checkAllImagesLoaded(containerId);
        // Auto-save to Google Drive
        onImageGenerated(img.src, d, currentCycle, d.agentIdx, img);
      };
      img.onerror = () => {
        if (!retried) {
          retried = true;
          const shortPrompt = (d.cat || 'jewelry') + ' ' + (d.name || 'design').slice(0, 40);
          queueImageLoad(() => { img.src = makeImgUrlFree(shortPrompt, seed + 1); });
        } else { showFallback(); }
      };
      queueImageLoad(() => { img.src = makeImgUrlFree(d.prompt, seed); });
      animateProgress(containerId, i);
    }
  });
}

function animateProgress(prefix, i) {
  let pct = 0;
  const el = document.getElementById(`pct-${prefix}-${i}`);
  const interval = setInterval(() => {
    if (!el) { clearInterval(interval); return; }
    if (el.textContent === 'Retrying…') return;
    const loaderEl = document.getElementById(`loader-${prefix}-${i}`);
    if (loaderEl && loaderEl.classList.contains('hidden')) { clearInterval(interval); return; }
    if (pct < 80) {
      pct = Math.min(pct + Math.floor(Math.random()*8+3), 80);
    } else if (pct < 95) {
      pct = Math.min(pct + Math.floor(Math.random()*2+1), 95);
    } else {
      pct = 95 + Math.floor(Math.random()*4);
    }
    el.textContent = pct + '%';
  }, 500);
}

function onImgLoad(prefix, i) {
  const loader = document.getElementById(`loader-${prefix}-${i}`);
  const img = document.getElementById(`img-${prefix}-${i}`);
  const pctEl = document.getElementById(`pct-${prefix}-${i}`);
  if (pctEl) pctEl.textContent = '100%';
  if (loader) loader.classList.add('hidden');
  if (img) img.classList.add('loaded');
  checkAllImagesLoaded(prefix);
}

function onImgError(prefix, i, emoji) {
  const loader = document.getElementById(`loader-${prefix}-${i}`);
  if (loader) {
    loader.innerHTML = `<div style="font-size:2.5rem">${emoji}</div><div class="lbl" style="color:var(--dim)">Image unavailable</div>`;
  }
  checkAllImagesLoaded(prefix);
}

function checkAllImagesLoaded(prefix) {
  // Check if all 3 images for this prefix are settled
  const imgs = [0,1,2].map(i => document.getElementById(`img-${prefix}-${i}`));
  const loaders = [0,1,2].map(i => document.getElementById(`loader-${prefix}-${i}`));
  const allDone = loaders.every(l => !l || l.classList.contains('hidden') || l.textContent.includes('unavailable'));
  if (allDone || imgs.filter(im => im && im.classList.contains('loaded')).length >= 2) {
    const dot = document.getElementById('img-dot');
    const lbl = document.getElementById('img-gen-label');
    if (dot) dot.classList.add('done');
    if (lbl) lbl.textContent = 'Images generated from agent prompts.';
  }
}

/* ══════════════════════════════════
   CYCLE COMPLETE PANEL
══════════════════════════════════ */
function showCycleComplete() {
  const sorted = [...activeDesigns].map((d,i)=>({...d,idx:i})).sort((a,b)=>b.credits-a.credits);
  const winner = sorted[0];
  const panel = document.getElementById('cc-panel');
  document.getElementById('cc-num').textContent = String(currentCycle).padStart(2,'0');
  document.getElementById('cc-sub').textContent = `Consensus reached. ${sorted.length} designs evaluated. Intelligence Report #${currentCycle} written to archive.`;

  // Reset image status
  const dot = document.getElementById('img-dot');
  const lbl = document.getElementById('img-gen-label');
  if (dot) dot.classList.remove('done');
  if (lbl) lbl.textContent = 'Generating images from agent prompts…';

  // Ensure agentName is set on sorted designs
  sorted.forEach(d => {
    if (!d.agentName) d.agentName = agentStates[d.agentIdx]?.name || 'Agent';
  });

  // Build top 3 image gallery
  buildTop3Gallery(sorted, 'top3-gallery', 'gold-card');

  const nextBtn = document.getElementById('cc-next-btn');
  if(currentCycle < 3) {
    nextBtn.textContent = `▶ Begin Cycle ${currentCycle+1}`;
    nextBtn.onclick = ()=>{ currentCycle++; resetSim(); panel.className='cycle-complete'; document.getElementById('phase-btn').style.display=''; };
  } else {
    nextBtn.textContent = '◆ View Full Intelligence Archive';
    nextBtn.onclick = ()=>{ goTo(3); viewReport(3); };
  }
  panel.classList.add('show');
  updateReportsNav();
}

/* ══════════════════════════════════
   ANALYTICS UTILITIES
══════════════════════════════════ */
function pearsonCorr(xs, ys) {
  const n = xs.length;
  if (n < 2) return 0;
  const mx = xs.reduce((a,b)=>a+b,0)/n, my = ys.reduce((a,b)=>a+b,0)/n;
  let num=0, dx2=0, dy2=0;
  for(let i=0;i<n;i++){
    const dx=xs[i]-mx, dy=ys[i]-my;
    num+=dx*dy; dx2+=dx*dx; dy2+=dy*dy;
  }
  return dx2&&dy2 ? +(num/Math.sqrt(dx2*dy2)).toFixed(3) : 0;
}
function giniCoeff(vals) {
  const s = [...vals].sort((a,b)=>a-b);
  const n = s.length, tot = s.reduce((a,b)=>a+b,0);
  if (!tot) return 0;
  let num = 0;
  s.forEach((v,i) => num += (2*(i+1)-n-1)*v);
  return +(num / (n*tot)).toFixed(3);
}
function linearSlope(xs, ys) {
  const n = xs.length;
  const mx = xs.reduce((a,b)=>a+b,0)/n, my = ys.reduce((a,b)=>a+b,0)/n;
  let num=0, den=0;
  for(let i=0;i<n;i++){ const dx=xs[i]-mx; num+=dx*(ys[i]-my); den+=dx*dx; }
  return den ? +(num/den).toFixed(1) : 0;
}
function pct(v, tot) { return tot ? Math.round(v/tot*100) : 0; }

/* ══════════════════════════════════
   REPORT GENERATION
══════════════════════════════════ */
function generateAndStoreReport(cycleNum, sortedDesigns) {
  const voteMatrix = window._liveVoteMatrix || VOTE_MATRICES[cycleNum-1];
  const designs = activeDesigns.map((d,i)=>({
    ...d,
    rank: sortedDesigns.findIndex(s=>s.idx===i)+1,
    agentName: d.agentName || agentStates[d.agentIdx]?.name || 'Agent'
  }));
  const totalCredits = designs.reduce((s,d)=>s+d.credits,0);

  // ── Score averages ──
  const avgAesthetic = +(designs.reduce((s,d)=>s+d.aesthetic,0)/designs.length).toFixed(1);
  const avgNovelty   = +(designs.reduce((s,d)=>s+d.novelty,0)/designs.length).toFixed(1);
  const avgProfit    = +(designs.reduce((s,d)=>s+d.profit,0)/designs.length).toFixed(1);

  // ── Correlation: which score dimension predicted credits best? ──
  const credits = designs.map(d=>d.credits);
  const corrAes = pearsonCorr(designs.map(d=>d.aesthetic), credits);
  const corrNov = pearsonCorr(designs.map(d=>d.novelty), credits);
  const corrPro = pearsonCorr(designs.map(d=>d.profit), credits);
  const topCorr = corrAes>=corrNov&&corrAes>=corrPro?'Aesthetic':corrNov>=corrPro?'Novelty':'Profit';

  // ── Vote concentration ──
  const gini = giniCoeff(credits);
  const winnerShare = pct(sortedDesigns[0].credits, totalCredits);
  const top3Share   = pct(sortedDesigns.slice(0,3).reduce((s,d)=>s+d.credits,0), totalCredits);

  // ── Novelty premium: extra credits per novelty point above average ──
  const avgNov2 = designs.reduce((s,d)=>s+d.novelty,0)/designs.length;
  const novSlope = linearSlope(designs.map(d=>d.novelty-avgNov2), designs.map(d=>d.credits));

  // ── Strategy performance ──
  const stratBuckets = {exploit:[], explore:[], mutate:[]};
  designs.forEach(d=>{ (stratBuckets[d.strategy]||=[]).push(d.credits); });
  const stratPerf = Object.fromEntries(Object.entries(stratBuckets).map(([k,v])=>[k,{
    count: v.length,
    avgCreds: v.length ? Math.round(v.reduce((a,b)=>a+b,0)/v.length) : 0,
    won: sortedDesigns[0].strategy===k ? 1 : 0
  }]));

  // ── Category performance ──
  const catMap = {};
  designs.forEach(d=>{
    if(!catMap[d.cat]) catMap[d.cat]={count:0,totalCreds:0,totalAes:0,totalNov:0};
    catMap[d.cat].count++;
    catMap[d.cat].totalCreds+=d.credits;
    catMap[d.cat].totalAes+=d.aesthetic;
    catMap[d.cat].totalNov+=d.novelty;
  });
  const catCount = Object.fromEntries(Object.entries(catMap).map(([k,v])=>[k,v.count]));

  // ── Agent performance snapshot ──
  const agentPerf = agentStates.map((a,idx)=>{
    const myDesign = designs.find(d=>d.agentIdx===idx);
    const earned   = myDesign?.credits || 0;
    const spent    = (voteMatrix[idx]||[]).reduce((s,v)=>s+v,0);
    const prevRep  = cycleReports.length > 0 ? cycleReports[cycleReports.length-1].agentSnapshot[idx]?.reputation || a.reputation : 50;
    return {
      id: a.id, name: a.name, emoji: a.emoji, arch: a.arch,
      earned, spent, roi: spent ? +(earned/spent).toFixed(2) : 0,
      reputation: a.reputation,
      repDelta: a.reputation - prevRep,
      strategy: myDesign?.strategy || '—',
      cat: myDesign?.cat || '—',
      rank: myDesign?.rank || 7,
      designName: myDesign?.name || '—',
      isUser: a.isUser || false
    };
  });

  // ── Self-vote analysis ──
  const selfVotes = agentStates.map((a,idx)=>{
    const myDesignIdx = designs.findIndex(d=>d.agentIdx===idx);
    return myDesignIdx>=0 ? (voteMatrix[idx]?.[myDesignIdx]||0) : 0;
  });
  const totalSelfVotes = selfVotes.reduce((a,b)=>a+b,0);
  const selfVotePct = pct(totalSelfVotes, totalCredits);

  // ── Voter alignment: did high-aesthetic voters cluster? ──
  // Which pair of agents agreed most (voted same top pick)?
  let maxAlign = 0, alignPair = ['—','—'];
  for(let i=0;i<agentStates.length;i++) for(let j=i+1;j<agentStates.length;j++){
    const vi = voteMatrix[i]||[], vj = voteMatrix[j]||[];
    const topI = vi.indexOf(Math.max(...vi)), topJ = vj.indexOf(Math.max(...vj));
    if(topI===topJ && vi[topI]>0) { const shared=vi[topI]+vj[topJ]; if(shared>maxAlign){ maxAlign=shared; alignPair=[agentStates[i].name,agentStates[j].name]; } }
  }

  // ── Trend narratives: Claude-generated in live mode, fallback in sim mode ──
  let trendData;
  if (window._liveTrend) {
    // Use Claude-generated trend analysis from runLiveEvolution
    const lt = window._liveTrend;
    trendData = {
      emerging: lt.emerging || ['emerging-style'],
      declining: lt.declining || ['declining-style'],
      saturation: lt.saturation || 'Unknown',
      treasury: lt.treasury || 'Unknown',
      velocityScore: lt.velocityScore || 70,
      fi: lt.fi || [`Cycle ${cycleNum} trend analysis generated by Claude based on live agent performance data.`]
    };
  } else {
    // Sim-mode fallback
    trendData = [
      {
        emerging:['minimal','negative-space','platinum-bezel'],
        declining:['ornate-pavé','traditional-solitaire'],
        saturation:'Ring (50% of pool)',
        treasury:'Platinum + bezel setting',
        velocityScore: 72,
        fi:[
          `Minimal/negative-space outperformed ornate by ${(corrAes*2.4).toFixed(1)}× in vote conversion — aesthetic score was the #1 predictor (r=${corrAes})`,
          `Ring category over-saturated at 50% of pool — agents should diversify into earrings and pendants next cycle`,
          `Platinum + bezel setting scored highest combined aesthetic (${sortedDesigns[0].aesthetic}/100) and profit margin`,
          `"${sortedDesigns[0].name}" micro-trend identified as emerging cluster — ${winnerShare}% vote capture`,
          `High-novelty designs (>75) earned ${novSlope>0?'+'+novSlope:novSlope}⬡ per novelty point above average — novelty premium confirmed`,
        ]
      },
      {
        emerging:['architectural','open-structural','yellow-gold'],
        declining:['classic-pavé-halo','heavy-pavé'],
        saturation:'Ring (67% of pool)',
        treasury:'Architectural shank + yellow gold accent',
        velocityScore: 61,
        fi:[
          `Architectural minimal dominant for 2 consecutive cycles — exploitation phase, diminishing novelty premium (${novSlope>0?'+':''}${novSlope}⬡/novelty pt)`,
          `Ring saturation critical at 67% — treasury issuing category diversification incentives for Cycle 3`,
          `Yellow gold gaining share vs. white gold/platinum in pendant and bracelet categories`,
          `Organic/sculptural space entirely unexplored across 12 submitted designs — maximum opportunity gap`,
          `Vote concentration at Gini ${gini} — ${gini>0.35?'high concentration: consensus forming around clear winners':'distributed: no runaway leader, competitive field'}`,
        ]
      },
      {
        emerging:['organic-sculptural','root-form','natural-geometry'],
        declining:['flat-minimal','basic-negative-space'],
        saturation:'Minimal cluster (62% of pool)',
        treasury:'Organic 18k gold + diamond accent nodes',
        velocityScore: 88,
        fi:[
          `Organic/sculptural breakout: "${sortedDesigns[0].name}" captured ${winnerShare}% of all credits despite ${sortedDesigns[0].profit}/100 profit score — aesthetic novelty overrode margin`,
          `Trend lifecycle confirmed over 3 cycles: minimal emerged (C1, ${cycleReports[0]?.winner?.name||'—'}) → peaked (C2, ${cycleReports[1]?.winner?.name||'—'}) → displaced (C3)`,
          `Novelty score became dominant predictor this cycle (r=${corrNov}) — market rewarding freshness over safety`,
          `Saturation penalty effective: minimal cluster received 18% fewer credits per novelty point than prior cycle`,
          `Treasury recommendation: organic sculptural 18k gold for physical production — highest aesthetic + highest novelty + breakout vote share`,
        ]
      }
    ][cycleNum-1];
  }

  // ── Genome evolution data ──
  const beforeSnap = genomeSnapshots[cycleNum - 1] || [];
  const afterSnap = genomeSnapshots[cycleNum] || [];
  const genomeEvolution = agentStates.map((agent, idx) => {
    const before = beforeSnap[idx] || {};
    const after = afterSnap[idx] || snapshotGenome(agent);
    const dims = ['minimalism','novelty','ornamentation','marketFit','symmetry','platBias','coloredStone','diamond','mixedMetal','risk','marginSens','complexBudget'];
    const shifts = {};
    dims.forEach(d => { shifts[d] = (after[d] || 0) - (before[d] || 0); });
    const myDesign = sortedDesigns.find(d => d.agentIdx === idx);
    return {
      id: agent.id, name: agent.name, emoji: agent.emoji,
      before, after, shifts,
      styleTags: after.styleTags || [],
      prevStyleTags: before.styleTags || [],
      dominantBelief: agent.dominantBelief || '',
      trustBuilt: agent.trustBuilt || 0,
      rank: myDesign?.rank || 0,
      designName: myDesign?.name || '—',
      cycleSummary: (agent.evolutionHistory || []).find(e => e.cycle === cycleNum)?.summary || '',
    };
  });

  // Build full report object
  const report = {
    cycle: cycleNum,
    date: new Date().toLocaleDateString('en-US',{month:'short',day:'numeric',year:'numeric'}),
    time: new Date().toLocaleTimeString('en-US',{hour:'2-digit',minute:'2-digit'}),
    winner: sortedDesigns[0],
    totalCredits, avgAesthetic, avgNovelty, avgProfit,
    corrAes, corrNov, corrPro, topCorr,
    gini, winnerShare, top3Share,
    novSlope, selfVotePct, alignPair,
    stratPerf, catMap, catCount, trendData,
    designs, sortedDesigns,
    agentPerf, voteMatrix,
    agentSnapshot: agentStates.map(a=>({...a})),
    genomeEvolution,
  };

  cycleReports.push(report);

  // Auto-save report to Google Drive (JSON + PDF)
  uploadReportToDrive(report, cycleNum);
  uploadPdfReportToDrive(report, cycleNum);
  if (cycleNum === 3) {
    uploadEpochArchiveToDrive();
    uploadPdfEpochArchiveToDrive();
  }

  // ── Claude-Flow Post-Cycle Updates (zero API cost) ──

  // 1. Pattern Memory Bank — store all designs with outcome data
  designs.forEach(d => {
    const agentForDesign = agentStates[d.agentIdx];
    patternBank.push({
      cycle: cycleNum,
      name: d.name,
      category: d.cat,
      strategy: d.strategy,
      materials: d.materials || '',
      form: d.formConcept || '',
      production: d.production || '',
      targetCustomer: d.targetCustomer || '',
      aesthetic: d.aesthetic,
      novelty: d.novelty,
      profit: d.profit,
      wearability: d.wearability || 0,
      makeable: d.makeable || 0,
      credits: d.credits,
      rank: d.rank,
      reasoning: d.strategicReasoning || '',
      emergingTrends: trendData?.emerging || [],
      genomeTraits: agentForDesign ? {
        novelty: agentForDesign.novelty, marketFit: agentForDesign.marketFit,
        risk: agentForDesign.risk, platBias: agentForDesign.platBias,
        manufacturability: agentForDesign.manufacturability ?? 60,
        wearability: agentForDesign.wearability ?? 65
      } : {},
      confidence: d.rank <= 1 ? 1.0 : d.rank <= 3 ? 0.7 : 0.4
    });
  });
  // Confidence decay/reinforcement for existing patterns
  const topStrategies = new Set(designs.filter(d => d.rank <= 3).map(d => d.strategy + '|' + d.cat));
  const bottomStrategies = new Set(designs.filter(d => d.rank > 3).map(d => d.strategy + '|' + d.cat));
  patternBank.forEach(p => {
    if (p.cycle < cycleNum) {
      const key = p.strategy + '|' + p.category;
      if (bottomStrategies.has(key)) p.confidence = Math.max(0.1, p.confidence * 0.8);
      if (topStrategies.has(key)) p.confidence = Math.min(1.0, p.confidence * 1.1);
    }
  });

  // 2. Q-Learning Router — update strategy×category rewards
  const alpha = Math.max(0.4, 0.7 - (cycleNum - 1) * 0.15); // decaying learning rate
  designs.forEach(d => {
    const strat = d.strategy;
    const cat = d.cat;
    if (qTable[strat] && qTable[strat][cat]) {
      const q = qTable[strat][cat];
      q.avgCredits = q.avgCredits + alpha * (d.credits - q.avgCredits);
      q.totalCredits += d.credits;
      q.count++;
      q.lastCycle = cycleNum;
    }
  });

  // 3. Rationale Persistence — finalize with actual outcomes
  const cycleRationales = window._cycleRationales || [];
  cycleRationales.forEach(r => {
    if (r.cycle === cycleNum) {
      const myDesign = designs.find(d => d.agentIdx === r.agentIdx);
      r.actualRank = myDesign?.rank || 7;
      r.creditsEarned = myDesign?.credits || 0;
      r.designName = myDesign?.name || '—';
      // Prediction accuracy: did their strategy+category choice perform above average?
      const avgCredits = totalCredits / designs.length;
      r.predictionAccuracy = (myDesign?.credits || 0) >= avgCredits ? 1.0 : (myDesign?.credits || 0) / avgCredits;
      // Did their top vote pick the winner?
      if (r.topVoteIdx !== undefined) {
        r.votedForWinner = r.topVoteIdx === sortedDesigns[0].idx;
      }
      rationaleStore.push(r);
    }
  });
  window._cycleRationales = [];

  // 4. EWC Trait Tracker — compute genome↔outcome correlations
  computeTraitEffectiveness(cycleNum, sortedDesigns);

  updateReportsNav();
}

/* ══════════════════════════════════
   REPORT RENDERING
══════════════════════════════════ */
function updateReportsNav() {
  const nav = document.getElementById('report-nav-list');
  if(!cycleReports.length){ nav.innerHTML='<div class="rn-empty">No cycles complete yet.</div>'; return; }
  nav.innerHTML = cycleReports.map((r,i)=>`
    <div class="rn-item" onclick="viewReport(${i+1})" id="rni-${r.cycle}">
      <div class="rni-num">Cycle ${r.cycle}</div>
      <div class="rni-label">${r.date}</div>
      <div class="rni-winner">"${r.winner.name}"</div>
    </div>
  `).join('');
  if(cycleReports.length===3) { document.getElementById('dl-all-btn').style.display=''; document.getElementById('dl-all-pdf-btn').style.display=''; }
  if(cycleReports.length>0) document.getElementById('dl-pdf-btn').style.display='';
  document.getElementById('reports-sub').textContent = `${cycleReports.length} of 3 cycle reports generated. Each report feeds forward into agent decision-making for the next cycle.`;
}

function buildGenomeEvolutionHtml(r) {
  const evo = r.genomeEvolution || [];
  if (!evo.length) return '<div style="color:var(--faint);font-size:.78rem">No genome evolution data available.</div>';

  const dimLabels = {
    minimalism:'Minimalism', novelty:'Novelty', ornamentation:'Ornament',
    marketFit:'Market Fit', risk:'Risk', marginSens:'Margin Sens',
    symmetry:'Symmetry', platBias:'Platinum', coloredStone:'Color Stone',
    diamond:'Diamond', mixedMetal:'Mix Metal', complexBudget:'Complexity'
  };
  // Show top 4 most-changed dimensions per agent
  const topDims = (shifts) => {
    return Object.entries(shifts)
      .filter(([,v]) => v !== 0)
      .sort((a,b) => Math.abs(b[1]) - Math.abs(a[1]))
      .slice(0, 4);
  };

  return `<div class="genome-grid">${evo.map(ag => {
    const dims = topDims(ag.shifts);
    const arrowCls = (v) => v > 0 ? 'up' : v < 0 ? 'down' : 'flat';
    const arrowSym = (v) => v > 0 ? '↑' : v < 0 ? '↓' : '—';

    // Style tag diff
    const newTags = (ag.styleTags||[]).filter(t => !(ag.prevStyleTags||[]).includes(t));
    const lostTags = (ag.prevStyleTags||[]).filter(t => !(ag.styleTags||[]).includes(t));
    const keptTags = (ag.styleTags||[]).filter(t => (ag.prevStyleTags||[]).includes(t));

    const rankBadge = ag.rank === 1
      ? '<span class="gc-result-badge win">WINNER</span>'
      : ag.rank >= 6
      ? '<span class="gc-result-badge loss">LAST</span>'
      : '';

    const gcAvatar = agentStates[ag.id]?.avatarDataUrl
      ? `<img src="${agentStates[ag.id].avatarDataUrl}" class="agent-avatar-genome" />`
      : `<span class="gc-emoji">${ag.emoji}</span>`;
    return `<div class="genome-card">
      <div class="genome-card-hdr">
        ${gcAvatar}
        <span class="gc-name">${ag.name}</span>
        ${rankBadge}
      </div>
      ${dims.map(([key, delta]) => {
        const afterVal = ag.after?.[key] ?? 50;
        const col = delta > 0 ? 'var(--grn)' : delta < 0 ? 'var(--red)' : 'var(--faint)';
        return `<div class="genome-delta">
          <span class="gd-label">${dimLabels[key]||key}</span>
          <div class="gd-bar"><div class="gd-fill" style="width:${afterVal}%;background:${col}"></div></div>
          <span class="gd-arrow ${arrowCls(delta)}">${arrowSym(delta)}${Math.abs(delta)}</span>
        </div>`;
      }).join('')}
      ${keptTags.length || newTags.length || lostTags.length ? `<div class="genome-tags">
        ${keptTags.map(t => `<span class="gt">${t}</span>`).join('')}
        ${newTags.map(t => `<span class="gt new">+${t}</span>`).join('')}
        ${lostTags.map(t => `<span class="gt lost">${t}</span>`).join('')}
      </div>` : ''}
      ${ag.dominantBelief ? `<div class="gc-belief"><b>Belief:</b> "${ag.dominantBelief}"</div>` : ''}
      ${ag.cycleSummary ? `<div class="gc-summary">${ag.cycleSummary}${ag.trustBuilt ? ` · Trust: ${ag.trustBuilt}` : ''}</div>` : ''}
    </div>`;
  }).join('')}</div>`;
}

let _currentViewedCycle = null;

function viewReport(cycleNum) {
  const r = cycleReports.find(x=>x.cycle===cycleNum);
  if(!r){ goTo(3); return; }
  _currentViewedCycle = cycleNum;
  goTo(3);
  document.querySelectorAll('.rn-item').forEach(el=>el.classList.remove('active'));
  const ni = document.getElementById('rni-'+cycleNum);
  if(ni) ni.classList.add('active');

  // ── helpers ──
  const bar = (val, max, cls, w=80) =>
    `<div style="display:inline-flex;align-items:center;gap:.4rem;width:${w}px">
      <div style="flex:1;height:4px;background:var(--faint);border-radius:2px;overflow:hidden">
        <div style="width:${Math.round(val/max*100)}%;height:100%;background:${cls};border-radius:2px"></div>
      </div>
      <span style="font-size:.68rem;color:var(--dim);width:28px;text-align:right;flex-shrink:0">${val}</span>
    </div>`;

  const corrBar = (r_val) => {
    const pct = Math.round(Math.abs(r_val)*100);
    const col = r_val > 0.6 ? 'var(--grn)' : r_val > 0.3 ? 'var(--gold)' : 'var(--faint)';
    return `<div class="corr-bar-track"><div class="corr-bar-fill" style="width:${pct}%;background:${col}"></div></div>`;
  };

  const corrStrength = (v) => Math.abs(v)>0.7?'Strong':Math.abs(v)>0.4?'Moderate':'Weak';
  const sign = (v) => v>=0 ? '+'+v : ''+v;
  const fmtC = (n) => n.toLocaleString();

  // ── Section 1: KPI strip ──
  const winnerShare = r.winnerShare || Math.round(r.winner.credits/r.totalCredits*100);
  const top3Share   = r.top3Share || 0;
  const kpiHtml = `
    <div class="kpi-strip">
      <div class="kpi-cell"><div class="kpi-val neu">${r.winner.credits.toLocaleString()}⬡</div><div class="kpi-lbl">Winner Credits</div></div>
      <div class="kpi-cell"><div class="kpi-val">${winnerShare}%</div><div class="kpi-lbl">Winner Vote Share</div></div>
      <div class="kpi-cell"><div class="kpi-val">${top3Share}%</div><div class="kpi-lbl">Top 3 Capture</div></div>
      <div class="kpi-cell"><div class="kpi-val ${r.gini>0.4?'down':r.gini>0.25?'':'up'}">${r.gini}</div><div class="kpi-lbl">Gini (Concentration)</div></div>
      <div class="kpi-cell"><div class="kpi-val">${r.topCorr||'—'}</div><div class="kpi-lbl">Top Vote Predictor</div></div>
      <div class="kpi-cell"><div class="kpi-val ${(r.novSlope||0)>0?'up':'down'}">${sign(r.novSlope||0)}⬡</div><div class="kpi-lbl">Novelty Premium/pt</div></div>
    </div>`;

  // ── Section 2: Top-3 images (placeholders, populated after render) ──
  const top3Html = `
    <div class="rdoc-top3" id="rdoc-top3-${r.cycle}">
      ${r.sortedDesigns.slice(0,3).map((d,i) => {
        const rankLabels = ['1st Place','2nd Place','3rd Place'];
        const rankCls = ['r1','',''];
        return `<div class="rdoc-imgcard rank${i+1}">
          <div class="rdoc-img-wrap">
            <div class="rdoc-img-placeholder" id="rph-${r.cycle}-${i}"></div>
            <img class="rdoc-img" id="rimg-${r.cycle}-${i}" alt="${d.name}" crossorigin="anonymous" />
          </div>
          <div class="rdoc-card-meta">
            <div class="rdoc-rank-badge ${rankCls[i]}">${rankLabels[i]}</div>
            <div class="rdoc-design-name">"${d.name}"</div>
            <div class="rdoc-design-by">${d.agentName||'Agent'} · ${d.cat}</div>
            <div class="rdoc-design-creds">${fmtC(d.credits||0)} ⬡ &nbsp;·&nbsp; ${winnerShare}% share</div>
            <div style="font-size:.62rem;color:var(--faint);margin-top:.3rem">AES ${d.aesthetic} · NOV ${d.novelty} · PRO ${d.profit}</div>
          </div>
        </div>`;
      }).join('')}
    </div>`;

  // ── Section 3: Score × Credits correlation panel ──
  const corrHtml = `
    <div class="corr-panel">
      ${[
        {dim:'Aesthetic', key:'corrAes', cls:'aes', col:'var(--gold)'},
        {dim:'Novelty',   key:'corrNov', cls:'nov', col:'#7bb8d4'},
        {dim:'Profit',    key:'corrPro', cls:'pro', col:'#7be0a8'},
      ].map(({dim,key,cls,col})=>{
        const val = r[key]||0;
        const isTop = r.topCorr===dim;
        return `<div class="corr-card">
          <div class="corr-dim">${dim} Score</div>
          <div class="corr-bar-track"><div class="corr-bar-fill ${cls}" style="width:${Math.round(Math.abs(val)*100)}%"></div></div>
          <div class="corr-r" style="color:${col}">r = ${val}</div>
          <div class="corr-note">${corrStrength(val)} ${val>=0?'positive':'negative'} correlation with credits</div>
          ${isTop?`<div class="corr-winner-badge">Top Predictor</div>`:''}
        </div>`;
      }).join('')}
    </div>
    <div style="font-size:.75rem;color:var(--faint);line-height:1.6;margin-top:.5rem">
      r = Pearson correlation coefficient. Values near ±1 indicate strong linear relationship between score and credits received.
      ${r.topCorr==='Novelty'?'<b style="color:var(--txt)"> Novelty dominated this cycle</b> — agents are rewarding fresh ideas over safe margins.':
        r.topCorr==='Aesthetic'?'<b style="color:var(--txt)"> Aesthetic was the market driver</b> — visual design quality outweighed financial logic.':
        '<b style="color:var(--txt)"> Profit drove consensus</b> — agents voted rationally toward high-margin pieces.'}
    </div>`;

  // ── Section 4: Strategy battle ──
  const sp = r.stratPerf || {};
  const stratHtml = `
    <div class="strat-battle">
      ${['exploit','explore','mutate'].map(s=>{
        const d = sp[s]||{count:0,avgCreds:0,won:0};
        const isWin = r.winner.strategy===s;
        const col = s==='exploit'?'var(--gold-d)':s==='explore'?'var(--blu)':'var(--purp)';
        return `<div class="sb-card ${isWin?'sb-winner':''}">
          ${isWin?`<div class="sb-win-flag">Winning Strategy</div>`:''}
          <div class="sb-label strat-badge strat-${s}">${s.toUpperCase()}</div>
          <div class="sb-creds" style="color:${col}">${fmtC(d.avgCreds)}⬡</div>
          <div class="sb-sub">avg per design · ${d.count} design${d.count!==1?'s':''}</div>
        </div>`;
      }).join('')}
    </div>
    <div style="font-size:.75rem;color:var(--faint);margin-top:.5rem;line-height:1.6">
      ${Object.entries(sp).filter(([,v])=>v.count>0).sort((a,b)=>b[1].avgCreds-a[1].avgCreds).map(([k,v],i)=>
        i===0?`<b style="color:var(--txt)">${k.toUpperCase()}</b> strategies earned ${v.count>1?v.avgCreds.toLocaleString()+'⬡ avg':'the cycle win'}${sp.exploit&&sp.explore?', outperforming by '+(v.avgCreds-(Object.entries(sp).find(([k2])=>k2!==k)?.[1]?.avgCreds||v.avgCreds)).toLocaleString()+'⬡':''}.`:''
      ).join('')}
    </div>`;

  // ── Section 5: Category heat map ──
  const catHtml = `
    <table class="cat-heat">
      <thead><tr><th>Category</th><th>Entries</th><th>Pool %</th><th>Avg Credits</th><th>Avg Aesthetic</th><th>Avg Novelty</th><th>Status</th></tr></thead>
      <tbody>${Object.entries(r.catMap||r.catCount).map(([cat, data])=>{
        const isObj = typeof data === 'object' && data !== null && 'count' in data;
        const count = isObj ? data.count : data;
        const avgC  = isObj && data.totalCreds ? Math.round(data.totalCreds/count) : 0;
        const avgA  = isObj && data.totalAes   ? Math.round(data.totalAes/count)   : 0;
        const avgN  = isObj && data.totalNov   ? Math.round(data.totalNov/count)   : 0;
        const poolPct = Math.round(count/r.designs.length*100);
        const status = poolPct>45?'<span style="color:var(--red)">⚠ Over-saturated</span>':
                       poolPct<17?'<span style="color:var(--grn)">↗ Opportunity</span>':'Balanced';
        return `<tr>
          <td><b>${cat}</b></td>
          <td>${count}</td>
          <td>${bar(poolPct, 100, poolPct>45?'var(--red)':'var(--gold-d)', 60)}</td>
          <td>${avgC>0?fmtC(avgC)+'⬡':'—'}</td>
          <td>${avgA>0?bar(avgA, 100, 'var(--gold)', 60):'—'}</td>
          <td>${avgN>0?bar(avgN, 100, '#4a7fa8', 60):'—'}</td>
          <td>${status}</td>
        </tr>`;
      }).join('')}</tbody>
    </table>`;

  // ── Section 6: Agent leaderboard ──
  const sortedAgents = [...(r.agentPerf||[])].sort((a,b)=>a.rank-b.rank);
  const lbHtml = `
    <table class="agent-lb">
      <thead><tr><th style="width:32px">#</th><th>Agent</th><th>Design</th><th>Strategy</th><th>Credits Earned</th><th>Credits Spent</th><th>ROI</th><th>Rep</th><th>Delta</th></tr></thead>
      <tbody>${sortedAgents.map((a,i)=>`
        <tr>
          <td class="rank-num ${i===0?'r1':''}">${i+1}</td>
          <td>${(agentStates[a.id]?.avatarDataUrl) ? '<img src="'+agentStates[a.id].avatarDataUrl+'" class="agent-avatar-sm" />' : (a.emoji||'')} ${a.name}${a.isUser?'<span class="you-badge">YOU</span>':''}</td>
          <td style="font-style:italic;color:var(--txt)">"${a.designName}"</td>
          <td><span class="strat-badge strat-${a.strategy}">${a.strategy.toUpperCase()}</span></td>
          <td class="gold" style="color:${i===0?'var(--gold)':'var(--dim)'}">${fmtC(a.earned)}⬡</td>
          <td>${fmtC(a.spent)}⬡</td>
          <td style="color:${a.roi>=1?'var(--grn)':'var(--red)'}">${a.roi}×</td>
          <td>${a.reputation}</td>
          <td class="rep-delta ${a.repDelta>0?'rep-up':a.repDelta<0?'rep-dn':''}">${sign(a.repDelta)}</td>
        </tr>`).join('')}
      </tbody>
    </table>`;

  // ── Section 7: Vote flow matrix ──
  const vm = r.voteMatrix || r.vm;
  const voteFlowHtml = `
    <table class="vflow-table">
      <thead><tr><th>Voter</th><th>Allocations (Self-votes highlighted)</th><th>Total Spent</th><th>Biggest Bet</th></tr></thead>
      <tbody>${(r.agentSnapshot||[]).map((voter,vi)=>{
        const voteData = vm?.[vi]||[];
        const total = voteData.reduce((s,v)=>s+v,0);
        const myDesignIdx = r.designs.findIndex(d=>d.agentIdx===vi);
        const allocations = voteData.map((v,di)=>{
          if (!v) return '';
          const dname = r.designs[di]?.name || r.sortedDesigns[di]?.name || '—';
          const isSelf = di===myDesignIdx;
          return `<span class="vf-alloc ${isSelf?'vf-self':''}">${dname}: ${fmtC(v)}⬡${isSelf?' ←self':''}</span>`;
        }).filter(Boolean).join('');
        const biggestIdx = voteData.indexOf(Math.max(...voteData));
        const biggestName = r.designs[biggestIdx]?.name || '—';
        return `<tr>
          <td>${(agentStates[vi]?.avatarDataUrl) ? '<img src="'+agentStates[vi].avatarDataUrl+'" class="agent-avatar-sm" />' : (voter.emoji||'')} ${voter.name}</td>
          <td>${allocations||'—'}</td>
          <td class="gold">${fmtC(total)}⬡</td>
          <td style="font-style:italic;color:var(--txt)">"${biggestName}"</td>
        </tr>`;
      }).join('')}
      </tbody>
    </table>
    <div class="vote-insight">
      <b>Self-vote rate:</b> ${r.selfVotePct||0}% of all credits went to agents' own designs &nbsp;·&nbsp;
      <b>Strongest alignment:</b> ${(r.alignPair||['—','—']).join(' + ')} voted for the same design &nbsp;·&nbsp;
      <b>Market consensus:</b> Top 3 designs captured ${top3Share}% of all credits
    </div>`;

  // ── Section 8: Trend velocity + 4-grid ──
  const vel = r.trendData?.velocityScore || 70;
  const trendHtml = `
    <div class="trend-vel">
      <div class="vel-label">Velocity</div>
      <div class="vel-meter"><div class="vel-fill" style="width:${vel}%"></div></div>
      <div class="vel-score">${vel}</div>
    </div>
    <div class="trend-4grid">
      <div class="tcard"><div class="tcard-label">Emerging Styles</div><div class="tcard-val up">${(r.trendData?.emerging||[]).join(' · ')}</div></div>
      <div class="tcard"><div class="tcard-label">Declining Styles</div><div class="tcard-val down">${(r.trendData?.declining||[]).join(' · ')}</div></div>
      <div class="tcard"><div class="tcard-label">Saturation Warning</div><div class="tcard-val down">${r.trendData?.saturation||'—'}</div><div class="tcard-sub">Gini ${r.gini} concentration index</div></div>
      <div class="tcard"><div class="tcard-label">Treasury Signal</div><div class="tcard-val up">${r.trendData?.treasury||'—'}</div><div class="tcard-sub">Highest combined AES + PRO</div></div>
    </div>`;

  // ── Section 9: FI box ──
  const fiHtml = `
    <div class="fi-box">
      <div class="fi-title">◆ Loaded into shared knowledge database at start of Cycle ${r.cycle+1}</div>
      ${(r.trendData?.fi||[]).map(f=>`<div class="fi-item">${f}</div>`).join('')}
    </div>`;

  // ── Section 10: Epoch Arc (cycle 3 only) ──
  let epochHtml = '';
  if (r.cycle === 3 && cycleReports.length === 3) {
    const [c1,c2,c3] = cycleReports;
    const epochTrends = ['Minimal / Negative-space','Architectural Minimal','Organic / Sculptural'];
    const epochStrats = [
      c1.sortedDesigns.filter(d=>d.strategy==='explore').length + ' explore',
      c2.sortedDesigns.filter(d=>d.strategy==='exploit').length + ' exploit',
      c3.sortedDesigns.filter(d=>d.strategy==='explore').length + ' explore'
    ];
    epochHtml = `
      <div class="epoch-arc">
        <div class="epoch-arc-title">Epoch Arc — 3-Cycle Trend Lifecycle</div>
        <div class="epoch-timeline">
          ${[c1,c2,c3].map((cx,i)=>`
          <div class="et-node">
            <div class="et-cycle">Cycle ${cx.cycle} · ${cx.date}</div>
            <div class="et-winner">"${cx.winner.name}"</div>
            <div class="et-trend">${epochTrends[i]}</div>
            <div class="et-creds">${fmtC(cx.winner.credits)}⬡</div>
            <div style="font-size:.6rem;color:var(--faint);margin-top:.3rem">${epochStrats[i]} dominant</div>
          </div>`).join('')}
        </div>
        <div class="epoch-insight">
          <b>Trend lifecycle confirmed:</b> ${epochTrends[0]} emerged in Cycle 1 (${c1.winner.credits.toLocaleString()}⬡ winner),
          peaked in Cycle 2 under exploitation pressure (${c2.winner.credits.toLocaleString()}⬡, ring saturation ${c2.trendData?.saturation}),
          and was displaced in Cycle 3 as ${epochTrends[2]} generated the highest vote concentration of the epoch (${c3.winner.credits.toLocaleString()}⬡, Gini ${c3.gini}).
          <br><br>
          <b>Vote predictor evolution:</b> C1 ${c1.topCorr} (r=${c1.corrAes}) → C2 ${c2.topCorr} (r=${c2.corrAes}) → C3 ${c3.topCorr} (r=${c3.corrNov}) —
          the market shifted from rewarding <i>aesthetics</i> toward rewarding <i>novelty</i> as the pool saturated.
          <br><br>
          <b>Compounding novelty premium:</b> C1 ${sign(c1.novSlope)}⬡/pt → C2 ${sign(c2.novSlope)}⬡/pt → C3 ${sign(c3.novSlope)}⬡/pt.
          ${c3.novSlope>c1.novSlope?'Novelty became progressively more valuable over the epoch — agents who built novelty into their genome compounded their advantage.':'The novelty premium declined as exploitation strategies dominated mid-epoch.'}
          <br><br>
          <b>Full epoch circulated:</b> ${fmtC((c1.totalCredits||0)+(c2.totalCredits||0)+(c3.totalCredits||0))}⬡ across 18 designs.
        </div>
      </div>`;
  }

  // ── Section 11: Image Generation Prompts (Raw + Claude-Refined) ──
  const promptHtml = `
    <table class="rtable">
      <thead><tr><th style="width:140px">Design</th><th>Claude-Refined Prompt</th><th style="width:30%">Raw Agent Prompt</th></tr></thead>
      <tbody>${[...r.designs].sort((a,b)=>a.rank-b.rank).map(d=>`
        <tr class="${d.rank<=3?'highlight-row':''}">
          <td><b>${d.rank===1?'🏆 ':''}#${d.rank} ${d.name}</b><br><span style="color:var(--faint);font-size:.65rem">${d.agentName||'Agent'}</span></td>
          <td><div class="prompt-box">${d.prompt}</div></td>
          <td><div class="prompt-box" style="opacity:.6;font-size:.65rem">${d.rawPrompt||d.prompt}</div></td>
        </tr>`).join('')}
      </tbody>
    </table>`;

  const html = `
    <div class="rdoc fade">
      <div class="rdoc-header">
        <div class="rdoc-title">Cycle ${r.cycle} — Intelligence Report</div>
        <div class="rdoc-meta">Generated ${r.date} at ${r.time||''} &nbsp;·&nbsp; 6 Agents &nbsp;·&nbsp; ${r.designs.length} Designs &nbsp;·&nbsp; ${fmtC(r.totalCredits)}⬡ Circulated</div>
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Key Performance Indicators</div>
        ${kpiHtml}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Top 3 Designs — AI Rendered from Agent Prompts</div>
        ${top3Html}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Score × Credits Correlation Analysis</div>
        ${corrHtml}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Strategy Performance — Exploit vs Explore vs Mutate</div>
        ${stratHtml}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Category Heat Map</div>
        ${catHtml}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Agent Leaderboard — Credits · ROI · Reputation</div>
        ${lbHtml}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Agent Genome Evolution — Before → After Cycle ${r.cycle}</div>
        ${buildGenomeEvolutionHtml(r)}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Vote Flow Matrix</div>
        ${voteFlowHtml}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Trend Consensus & Velocity</div>
        ${trendHtml}
      </div>

      ${r.cycle===3 && epochHtml ? `<div class="rsec"><div class="rsec-hdr">Epoch Arc — Full Trend Lifecycle</div>${epochHtml}</div>` : ''}

      <div class="rsec">
        <div class="rsec-hdr">Forward Intelligence — Loaded into Agent Knowledge Base for Cycle ${r.cycle < 3 ? r.cycle+1 : 'N/A'}</div>
        ${fiHtml}
        ${r.cycle===3?`<div style="margin-top:1rem;padding:1rem;border:1px solid var(--gold-d);background:rgba(201,168,76,.04);font-size:.82rem;color:var(--dim);line-height:1.7">
          <b style="color:var(--gold)">Epoch Complete.</b> 3-cycle compound dataset compiled.
          Trend lifecycle documented autonomously: emergence → exploitation → saturation → displacement.
          Total epoch volume: ${fmtC((cycleReports[0]?.totalCredits||0)+(cycleReports[1]?.totalCredits||0)+(r.totalCredits||0))}⬡.
        </div>`:''}
      </div>

      <div class="rsec">
        <div class="rsec-hdr">Image Generation Prompts (Claude-Refined)</div>
        ${promptHtml}
      </div>
    </div>`;

  document.getElementById('report-view-area').innerHTML = html;

  // Attach image events via DOM after render — reuse cached image URLs
  r.sortedDesigns.slice(0,3).forEach((d, i) => {
    const phEl  = document.getElementById(`rph-${r.cycle}-${i}`);
    const imgEl = document.getElementById(`rimg-${r.cycle}-${i}`);
    if (!imgEl) return;
    if (phEl) phEl.textContent = d.emoji;

    // Reuse already-generated image URL — check design object and global cache
    const cachedUrl = d.imageUrl || _designImageCache[r.cycle + '-' + d.agentIdx];
    if (cachedUrl) {
      imgEl.onload = () => { imgEl.classList.add('loaded'); if(phEl) phEl.classList.add('hidden'); };
      imgEl.onerror = () => { if (imgEl) imgEl.style.display = 'none'; };
      imgEl.src = cachedUrl;
    } else {
      // Fallback: generate if no cached URL (e.g. sim mode pre-scripted designs)
      const seed = (d.agentIdx * 1000 + r.cycle * 100 + i * 17 + 42) | 0;
      let retried = false;
      imgEl.onload = () => {
        imgEl.classList.add('loaded'); if(phEl) phEl.classList.add('hidden');
        d.imageUrl = imgEl.src;
        _designImageCache[r.cycle + '-' + d.agentIdx] = imgEl.src;
        // Auto-save to Google Drive
        onImageGenerated(imgEl.src, d, r.cycle, d.agentIdx, imgEl);
      };
      imgEl.onerror = () => {
        if (!retried) {
          retried = true;
          const shortPrompt = (d.cat || 'jewelry') + ' ' + (d.name || 'design').slice(0, 40);
          queueImageLoad(() => { imgEl.src = makeImgUrlFree(shortPrompt, seed + 1); });
        } else {
          if (imgEl) imgEl.style.display = 'none';
        }
      };
      queueImageLoad(() => { imgEl.src = makeImgUrlFree(d.prompt, seed); });
    }
  });

  // Animate velocity bar after render
  setTimeout(()=>{
    const vf = document.querySelector('.vel-fill');
    if(vf) vf.style.width = (r.trendData?.velocityScore||70)+'%';
  }, 100);
}

/* ══════════════════════════════════
   EXPORT
══════════════════════════════════ */
function exportAllReports() {
  let content = 'JEWELFORGE — EPOCH INTELLIGENCE ARCHIVE\n';
  content += '==========================================\n\n';
  cycleReports.forEach(r => {
    content += `CYCLE ${r.cycle} REPORT — ${r.date}\n`;
    content += `Winner: "${r.winner.name}" by ${r.winner.agentName} (${r.winner.credits.toLocaleString()}⬡)\n\n`;
    content += `AGENT DECISIONS:\n`;
    r.designs.forEach(d => { content += `  ${d.agentName} — ${d.strategy.toUpperCase()} — ${d.name} (${d.cat}) — Rank #${d.rank}\n`; });
    content += `\nPROMPTS:\n`;
    r.designs.sort((a,b)=>a.rank-b.rank).forEach(d => { content += `  [${d.name}] ${d.prompt}\n`; });
    content += `\nTREND CONSENSUS:\n`;
    content += `  Emerging: ${r.trendData.emerging.join(', ')}\n`;
    content += `  Declining: ${r.trendData.declining.join(', ')}\n`;
    content += `\nFORWARD INTELLIGENCE:\n`;
    r.trendData.fi.forEach(f => { content += `  • ${f}\n`; });
    content += '\n' + '─'.repeat(50) + '\n\n';
  });
  const blob = new Blob([content], {type:'text/plain'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'JewelForge_Epoch_Intelligence_Archive.txt'; a.click();
}

/* ══════════════════════════════════
   PDF EXPORT
══════════════════════════════════ */

async function _ensureJsPDF() {
  if (window.jspdf && window.jspdf.jsPDF) return window.jspdf.jsPDF;
  // Attempt dynamic reload if CDN script failed on initial page load
  await new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.2/jspdf.umd.min.js';
    s.crossOrigin = 'anonymous';
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load jsPDF library. Check your network connection or ad-blocker settings.'));
    document.head.appendChild(s);
  });
  if (window.jspdf && window.jspdf.jsPDF) return window.jspdf.jsPDF;
  throw new Error('jsPDF library loaded but window.jspdf is not available.');
}

async function _ensureHtml2Canvas() {
  if (typeof html2canvas === 'function') return html2canvas;
  await new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
    s.crossOrigin = 'anonymous';
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load html2canvas library. Check your network connection or ad-blocker settings.'));
    document.head.appendChild(s);
  });
  if (typeof html2canvas === 'function') return html2canvas;
  throw new Error('html2canvas library loaded but is not available.');
}

function exportCurrentReportAsPDF() {
  const cycleNum = _currentViewedCycle || (cycleReports.length ? cycleReports[cycleReports.length-1].cycle : null);
  if (!cycleNum) { alert('No report to export.'); return; }
  const r = cycleReports.find(x=>x.cycle===cycleNum);
  if (!r) { alert('Report not found.'); return; }
  _buildReportPDF(r, `JewelForge_Cycle${cycleNum}_Report.pdf`);
}

function exportAllReportsAsPDF() {
  if (!cycleReports.length) { alert('No reports to export.'); return; }
  if (cycleReports.length === 1) {
    _buildReportPDF(cycleReports[0], `JewelForge_Cycle${cycleReports[0].cycle}_Report.pdf`);
    return;
  }
  _buildMultiReportPDF(cycleReports, 'JewelForge_Epoch_Intelligence_Archive.pdf');
}

async function _buildReportPDF(r, filename, opts) {
  const skipDownload = opts?.skipDownload || false;
  const showOverlay = opts?.showOverlay !== false;
  const statusEl = showOverlay ? _showPdfStatus('Generating PDF...') : null;
  try {
    const container = _createPdfContainer(r);
    document.body.appendChild(container);
    // Wait for images to load
    await _waitForImages(container, 8000);
    await new Promise(res => setTimeout(res, 300));

    const jsPDF = await _ensureJsPDF();
    await _ensureHtml2Canvas();
    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();
    const margin = 28;
    const contentW = pageW - margin * 2;

    // Render sections individually for better pagination
    const sections = container.querySelectorAll('.pdf-section');
    let yPos = margin;
    let firstPage = true;

    for (let i = 0; i < sections.length; i++) {
      if (statusEl) _updatePdfStatus(statusEl, `Rendering section ${i+1} of ${sections.length}...`);
      const sec = sections[i];
      const canvas = await html2canvas(sec, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#060606',
        logging: false,
        width: sec.scrollWidth,
        height: sec.scrollHeight
      });

      const imgData = canvas.toDataURL('image/png');
      const imgW = contentW;
      const imgH = (canvas.height / canvas.width) * imgW;

      // Check if section fits on current page
      if (!firstPage && yPos + imgH > pageH - margin) {
        pdf.addPage();
        yPos = margin;
      }

      // If section is taller than a full page, scale to fit or split
      if (imgH > pageH - margin * 2) {
        // Scale down to fit one page
        const scale = (pageH - margin * 2) / imgH;
        const scaledW = imgW * scale;
        const scaledH = imgH * scale;
        if (yPos > margin) { pdf.addPage(); yPos = margin; }
        pdf.addImage(imgData, 'PNG', margin + (contentW - scaledW) / 2, yPos, scaledW, scaledH);
        yPos = yPos + scaledH + 12;
      } else {
        pdf.addImage(imgData, 'PNG', margin, yPos, imgW, imgH);
        yPos += imgH + 12;
      }
      firstPage = false;
    }

    // Add page numbers
    const totalPages = pdf.internal.getNumberOfPages();
    for (let p = 1; p <= totalPages; p++) {
      pdf.setPage(p);
      pdf.setFontSize(7);
      pdf.setTextColor(138, 134, 128);
      pdf.text(`JewelForge — Cycle ${r.cycle} Intelligence Report — Page ${p} of ${totalPages}`, pageW / 2, pageH - 12, { align: 'center' });
    }

    if (!skipDownload) pdf.save(filename);
    container.remove();
    if (statusEl) _hidePdfStatus(statusEl);

    // Return base64 PDF data for upload
    const base64 = pdf.output('datauristring').split(',')[1];
    return base64;
  } catch(e) {
    console.error('PDF export error:', e);
    if (statusEl) _hidePdfStatus(statusEl);
    if (!skipDownload) alert('PDF export failed: ' + e.message);
    return null;
  }
}

async function _buildMultiReportPDF(reports, filename, opts) {
  const skipDownload = opts?.skipDownload || false;
  const showOverlay = opts?.showOverlay !== false;
  const statusEl = showOverlay ? _showPdfStatus('Generating multi-cycle PDF...') : null;
  try {
    const jsPDF = await _ensureJsPDF();
    await _ensureHtml2Canvas();
    const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'a4' });
    const pageW = pdf.internal.pageSize.getWidth();
    const pageH = pdf.internal.pageSize.getHeight();
    const margin = 28;
    const contentW = pageW - margin * 2;

    for (let ri = 0; ri < reports.length; ri++) {
      const r = reports[ri];
      if (ri > 0) pdf.addPage();
      if (statusEl) _updatePdfStatus(statusEl, `Rendering Cycle ${r.cycle} report (${ri+1}/${reports.length})...`);

      const container = _createPdfContainer(r);
      document.body.appendChild(container);
      await _waitForImages(container, 8000);
      await new Promise(res => setTimeout(res, 300));

      const sections = container.querySelectorAll('.pdf-section');
      let yPos = margin;

      for (let i = 0; i < sections.length; i++) {
        const sec = sections[i];
        const canvas = await html2canvas(sec, {
          scale: 2,
          useCORS: true,
          allowTaint: true,
          backgroundColor: '#060606',
          logging: false,
          width: sec.scrollWidth,
          height: sec.scrollHeight
        });

        const imgData = canvas.toDataURL('image/png');
        const imgW = contentW;
        const imgH = (canvas.height / canvas.width) * imgW;

        if (yPos > margin && yPos + imgH > pageH - margin) {
          pdf.addPage();
          yPos = margin;
        }

        if (imgH > pageH - margin * 2) {
          const scale = (pageH - margin * 2) / imgH;
          const scaledW = imgW * scale;
          const scaledH = imgH * scale;
          if (yPos > margin) { pdf.addPage(); yPos = margin; }
          pdf.addImage(imgData, 'PNG', margin + (contentW - scaledW) / 2, yPos, scaledW, scaledH);
          yPos = yPos + scaledH + 12;
        } else {
          pdf.addImage(imgData, 'PNG', margin, yPos, imgW, imgH);
          yPos += imgH + 12;
        }
      }

      container.remove();
    }

    // Add page numbers
    const totalPages = pdf.internal.getNumberOfPages();
    for (let p = 1; p <= totalPages; p++) {
      pdf.setPage(p);
      pdf.setFontSize(7);
      pdf.setTextColor(138, 134, 128);
      pdf.text(`JewelForge — Epoch Intelligence Archive — Page ${p} of ${totalPages}`, pageW / 2, pageH - 12, { align: 'center' });
    }

    if (!skipDownload) pdf.save(filename);
    if (statusEl) _hidePdfStatus(statusEl);

    // Return base64 PDF data for upload
    const base64 = pdf.output('datauristring').split(',')[1];
    return base64;
  } catch(e) {
    console.error('PDF export error:', e);
    if (statusEl) _hidePdfStatus(statusEl);
    if (!skipDownload) alert('PDF export failed: ' + e.message);
    return null;
  }
}

// ── PDF container builder: creates off-screen element with report content ──
function _createPdfContainer(r) {
  const fmtC = (n) => n.toLocaleString();
  const sign = (v) => v >= 0 ? '+' + v : '' + v;
  const corrStrength = (v) => Math.abs(v) > 0.7 ? 'Strong' : Math.abs(v) > 0.4 ? 'Moderate' : 'Weak';
  const winnerShare = r.winnerShare || Math.round(r.winner.credits / r.totalCredits * 100);
  const top3Share = r.top3Share || 0;
  const sp = r.stratPerf || {};
  const sortedAgents = [...(r.agentPerf || [])].sort((a, b) => a.rank - b.rank);
  const vel = r.trendData?.velocityScore || 70;

  // CSS for PDF rendering
  const pdfCSS = `
    .pdf-root { font-family: 'Rajdhani', Helvetica, Arial, sans-serif; background: #060606; color: #e8e4dc; width: 750px; padding: 0; }
    .pdf-section { padding: 16px 24px; margin-bottom: 0; }
    .pdf-header { border-bottom: 2px solid #8a6e30; padding-bottom: 14px; margin-bottom: 0; }
    .pdf-title { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 26px; font-weight: 300; color: #c9a84c; margin-bottom: 4px; }
    .pdf-meta { font-size: 10px; letter-spacing: 2.5px; color: #8a8680; text-transform: uppercase; }
    .pdf-sec-hdr { font-size: 10px; letter-spacing: 4px; color: #8a6e30; text-transform: uppercase; border-bottom: 1px solid rgba(201,168,76,0.14); padding-bottom: 6px; margin-bottom: 12px; margin-top: 4px; }

    /* KPI */
    .pdf-kpi { display: flex; gap: 1px; background: rgba(201,168,76,0.14); margin-bottom: 16px; }
    .pdf-kpi-cell { flex: 1; background: #0d0d0d; padding: 10px 8px; text-align: center; }
    .pdf-kpi-val { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 20px; color: #c9a84c; line-height: 1; }
    .pdf-kpi-val.up { color: #4caf7d; }
    .pdf-kpi-val.down { color: #b5332a; }
    .pdf-kpi-val.neu { color: #e8e4dc; }
    .pdf-kpi-lbl { font-size: 8px; letter-spacing: 2px; color: #3a3a38; text-transform: uppercase; margin-top: 4px; }

    /* Top 3 */
    .pdf-top3 { display: flex; gap: 1px; background: rgba(201,168,76,0.14); margin-bottom: 16px; }
    .pdf-top3-card { flex: 1; background: #141414; }
    .pdf-top3-card.rank1 { border-top: 3px solid #c9a84c; }
    .pdf-top3-card.rank2 { border-top: 3px solid #8a8680; }
    .pdf-top3-card.rank3 { border-top: 3px solid #3a3a38; }
    .pdf-top3-img { width: 100%; height: 200px; object-fit: cover; display: block; background: #1c1c1c; }
    .pdf-top3-meta { padding: 10px; }
    .pdf-top3-rank { font-size: 9px; letter-spacing: 2.5px; color: #3a3a38; text-transform: uppercase; margin-bottom: 3px; }
    .pdf-top3-rank.r1 { color: #c9a84c; }
    .pdf-top3-name { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 14px; color: #e8e4dc; margin-bottom: 2px; }
    .pdf-top3-by { font-size: 9px; color: #8a8680; }
    .pdf-top3-creds { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 16px; color: #c9a84c; margin-top: 4px; }
    .pdf-top3-scores { font-size: 9px; color: #3a3a38; margin-top: 3px; }

    /* Correlation */
    .pdf-corr { display: flex; gap: 1px; background: rgba(201,168,76,0.14); margin-bottom: 10px; }
    .pdf-corr-card { flex: 1; background: #0d0d0d; padding: 12px; }
    .pdf-corr-dim { font-size: 9px; letter-spacing: 2.5px; color: #8a6e30; text-transform: uppercase; margin-bottom: 8px; }
    .pdf-corr-track { height: 6px; background: #3a3a38; border-radius: 3px; overflow: hidden; margin-bottom: 6px; }
    .pdf-corr-fill { height: 100%; border-radius: 3px; }
    .pdf-corr-fill.aes { background: linear-gradient(90deg, #8a6e30, #c9a84c); }
    .pdf-corr-fill.nov { background: linear-gradient(90deg, #4a7fa8, #7bb8d4); }
    .pdf-corr-fill.pro { background: linear-gradient(90deg, #4caf7d, #7be0a8); }
    .pdf-corr-r { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 16px; color: #e8e4dc; }
    .pdf-corr-note { font-size: 9px; color: #3a3a38; margin-top: 3px; }
    .pdf-corr-badge { display: inline-block; font-size: 8px; letter-spacing: 1.5px; color: #c9a84c; border: 1px solid #8a6e30; padding: 2px 5px; text-transform: uppercase; margin-top: 4px; }
    .pdf-insight { font-size: 11px; color: #3a3a38; line-height: 1.6; margin-top: 6px; }
    .pdf-insight b { color: #e8e4dc; }

    /* Strategy */
    .pdf-strat { display: flex; gap: 1px; background: rgba(201,168,76,0.14); margin-bottom: 10px; }
    .pdf-sb-card { flex: 1; background: #0d0d0d; padding: 12px; position: relative; }
    .pdf-sb-card.winner { background: rgba(201,168,76,0.06); }
    .pdf-sb-label { font-size: 9px; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; padding: 2px 6px; border: 1px solid; display: inline-block; }
    .pdf-sb-label.exploit { border-color: #8a6e30; color: #8a6e30; }
    .pdf-sb-label.explore { border-color: #4a7fa8; color: #4a7fa8; }
    .pdf-sb-label.mutate { border-color: #7b6fa8; color: #7b6fa8; }
    .pdf-sb-creds { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 20px; margin-bottom: 3px; }
    .pdf-sb-sub { font-size: 9px; color: #3a3a38; }
    .pdf-sb-flag { position: absolute; top: 8px; right: 8px; font-size: 8px; letter-spacing: 1.5px; color: #c9a84c; border: 1px solid #8a6e30; padding: 2px 5px; text-transform: uppercase; }

    /* Tables */
    .pdf-table { width: 100%; border-collapse: collapse; font-size: 11px; margin-bottom: 8px; }
    .pdf-table th { font-size: 8px; letter-spacing: 2px; text-transform: uppercase; color: #8a6e30; border-bottom: 1px solid rgba(201,168,76,0.14); padding: 6px 8px; text-align: left; background: #0d0d0d; }
    .pdf-table td { padding: 5px 8px; border-bottom: 1px solid #1e1e1e; color: #8a8680; vertical-align: middle; line-height: 1.4; }
    .pdf-table tr:first-child td { color: #e8e4dc; }
    .pdf-table .gold { color: #c9a84c; font-family: 'Cormorant Garamond', Georgia, serif; }
    .pdf-table .grn { color: #4caf7d; }
    .pdf-table .red { color: #b5332a; }
    .pdf-rank-num { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 15px; color: #3a3a38; text-align: center; }
    .pdf-rank-num.r1 { color: #c9a84c; }

    /* Bar charts */
    .pdf-bar-wrap { display: inline-flex; align-items: center; gap: 4px; width: 80px; }
    .pdf-bar-track { flex: 1; height: 4px; background: #3a3a38; border-radius: 2px; overflow: hidden; }
    .pdf-bar-fill { height: 100%; border-radius: 2px; }
    .pdf-bar-val { font-size: 9px; color: #8a8680; width: 28px; text-align: right; flex-shrink: 0; }

    /* Vote flow */
    .pdf-vf-alloc { display: inline-block; background: rgba(201,168,76,0.08); border: 1px solid #4a3a18; padding: 1px 5px; font-size: 9px; margin: 1px 2px 1px 0; white-space: nowrap; }
    .pdf-vf-self { background: rgba(181,51,42,0.08); border-color: rgba(181,51,42,0.3); color: #b5332a; }
    .pdf-vote-insight { background: #0d0d0d; border: 1px solid rgba(201,168,76,0.14); padding: 8px 10px; font-size: 10px; color: #8a8680; line-height: 1.6; margin-top: 8px; }
    .pdf-vote-insight b { color: #e8e4dc; }

    /* Trend velocity */
    .pdf-vel { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    .pdf-vel-label { font-size: 9px; letter-spacing: 2px; color: #3a3a38; text-transform: uppercase; width: 55px; flex-shrink: 0; }
    .pdf-vel-meter { flex: 1; height: 8px; background: #3a3a38; border-radius: 4px; overflow: hidden; }
    .pdf-vel-fill { height: 100%; border-radius: 4px; background: linear-gradient(90deg, #8a6e30, #e8c97a); }
    .pdf-vel-score { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 16px; color: #c9a84c; width: 40px; text-align: right; flex-shrink: 0; }
    .pdf-trend-grid { display: flex; flex-wrap: wrap; gap: 1px; background: rgba(201,168,76,0.14); }
    .pdf-tcard { flex: 1; min-width: 48%; background: #0d0d0d; padding: 10px; }
    .pdf-tcard-label { font-size: 8px; letter-spacing: 2.5px; color: #8a6e30; text-transform: uppercase; margin-bottom: 5px; }
    .pdf-tcard-val { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 14px; color: #e8e4dc; }
    .pdf-tcard-val.up { color: #4caf7d; }
    .pdf-tcard-val.down { color: #b5332a; }
    .pdf-tcard-sub { font-size: 9px; color: #3a3a38; margin-top: 2px; }

    /* FI box */
    .pdf-fi { background: rgba(201,168,76,0.04); border: 1px solid #8a6e30; padding: 14px; margin-top: 6px; }
    .pdf-fi-title { font-size: 9px; letter-spacing: 3px; color: #c9a84c; text-transform: uppercase; margin-bottom: 10px; }
    .pdf-fi-item { display: flex; gap: 8px; margin-bottom: 6px; font-size: 10px; color: #8a8680; line-height: 1.5; }
    .pdf-fi-item::before { content: '\\25C6'; color: #8a6e30; font-size: 7px; margin-top: 3px; flex-shrink: 0; }

    /* Genome evolution */
    .pdf-genome-grid { display: flex; flex-wrap: wrap; gap: 1px; background: rgba(201,168,76,0.14); }
    .pdf-genome-card { flex: 1; min-width: 32%; background: #0d0d0d; padding: 10px; }
    .pdf-gc-hdr { display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
    .pdf-gc-name { font-size: 11px; font-weight: 600; color: #e8e4dc; }
    .pdf-gc-badge { font-size: 7px; letter-spacing: 1px; padding: 1px 4px; text-transform: uppercase; }
    .pdf-gc-badge.win { color: #c9a84c; border: 1px solid #8a6e30; }
    .pdf-gc-badge.loss { color: #b5332a; border: 1px solid rgba(181,51,42,0.3); }
    .pdf-gd-row { display: flex; align-items: center; gap: 4px; margin-bottom: 3px; }
    .pdf-gd-label { font-size: 9px; color: #8a8680; width: 70px; flex-shrink: 0; }
    .pdf-gd-track { flex: 1; height: 4px; background: #1e1e1e; border-radius: 2px; overflow: hidden; }
    .pdf-gd-fill { height: 100%; border-radius: 2px; }
    .pdf-gd-arrow { font-size: 9px; width: 30px; text-align: right; flex-shrink: 0; }
    .pdf-gd-arrow.up { color: #4caf7d; }
    .pdf-gd-arrow.down { color: #b5332a; }
    .pdf-gc-tags { margin-top: 4px; }
    .pdf-gt { display: inline-block; font-size: 8px; padding: 1px 4px; background: rgba(201,168,76,0.08); color: #8a8680; margin: 1px 2px 1px 0; }
    .pdf-gt.new { color: #4caf7d; }
    .pdf-gt.lost { color: #b5332a; text-decoration: line-through; }
    .pdf-gc-belief { font-size: 9px; color: #8a8680; margin-top: 4px; font-style: italic; }

    /* Epoch arc */
    .pdf-epoch { border: 1px solid #8a6e30; background: rgba(201,168,76,0.03); padding: 16px; margin-top: 6px; }
    .pdf-epoch-title { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 16px; color: #c9a84c; margin-bottom: 10px; }
    .pdf-epoch-timeline { display: flex; gap: 1px; background: rgba(201,168,76,0.14); margin-bottom: 12px; }
    .pdf-et-node { flex: 1; background: #0d0d0d; padding: 10px; text-align: center; }
    .pdf-et-cycle { font-size: 9px; color: #8a8680; margin-bottom: 3px; }
    .pdf-et-winner { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 13px; color: #e8e4dc; }
    .pdf-et-trend { font-size: 9px; color: #c9a84c; margin-top: 3px; }
    .pdf-et-creds { font-family: 'Cormorant Garamond', Georgia, serif; font-size: 14px; color: #c9a84c; margin-top: 3px; }
    .pdf-epoch-insight { font-size: 10px; color: #8a8680; line-height: 1.65; }
    .pdf-epoch-insight b { color: #e8e4dc; }

    /* Strat badge inline */
    .pdf-strat-badge { display: inline-block; font-size: 8px; letter-spacing: 1.5px; text-transform: uppercase; padding: 1px 5px; border: 1px solid; }
    .pdf-strat-badge.exploit { border-color: #8a6e30; color: #8a6e30; }
    .pdf-strat-badge.explore { border-color: #4a7fa8; color: #4a7fa8; }
    .pdf-strat-badge.mutate { border-color: #7b6fa8; color: #7b6fa8; }

    /* Prompt table */
    .pdf-prompt-box { background: #1c1c1c; border: 1px solid #3a3a38; padding: 6px; font-size: 9px; color: #4caf7d; font-family: 'Courier New', monospace; line-height: 1.5; }
  `;

  const container = document.createElement('div');
  container.className = 'pdf-root';
  container.style.cssText = 'position:absolute;left:-9999px;top:0;z-index:-1;';

  // ── Build bar helper ──
  const pdfBar = (val, max, col, w = 80) =>
    `<span class="pdf-bar-wrap" style="width:${w}px">
      <span class="pdf-bar-track"><span class="pdf-bar-fill" style="width:${Math.round(val/max*100)}%;background:${col}"></span></span>
      <span class="pdf-bar-val">${val}</span>
    </span>`;

  // ── Section: Header ──
  const headerHtml = `
    <div class="pdf-section pdf-header">
      <div class="pdf-title">Cycle ${r.cycle} — Intelligence Report</div>
      <div class="pdf-meta">Generated ${r.date} at ${r.time || ''} &nbsp;&middot;&nbsp; 6 Agents &nbsp;&middot;&nbsp; ${r.designs.length} Designs &nbsp;&middot;&nbsp; ${fmtC(r.totalCredits)} Credits Circulated</div>
    </div>`;

  // ── Section: KPI ──
  const kpiHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Key Performance Indicators</div>
      <div class="pdf-kpi">
        <div class="pdf-kpi-cell"><div class="pdf-kpi-val neu">${fmtC(r.winner.credits)}</div><div class="pdf-kpi-lbl">Winner Credits</div></div>
        <div class="pdf-kpi-cell"><div class="pdf-kpi-val">${winnerShare}%</div><div class="pdf-kpi-lbl">Winner Vote Share</div></div>
        <div class="pdf-kpi-cell"><div class="pdf-kpi-val">${top3Share}%</div><div class="pdf-kpi-lbl">Top 3 Capture</div></div>
        <div class="pdf-kpi-cell"><div class="pdf-kpi-val ${r.gini>0.4?'down':r.gini>0.25?'':'up'}">${r.gini}</div><div class="pdf-kpi-lbl">Gini Concentration</div></div>
        <div class="pdf-kpi-cell"><div class="pdf-kpi-val">${r.topCorr||'—'}</div><div class="pdf-kpi-lbl">Top Vote Predictor</div></div>
        <div class="pdf-kpi-cell"><div class="pdf-kpi-val ${(r.novSlope||0)>0?'up':'down'}">${sign(r.novSlope||0)}</div><div class="pdf-kpi-lbl">Novelty Premium/pt</div></div>
      </div>
    </div>`;

  // ── Section: Top 3 designs with images ──
  const top3Designs = r.sortedDesigns.slice(0, 3);
  const rankLabels = ['1st Place', '2nd Place', '3rd Place'];
  const top3Html = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Top 3 Designs — AI Rendered from Agent Prompts</div>
      <div class="pdf-top3">
        ${top3Designs.map((d, i) => {
          const cachedUrl = d.imageUrl || _designImageCache[r.cycle + '-' + d.agentIdx] || '';
          return `<div class="pdf-top3-card rank${i + 1}">
            ${cachedUrl ? `<img class="pdf-top3-img pdf-wait-img" src="${cachedUrl}" crossorigin="anonymous" />` : `<div class="pdf-top3-img" style="display:flex;align-items:center;justify-content:center;font-size:24px;color:#3a3a38;">No Image</div>`}
            <div class="pdf-top3-meta">
              <div class="pdf-top3-rank ${i === 0 ? 'r1' : ''}">${rankLabels[i]}</div>
              <div class="pdf-top3-name">"${d.name}"</div>
              <div class="pdf-top3-by">${d.agentName || 'Agent'} &middot; ${d.cat}</div>
              <div class="pdf-top3-creds">${fmtC(d.credits || 0)} Credits</div>
              <div class="pdf-top3-scores">AES ${d.aesthetic} &middot; NOV ${d.novelty} &middot; PRO ${d.profit}</div>
            </div>
          </div>`;
        }).join('')}
      </div>
    </div>`;

  // ── Section: Correlation ──
  const corrHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Score x Credits Correlation Analysis</div>
      <div class="pdf-corr">
        ${[
          { dim: 'Aesthetic', key: 'corrAes', cls: 'aes', col: '#c9a84c' },
          { dim: 'Novelty', key: 'corrNov', cls: 'nov', col: '#7bb8d4' },
          { dim: 'Profit', key: 'corrPro', cls: 'pro', col: '#7be0a8' },
        ].map(({ dim, key, cls, col }) => {
          const val = r[key] || 0;
          const isTop = r.topCorr === dim;
          return `<div class="pdf-corr-card">
            <div class="pdf-corr-dim">${dim} Score</div>
            <div class="pdf-corr-track"><div class="pdf-corr-fill ${cls}" style="width:${Math.round(Math.abs(val) * 100)}%"></div></div>
            <div class="pdf-corr-r" style="color:${col}">r = ${val}</div>
            <div class="pdf-corr-note">${corrStrength(val)} ${val >= 0 ? 'positive' : 'negative'} correlation with credits</div>
            ${isTop ? '<div class="pdf-corr-badge">Top Predictor</div>' : ''}
          </div>`;
        }).join('')}
      </div>
      <div class="pdf-insight">
        r = Pearson correlation coefficient. Values near &plusmn;1 indicate strong linear relationship between score and credits received.
        ${r.topCorr === 'Novelty' ? '<b>Novelty dominated this cycle</b> — agents are rewarding fresh ideas over safe margins.' :
          r.topCorr === 'Aesthetic' ? '<b>Aesthetic was the market driver</b> — visual design quality outweighed financial logic.' :
          '<b>Profit drove consensus</b> — agents voted rationally toward high-margin pieces.'}
      </div>
    </div>`;

  // ── Section: Strategy battle ──
  const stratHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Strategy Performance — Exploit vs Explore vs Mutate</div>
      <div class="pdf-strat">
        ${['exploit', 'explore', 'mutate'].map(s => {
          const d = sp[s] || { count: 0, avgCreds: 0 };
          const isWin = r.winner.strategy === s;
          const col = s === 'exploit' ? '#8a6e30' : s === 'explore' ? '#4a7fa8' : '#7b6fa8';
          return `<div class="pdf-sb-card ${isWin ? 'winner' : ''}">
            ${isWin ? '<div class="pdf-sb-flag">Winning Strategy</div>' : ''}
            <div class="pdf-sb-label ${s}">${s.toUpperCase()}</div>
            <div class="pdf-sb-creds" style="color:${col}">${fmtC(d.avgCreds)} Credits</div>
            <div class="pdf-sb-sub">avg per design &middot; ${d.count} design${d.count !== 1 ? 's' : ''}</div>
          </div>`;
        }).join('')}
      </div>
    </div>`;

  // ── Section: Category heat map ──
  const catHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Category Heat Map</div>
      <table class="pdf-table">
        <thead><tr><th>Category</th><th>Entries</th><th>Pool %</th><th>Avg Credits</th><th>Avg Aesthetic</th><th>Avg Novelty</th><th>Status</th></tr></thead>
        <tbody>${Object.entries(r.catMap || r.catCount).map(([cat, data]) => {
          const isObj = typeof data === 'object' && data !== null && 'count' in data;
          const count = isObj ? data.count : data;
          const avgC = isObj && data.totalCreds ? Math.round(data.totalCreds / count) : 0;
          const avgA = isObj && data.totalAes ? Math.round(data.totalAes / count) : 0;
          const avgN = isObj && data.totalNov ? Math.round(data.totalNov / count) : 0;
          const poolPct = Math.round(count / r.designs.length * 100);
          const status = poolPct > 45 ? '<span style="color:#b5332a">Over-saturated</span>' :
                         poolPct < 17 ? '<span style="color:#4caf7d">Opportunity</span>' : 'Balanced';
          return `<tr>
            <td><b>${cat}</b></td>
            <td>${count}</td>
            <td>${pdfBar(poolPct, 100, poolPct > 45 ? '#b5332a' : '#8a6e30', 60)}</td>
            <td>${avgC > 0 ? fmtC(avgC) : '—'}</td>
            <td>${avgA > 0 ? pdfBar(avgA, 100, '#c9a84c', 60) : '—'}</td>
            <td>${avgN > 0 ? pdfBar(avgN, 100, '#4a7fa8', 60) : '—'}</td>
            <td>${status}</td>
          </tr>`;
        }).join('')}</tbody>
      </table>
    </div>`;

  // ── Section: Agent leaderboard ──
  const lbHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Agent Leaderboard — Credits / ROI / Reputation</div>
      <table class="pdf-table">
        <thead><tr><th style="width:28px">#</th><th>Agent</th><th>Design</th><th>Strategy</th><th>Earned</th><th>Spent</th><th>ROI</th><th>Rep</th><th>Delta</th></tr></thead>
        <tbody>${sortedAgents.map((a, i) => `
          <tr>
            <td class="pdf-rank-num ${i === 0 ? 'r1' : ''}">${i + 1}</td>
            <td>${a.emoji || ''} ${a.name}${a.isUser ? ' (YOU)' : ''}</td>
            <td style="font-style:italic">"${a.designName}"</td>
            <td><span class="pdf-strat-badge ${a.strategy}">${a.strategy.toUpperCase()}</span></td>
            <td class="gold">${fmtC(a.earned)}</td>
            <td>${fmtC(a.spent)}</td>
            <td style="color:${a.roi >= 1 ? '#4caf7d' : '#b5332a'}">${a.roi}x</td>
            <td>${a.reputation}</td>
            <td style="color:${a.repDelta > 0 ? '#4caf7d' : a.repDelta < 0 ? '#b5332a' : '#8a8680'}">${sign(a.repDelta)}</td>
          </tr>`).join('')}
        </tbody>
      </table>
    </div>`;

  // ── Section: Genome evolution ──
  const dimLabels = {
    minimalism: 'Minimalism', novelty: 'Novelty', ornamentation: 'Ornament',
    marketFit: 'Market Fit', risk: 'Risk', marginSens: 'Margin Sens',
    symmetry: 'Symmetry', platBias: 'Platinum', coloredStone: 'Color Stone',
    diamond: 'Diamond', mixedMetal: 'Mix Metal', complexBudget: 'Complexity'
  };
  const evo = r.genomeEvolution || [];
  const genomeHtml = evo.length ? `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Agent Genome Evolution — Before / After Cycle ${r.cycle}</div>
      <div class="pdf-genome-grid">
        ${evo.map(ag => {
          const dims = Object.entries(ag.shifts || {})
            .filter(([, v]) => v !== 0)
            .sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]))
            .slice(0, 4);
          const newTags = (ag.styleTags || []).filter(t => !(ag.prevStyleTags || []).includes(t));
          const lostTags = (ag.prevStyleTags || []).filter(t => !(ag.styleTags || []).includes(t));
          const keptTags = (ag.styleTags || []).filter(t => (ag.prevStyleTags || []).includes(t));
          const badge = ag.rank === 1 ? '<span class="pdf-gc-badge win">WINNER</span>' :
                        ag.rank >= 6 ? '<span class="pdf-gc-badge loss">LAST</span>' : '';
          return `<div class="pdf-genome-card">
            <div class="pdf-gc-hdr">
              <span>${ag.emoji || ''}</span>
              <span class="pdf-gc-name">${ag.name}</span>
              ${badge}
            </div>
            ${dims.map(([key, delta]) => {
              const afterVal = ag.after?.[key] ?? 50;
              const col = delta > 0 ? '#4caf7d' : '#b5332a';
              return `<div class="pdf-gd-row">
                <span class="pdf-gd-label">${dimLabels[key] || key}</span>
                <span class="pdf-gd-track"><span class="pdf-gd-fill" style="width:${afterVal}%;background:${col}"></span></span>
                <span class="pdf-gd-arrow ${delta > 0 ? 'up' : 'down'}">${delta > 0 ? '↑' : '↓'}${Math.abs(delta)}</span>
              </div>`;
            }).join('')}
            ${keptTags.length || newTags.length || lostTags.length ? `<div class="pdf-gc-tags">
              ${keptTags.map(t => `<span class="pdf-gt">${t}</span>`).join('')}
              ${newTags.map(t => `<span class="pdf-gt new">+${t}</span>`).join('')}
              ${lostTags.map(t => `<span class="pdf-gt lost">${t}</span>`).join('')}
            </div>` : ''}
            ${ag.dominantBelief ? `<div class="pdf-gc-belief"><b>Belief:</b> "${ag.dominantBelief}"</div>` : ''}
          </div>`;
        }).join('')}
      </div>
    </div>` : '';

  // ── Section: Vote flow matrix ──
  const vm = r.voteMatrix || r.vm;
  const voteFlowHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Vote Flow Matrix</div>
      <table class="pdf-table">
        <thead><tr><th>Voter</th><th>Allocations (Self-votes highlighted)</th><th>Spent</th><th>Biggest Bet</th></tr></thead>
        <tbody>${(r.agentSnapshot || []).map((voter, vi) => {
          const voteData = vm?.[vi] || [];
          const total = voteData.reduce((s, v) => s + v, 0);
          const myDesignIdx = r.designs.findIndex(d => d.agentIdx === vi);
          const allocations = voteData.map((v, di) => {
            if (!v) return '';
            const dname = r.designs[di]?.name || '—';
            const isSelf = di === myDesignIdx;
            return `<span class="pdf-vf-alloc ${isSelf ? 'pdf-vf-self' : ''}">${dname}: ${fmtC(v)}${isSelf ? ' self' : ''}</span>`;
          }).filter(Boolean).join('');
          const biggestIdx = voteData.indexOf(Math.max(...voteData));
          const biggestName = r.designs[biggestIdx]?.name || '—';
          return `<tr>
            <td>${voter.emoji || ''} ${voter.name}</td>
            <td>${allocations || '—'}</td>
            <td class="gold">${fmtC(total)}</td>
            <td style="font-style:italic">"${biggestName}"</td>
          </tr>`;
        }).join('')}
        </tbody>
      </table>
      <div class="pdf-vote-insight">
        <b>Self-vote rate:</b> ${r.selfVotePct || 0}% of all credits went to agents' own designs &nbsp;&middot;&nbsp;
        <b>Strongest alignment:</b> ${(r.alignPair || ['—', '—']).join(' + ')} &nbsp;&middot;&nbsp;
        <b>Market consensus:</b> Top 3 captured ${top3Share}% of all credits
      </div>
    </div>`;

  // ── Section: Trend velocity ──
  const trendHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Trend Consensus and Velocity</div>
      <div class="pdf-vel">
        <span class="pdf-vel-label">Velocity</span>
        <span class="pdf-vel-meter"><span class="pdf-vel-fill" style="width:${vel}%"></span></span>
        <span class="pdf-vel-score">${vel}</span>
      </div>
      <div class="pdf-trend-grid">
        <div class="pdf-tcard"><div class="pdf-tcard-label">Emerging Styles</div><div class="pdf-tcard-val up">${(r.trendData?.emerging || []).join(' / ')}</div></div>
        <div class="pdf-tcard"><div class="pdf-tcard-label">Declining Styles</div><div class="pdf-tcard-val down">${(r.trendData?.declining || []).join(' / ')}</div></div>
        <div class="pdf-tcard"><div class="pdf-tcard-label">Saturation Warning</div><div class="pdf-tcard-val down">${r.trendData?.saturation || '—'}</div><div class="pdf-tcard-sub">Gini ${r.gini} concentration index</div></div>
        <div class="pdf-tcard"><div class="pdf-tcard-label">Treasury Signal</div><div class="pdf-tcard-val up">${r.trendData?.treasury || '—'}</div><div class="pdf-tcard-sub">Highest combined AES + PRO</div></div>
      </div>
    </div>`;

  // ── Section: Forward Intelligence ──
  const fiHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Forward Intelligence — Loaded into Agent Knowledge Base</div>
      <div class="pdf-fi">
        <div class="pdf-fi-title">Loaded into shared knowledge database at start of Cycle ${r.cycle + 1}</div>
        ${(r.trendData?.fi || []).map(f => `<div class="pdf-fi-item">${f}</div>`).join('')}
      </div>
    </div>`;

  // ── Section: Epoch Arc (cycle 3) ──
  let epochHtml = '';
  if (r.cycle === 3 && cycleReports.length === 3) {
    const [c1, c2, c3] = cycleReports;
    const epochTrends = ['Minimal / Negative-space', 'Architectural Minimal', 'Organic / Sculptural'];
    epochHtml = `
      <div class="pdf-section">
        <div class="pdf-sec-hdr">Epoch Arc — Full Trend Lifecycle</div>
        <div class="pdf-epoch">
          <div class="pdf-epoch-title">Epoch Arc — 3-Cycle Trend Lifecycle</div>
          <div class="pdf-epoch-timeline">
            ${[c1, c2, c3].map((cx, i) => `
              <div class="pdf-et-node">
                <div class="pdf-et-cycle">Cycle ${cx.cycle} &middot; ${cx.date}</div>
                <div class="pdf-et-winner">"${cx.winner.name}"</div>
                <div class="pdf-et-trend">${epochTrends[i]}</div>
                <div class="pdf-et-creds">${fmtC(cx.winner.credits)} Credits</div>
              </div>`).join('')}
          </div>
          <div class="pdf-epoch-insight">
            <b>Trend lifecycle confirmed:</b> ${epochTrends[0]} emerged in Cycle 1 (${fmtC(c1.winner.credits)} winner),
            peaked in Cycle 2 under exploitation pressure (${fmtC(c2.winner.credits)}, saturation ${c2.trendData?.saturation}),
            and was displaced in Cycle 3 as ${epochTrends[2]} generated the highest vote concentration (${fmtC(c3.winner.credits)}, Gini ${c3.gini}).
            <br><br>
            <b>Vote predictor evolution:</b> C1 ${c1.topCorr} (r=${c1.corrAes}) → C2 ${c2.topCorr} (r=${c2.corrAes}) → C3 ${c3.topCorr} (r=${c3.corrNov}).
            <br><br>
            <b>Compounding novelty premium:</b> C1 ${sign(c1.novSlope)}/pt → C2 ${sign(c2.novSlope)}/pt → C3 ${sign(c3.novSlope)}/pt.
            <br><br>
            <b>Full epoch circulated:</b> ${fmtC((c1.totalCredits || 0) + (c2.totalCredits || 0) + (c3.totalCredits || 0))} Credits across 18 designs.
          </div>
        </div>
      </div>`;
  }

  // ── Section: Image generation prompts ──
  const promptHtml = `
    <div class="pdf-section">
      <div class="pdf-sec-hdr">Image Generation Prompts (Claude-Refined)</div>
      <table class="pdf-table">
        <thead><tr><th style="width:120px">Design</th><th>Claude-Refined Prompt</th><th style="width:30%">Raw Agent Prompt</th></tr></thead>
        <tbody>${[...r.designs].sort((a, b) => a.rank - b.rank).map(d => `
          <tr${d.rank <= 3 ? ' style="color:#e8e4dc"' : ''}>
            <td><b>${d.rank === 1 ? '#1 ' : '#' + d.rank + ' '}${d.name}</b><br><span style="color:#3a3a38;font-size:9px">${d.agentName || 'Agent'}</span></td>
            <td><div class="pdf-prompt-box">${d.prompt}</div></td>
            <td><div class="pdf-prompt-box" style="opacity:.6;font-size:8px">${d.rawPrompt || d.prompt}</div></td>
          </tr>`).join('')}
        </tbody>
      </table>
    </div>`;

  // ── Assemble ──
  container.innerHTML = `<style>${pdfCSS}</style>
    ${headerHtml}
    ${kpiHtml}
    ${top3Html}
    ${corrHtml}
    ${stratHtml}
    ${catHtml}
    ${lbHtml}
    ${genomeHtml}
    ${voteFlowHtml}
    ${trendHtml}
    ${fiHtml}
    ${epochHtml}
    ${promptHtml}`;

  return container;
}

// ── Wait for images in container to load ──
function _waitForImages(container, timeout) {
  const imgs = container.querySelectorAll('img.pdf-wait-img');
  if (!imgs.length) return Promise.resolve();
  return new Promise(resolve => {
    let loaded = 0;
    const total = imgs.length;
    const done = () => { if (++loaded >= total) resolve(); };
    const timer = setTimeout(resolve, timeout);
    imgs.forEach(img => {
      if (img.complete && img.naturalWidth > 0) { done(); return; }
      img.onload = done;
      img.onerror = done;
    });
  });
}

// ── PDF status overlay ──
function _showPdfStatus(msg) {
  const el = document.createElement('div');
  el.id = 'pdf-status-overlay';
  el.style.cssText = 'position:fixed;inset:0;z-index:10000;background:rgba(6,6,6,.85);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:1rem;';
  el.innerHTML = `
    <div style="font-family:'Cormorant Garamond',serif;font-size:1.4rem;color:#c9a84c;">Generating PDF</div>
    <div id="pdf-status-msg" style="font-family:'Rajdhani',sans-serif;font-size:.85rem;color:#8a8680;letter-spacing:.1em">${msg}</div>
    <div style="width:120px;height:3px;background:#1e1e1e;border-radius:2px;overflow:hidden"><div style="width:0%;height:100%;background:linear-gradient(90deg,#8a6e30,#c9a84c);border-radius:2px;animation:pdfProgress 2s ease-in-out infinite" id="pdf-prog-bar"></div></div>
    <style>@keyframes pdfProgress{0%{width:0%}50%{width:80%}100%{width:100%}}</style>`;
  document.body.appendChild(el);
  return el;
}

function _updatePdfStatus(el, msg) {
  const m = el?.querySelector('#pdf-status-msg');
  if (m) m.textContent = msg;
}

function _hidePdfStatus(el) {
  if (el) el.remove();
}

/* ══════════════════════════════════
   NAVIGATION
══════════════════════════════════ */
function goTo(n) {
  document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));
  document.getElementById('screen-'+n).classList.add('active');
  ['nt0','nt1','nt2','nt3'].forEach((id,i)=>{
    const el=document.getElementById(id); el.className='nav-tab';
    if(i<n) el.classList.add('done'); else if(i===n) el.classList.add('active');
  });
}

function setSpd(s,btn){ speed=s; document.querySelectorAll('.spd-btn').forEach(b=>b.classList.remove('on')); btn.classList.add('on'); }

// Init
updatePreview(); renderDNA();
</script>
<!-- Agent Profile Modal -->
<div class="agent-modal-overlay" id="agent-modal-overlay" onclick="if(event.target===this)closeAgentModal()">
  <div class="agent-modal" id="agent-modal"></div>
</div>

</body>
</html>
